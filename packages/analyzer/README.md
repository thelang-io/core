# the/analyzer
The programming language analyzer

## Installation

```bash
the install the/analyzer
```

## Example usage

```the
import analyzer from "the/analyze"
```

## API

### `analyze (f: ref Parser.File) str[]`
Analyzes and generates errors for parsed file.

**Parameters**

- `f` - file parser by Parser

**Return value**

Errors generated by analyzer.

**Examples**

```the
mut f := Parser.parse("path/to/file")
error := analyze(ref f)
```

### `largest (a: ref Type, b: ref Type) ref Type`
Find largest type among two passed types.

**Parameters**

- `a` - first type to check
- `b` - second type to check

**Return value**

Largest type among two passed types.

**Examples**

```the
tm := TypeMap{}
c := largest(tm.get("int"), tm.get("i8"))
```

### `match (type1: ref Type, type2: ref Type) bool`
Check whether one type strictly matches another.

**Parameters**

- `type1` - first type to check
- `type2` - second type to check

**Return value**

Whether one type strictly matches another.

**Examples**

```the
tm := TypeMap{}
result := match(tm.get("int"), tm.get("i8"))
```

### `similarTo (typeToCompare: ref Type, similarToType: ref Type) bool`
Check whether one type is similar another.

**Parameters**

- `typeToCompare` - type to compare from
- `similarToType` - type to compare to

**Return value**

Whether one type is similar another.

**Examples**

```the
tm := TypeMap{}
result := similarTo(tm.get("i8"), tm.get("int"))
```

### `unwrap (t: ref Type, withOptional := false, withReference := true) ref Type`
Recursively unwraps alias type and returns underlying type.

**Parameters**

- `t` - type to unwrap
- `withOptional` - whether to treat optional type as type to unwrap. Defaults to `false`
- `withReference` - whether to treat reference type as type to unwrap. Defaults to `true`

**Return value**

Underlying type of type to unwrap.

**Examples**

```the
tm := TypeMap{}
t := unwrap(tm.get("int"))
```

### `AnalyzerExport.get (mut exports: ref Type.NamespaceMember[], name: str) ref Type.NamespaceMember`
Goes through exports and finds export with matching name.

**Parameters**

- `exports` - exports to go through
- `name` - name to search for

**Return value**

Found export with matching name.

**Exceptions**

- `Error` - throw if export you are looking for doesn't exist.

**Examples**

```the
exportItem := AnalyzerExport.get(ref exports, "name")
```

### `AnalyzerExport.has (exports: ref Type.NamespaceMember[], name: str) bool`
Checks whether export with matching name exists in passed exports.

**Parameters**

- `exports` - exports to go through
- `name` - name to search for

**Return value**

Whether export with matching name exists in passed exports.

**Examples**

```the
result := AnalyzerExport.has(ref exports, "name")
```

### `Type.asAlias () ref AliasType`
### `Type.asArray () ref ArrayType`
### `Type.asEnum () ref EnumType`
### `Type.asFunction () ref FunctionType`
### `Type.asMap () ref MapType`
### `Type.asMethod () ref MethodType`
### `Type.asNamespace () ref NamespaceType`
### `Type.asObject () ref ObjectType`
### `Type.asOptional () ref OptionalType`
### `Type.asReference () ref ReferenceType`
### `Type.asUnion () ref UnionType`
These methods are shortcuts for `as` expression.

**Return value**

Body casted to corresponding body type.

**Examples**

```the
type.asAlias()
```

### `Type.isAlias () bool`
### `Type.isArray () bool`
### `Type.isEnum () bool`
### `Type.isFunction () bool`
### `Type.isMap () bool`
### `Type.isMethod () bool`
### `Type.isNamespace () bool`
### `Type.isObject () bool`
### `Type.isOptional () bool`
### `Type.isReference () bool`
### `Type.isUnion () bool`
These methods are shortcuts for `is` expression.

**Return value**

Whether expression's body contains corresponding type.

**Examples**

```the
type.isAlias()
```

### `Type.canBe (t: ref Type) bool`
Checks whether type can be cast to another type (should be used only on union type).

**Parameters**

- `t` - another type to check if possible to cast to

**Return value**

Whether type can be cast to another type.

**Examples**

```the
mut tm := TypeMap{}
type.canBe(tm.get("int"))
```

### `Type.get (nameOrIndex: int | str) TypeProperty`
Finds type's property with specified name or index.

**Parameters**

- `nameOrIndex` - name or index to search for

**Return value**

Type's property with specified name or index.

**Exceptions**

- `Error` - throw if tried to get non-existing property.

**Examples**

```the
property1 := type.get("name")
property2 := type.get(1)
```

### `Type.has (nameOrIndex: int | str) bool`
Checks whether type has property with specified name or index.

**Parameters**

- `nameOrIndex` - name or index to search for

**Return value**

Whether type has property with specified name or index.

**Examples**

```the
result1 := type.has("name")
result2 := type.has(1)
```

### `Type.hasEnumerator (name: str) bool`
Checks whether enum type has enumerator with specified name (should be used only on enum type).

**Parameters**

- `name` - name of enumerator to search for

**Return value**

Whether enum type has enumerator with specified name.

**Examples**

```the
result := type.hasEnumerator("Color")
```

### `Type.hasType (search: ref Type) bool`
Checks whether union type has specified sub type (should be used only on union type).

**Parameters**

- `search` - type to search for

**Return value**

Whether union type has specified sub type.

**Examples**

```the
mut tm := TypeMap{}
result := type.hasType(tm.get("int))
```

### `Type.isErrorLike () bool`
Checks whether type looks like error object (with first 'message' property of `str` type and second 'stack' property of `str` type).

**Return value**

Whether type looks like error object.

**Examples**

```the
result := type.isErrorLike()
```

### `Type.isFloat () bool`
Checks whether type is floating point type.

**Return value**

Whether type is floating point type.

**Examples**

```the
result := type.isFloat()
```

### `Type.isInt () bool`
Checks whether type is integer type.

**Return value**

Whether type is integer type.

**Examples**

```the
result := type.isInt()
```

### `Type.isNumber () bool`
Checks whether type floating point or integer type.

**Return value**

Whether type floating point or integer type.

**Examples**

```the
result := type.isNumber()
```

### `Type.isRequired () bool`
Checks whether type is required to have an initializer.

**Return value**

Whether type is required to have an initializer.

**Examples**

```the
result := type.isRequired()
```

### `Type.isSignedInt () bool`
Checks whether type is signed integer type.

**Return value**

Whether type is signed integer type.

**Examples**

```the
result := type.isSignedInt()
```

### `Type.isUnsignedInt () bool`
Checks whether type is unsigned integer type.

**Return value**

Whether type is unsigned integer type.

**Examples**

```the
result := type.isUnsignedInt()
```

### `Type.toString () str`
Returns string representation of the type.

**Return value**

String representation of the type.

**Exceptions**

- `Error` - throw if tried stringify on unknown type.

**Examples**

```the
result := type.toString()
```
