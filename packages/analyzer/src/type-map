/*!
 * Copyright (c) Aaron Delasy
 * Licensed under the MIT License
 */

import TypeArray from "./type-array"
import * as Type from "./type"

export obj TypeMap {
  mut items: TypeArray
  mut _placeholder: (ref Type.Type)?

  fn init (mut self: ref Self) {
    self.items.push(Type.Type{name: "str", body: Type.ObjectType{}})
    self.createObject("any")
    self.createObject("bool")
    self.createObject("byte")
    self.createObject("char")
    self.createObject("f32")
    self.createObject("f64")
    self.createAlias("float", self.get("f64"))
    self.createObject("i8")
    self.createObject("i16")
    self.createObject("i32")
    self.createObject("i64")
    self.createAlias("int", self.get("i32"))
    self.createObject("u8")
    self.createObject("u16")
    self.createObject("u32")
    self.createObject("u64")
    self.createObject("void")
  }

  fn placeholder (mut self: ref Self) ref Type.Type {
    if self._placeholder != nil {
      return self._placeholder
    }

    self.items.push(Type.Type{body: Type.EmptyType{}})
    self._placeholder = Type.opt(self.items.last())
    return self.placeholder()
  }

  // todo insert actual properties for each type

  fn createAlias (mut self: ref Self, name: str, t := self.placeholder()) ref Type.Type {
    self.items.push(Type.Type{name: name, body: Type.AliasType{t: t}})
    return self.items.last()
  }

  fn createArray (mut self: ref Self, elementType: ref Type.Type) ref Type.Type {
    self.items.push(Type.Type{body: Type.ArrayType{elementType: elementType}})
    result := self.items.last()
    result.properties.push(Type.TypeProperty{
      name: "str",
      t: self.createMethod(false, [], self.get("str"), true, false, "self", result),
      mutable: false,
      builtin: true
    })
    return result
  }

  fn createEnum (mut self: ref Self, name: str, members: (ref Type.Type)[] = []) ref Type.Type {
    self.items.push(Type.Type{name: name, body: Type.EnumType{members: members}})
    result := self.items.last()
    result.properties.push(Type.TypeProperty{
      name: "str",
      t: self.createMethod(false, [], self.get("str"), true, false, "self", result),
      mutable: false,
      builtin: true
    })
    return result
  }

  fn createEnumerator (mut self: ref Self, name: str) ref Type.Type {
    self.items.push(Type.Type{name: name, body: Type.EnumeratorType{}})
    result := self.items.last()
    result.properties.push(Type.TypeProperty{
      name: "str",
      t: self.createMethod(false, [], self.get("str"), true, false, "self", result),
      mutable: false,
      builtin: true
    })
    return result
  }

  fn createFunction (
    mut self: ref Self,
    asynchronous: bool,
    parameters: Type.TypeParameter[],
    returnType: ref Type.Type
  ) ref Type.Type {
    self.items.push(Type.Type{
      body: Type.FunctionType{
        asynchronous: asynchronous,
        parameters: parameters,
        returnType: returnType
      }
    })

    result := self.items.last()
    result.properties.push(Type.TypeProperty{
      name: "name",
      t: self.get("str"),
      mutable: true,
      builtin: true
    })
    return result
  }

  fn createMap (mut self: ref Self, keyType: ref Type.Type, valueType: ref Type.Type) ref Type.Type {
    self.items.push(Type.Type{body: Type.MapType{keyType: keyType, valueType: valueType}})
    result := self.items.last()
    result.properties.push(Type.TypeProperty{
      name: "str",
      t: self.createMethod(false, [], self.get("str"), true, false, "self", result),
      mutable: false,
      builtin: true
    })
    return result
  }

  fn createMethod (
    mut self: ref Self,
    asynchronous: bool,
    parameters: Type.TypeParameter[],
    returnType: ref Type.Type,
    withSelf: bool,
    selfMutable: bool,
    selfName: str,
    selfType: ref Type.Type
  ) ref Type.Type {
    self.items.push(Type.Type{
      body: Type.MethodType{
        asynchronous: asynchronous,
        parameters: parameters,
        returnType: returnType,
        withSelf: withSelf,
        selfMutable: selfMutable,
        selfName: selfName,
        selfType: selfType
      }
    })

    result := self.items.last()
    result.properties.push(Type.TypeProperty{
      name: "name",
      t: self.get("str"),
      mutable: true,
      builtin: true
    })
    return result
  }

  fn createNamespace (mut self: ref Self, name: str, properties: Type.TypeProperty[] = []) ref Type.Type {
    self.items.push(Type.Type{name: name, properties: properties, body: Type.NamespaceType{}})
    return self.items.last()
  }

  fn createObject (mut self: ref Self, name: str, properties: Type.TypeProperty[] = []) ref Type.Type {
    self.items.push(Type.Type{name: name, properties: properties, body: Type.ObjectType{}})
    result := self.items.last()
    result.properties.push(Type.TypeProperty{
      name: "str",
      t: self.createMethod(false, [], self.get("str"), true, false, "self", result),
      mutable: false,
      builtin: true
    })
    return result
  }

  fn createOptional (mut self: ref Self, t: ref Type.Type) ref Type.Type {
    self.items.push(Type.Type{body: Type.OptionalType{t: t}})
    result := self.items.last()
    result.properties.push(Type.TypeProperty{
      name: "str",
      t: self.createMethod(false, [], self.get("str"), true, false, "self", result),
      mutable: false,
      builtin: true
    })
    return result
  }

  fn createReference (mut self: ref Self, t: ref Type.Type) ref Type.Type {
    self.items.push(Type.Type{body: Type.ReferenceType{t: t}})
    return self.items.last()
  }

  fn createUnion (mut self: ref Self, types: (ref Type.Type)[]) ref Type.Type {
    self.items.push(Type.Type{body: Type.UnionType{types: types}})
    result := self.items.last()
    result.properties.push(Type.TypeProperty{
      name: "str",
      t: self.createMethod(false, [], self.get("str"), true, false, "self", result),
      mutable: false,
      builtin: true
    })
    return result
  }

  fn get (mut self: ref Self, name: str) ref Type.Type {
    loop i := self.items.len - 1; i >= 0; i-- {
      item := self.items.at(i)

      if item.name == name {
        return item
      }
    }

    throw error_NewError("Type `" + name + "` doesn't exists")
  }

  fn has (mut self: ref Self, name: str) bool {
    loop i := self.items.len - 1; i >= 0; i-- {
      item := self.items.at(i)

      if item.name == name {
        return true
      }
    }

    return false
  }

  fn unionAdd (mut self: ref Self, a: ref Type.Type, b: ref Type.Type) ref Type.Type {
    if !a.isUnion() {
      return self.createUnion([a, b])
    }

    t := a.asUnion()
    types := t.types
    types.push(b)
    return self.createUnion(types)
  }

  fn unionSub (mut self: ref Self, a: ref Type.Type, b: ref Type.Type) ref Type.Type {
    t := a.asUnion()
    mut types := t.types

    loop i := types.len - 1; i >= 0; i-- {
      if Type.match(types[i] as ref Type.Type, b) {
        types.remove(i)
      }
    }

    if types.len == 1 {
      return types[0] as ref Type.Type
    }

    return self.createUnion(types)
  }

  fn updateAlias (mut self: ref Self, name: str, aliasedType: ref Type.Type) ref Type.Type {
    mut foundType := self.get(name)

    if foundType.isAlias() {
      mut t := foundType.asAlias()
      t.t = aliasedType
    }

    return foundType
  }

  fn updateEnum (mut self: ref Self, name: str, members: (ref Type.Type)[]) ref Type.Type {
    mut foundType := self.get(name)

    if foundType.isEnum() {
      mut t := foundType.asEnum()
      t.members = members
    }

    return foundType
  }
}
