/*!
 * Copyright (c) Aaron Delasy
 * Licensed under the MIT License
 */

import TypeArray from "./type-array"
import * as Type from "./type"

export obj TypeMap {
  mut items: TypeArray
  mut _self: (ref Type.Type)?

  fn init (mut self: ref Self) {
    self.items.push(Type.Type{name: "str", body: Type.ObjectType{}})
    self.createObject("any")
    self.createObject("bool")
    self.createObject("byte")
    self.createObject("char")
    self.createObject("f32")
    self.createObject("f64")
    self.createAlias("float", self.get("f64"))
    self.createObject("i8")
    self.createObject("i16")
    self.createObject("i32")
    self.createObject("i64")
    self.createAlias("int", self.get("i32"))
    self.createObject("isize")
    self.createObject("rune")
    self.createObject("u8")
    self.createObject("u16")
    self.createObject("u32")
    self.createObject("u64")
    self.createObject("usize")
    self.createObject("void")
  }

  // todo insert actual properties for each type

  fn createAlias (mut self: ref Self, name: str, t: ref Type.Type) ref Type.Type {
    self.items.push(Type.Type{name: name, body: Type.AliasType{t: t}})
    return self.items.last()
  }

  fn createArray (mut self: ref Self, elementType: ref Type.Type) ref Type.Type {
    self.items.push(Type.Type{body: Type.ArrayType{elementType: elementType}})
    result := self.items.last()
    result.properties.push(Type.TypeProperty{
      name: "str",
      t: self.createMethod(false, [], self.get("str"), true, false, "self", result),
      mutable: false,
      builtin: true
    })
    return result
  }

  fn createEnum (mut self: ref Self, name: str, members: str[]) ref Type.Type {
    self.items.push(Type.Type{name: name, body: Type.EnumType{members: members}})
    result := self.items.last()
    result.properties.push(Type.TypeProperty{
      name: "str",
      t: self.createMethod(false, [], self.get("str"), true, false, "self", result),
      mutable: false,
      builtin: true
    })
    return result
  }

  fn createFunction (
    mut self: ref Self,
    asynchronous: bool,
    parameters: Type.TypeParameter[],
    returnType: ref Type.Type
  ) ref Type.Type {
    self.items.push(Type.Type{
      body: Type.FunctionType{
        asynchronous: asynchronous,
        parameters: parameters,
        returnType: returnType
      }
    })

    result := self.items.last()
    result.properties.push(Type.TypeProperty{
      name: "name",
      t: self.get("str"),
      mutable: true,
      builtin: true
    })
    return result
  }

  fn createMap (mut self: ref Self, keyType: ref Type.Type, valueType: ref Type.Type) ref Type.Type {
    self.items.push(Type.Type{body: Type.MapType{keyType: keyType, valueType: valueType}})
    result := self.items.last()
    result.properties.push(Type.TypeProperty{
      name: "str",
      t: self.createMethod(false, [], self.get("str"), true, false, "self", result),
      mutable: false,
      builtin: true
    })
    return result
  }

  fn createMethod (
    mut self: ref Self,
    asynchronous: bool,
    parameters: Type.TypeParameter[],
    returnType: ref Type.Type,
    withSelf: bool,
    selfMutable: bool,
    selfName: str,
    selfType: ref Type.Type
  ) ref Type.Type {
    self.items.push(Type.Type{
      body: Type.MethodType{
        asynchronous: asynchronous,
        parameters: parameters,
        returnType: returnType,
        withSelf: withSelf,
        selfMutable: selfMutable,
        selfName: selfName,
        selfType: selfType
      }
    })

    result := self.items.last()
    result.properties.push(Type.TypeProperty{
      name: "name",
      t: self.get("str"),
      mutable: true,
      builtin: true
    })
    return result
  }

  fn createNamespace (mut self: ref Self, name: str, properties: Type.TypeProperty[] = []) ref Type.Type {
    self.items.push(Type.Type{name: name, properties: properties, body: Type.NamespaceType{}})
    return self.items.last()
  }

  fn createObject (mut self: ref Self, name: str, properties: Type.TypeProperty[] = []) ref Type.Type {
    self.items.push(Type.Type{name: name, properties: properties, body: Type.ObjectType{}})
    result := self.items.last()
    result.properties.push(Type.TypeProperty{
      name: "str",
      t: self.createMethod(false, [], self.get("str"), true, false, "self", result),
      mutable: false,
      builtin: true
    })
    return result
  }

  fn createOptional (mut self: ref Self, t: ref Type.Type) ref Type.Type {
    self.items.push(Type.Type{body: Type.OptionalType{t: t}})
    result := self.items.last()
    result.properties.push(Type.TypeProperty{
      name: "str",
      t: self.createMethod(false, [], self.get("str"), true, false, "self", result),
      mutable: false,
      builtin: true
    })
    return result
  }

  fn createReference (mut self: ref Self, t: ref Type.Type) ref Type.Type {
    self.items.push(Type.Type{body: Type.ReferenceType{t: t}})
    return self.items.last()
  }

  fn createUnion (mut self: ref Self, types: (ref Type.Type)[]) ref Type.Type {
    self.items.push(Type.Type{body: Type.UnionType{types: types}})
    result := self.items.last()
    result.properties.push(Type.TypeProperty{
      name: "str",
      t: self.createMethod(false, [], self.get("str"), true, false, "self", result),
      mutable: false,
      builtin: true
    })
    return result
  }

  fn get (mut self: ref Self, name: str) ref Type.Type {
    if name == "Self" && self._self != nil {
      return self._self
    }

    loop i := self.items.len - 1; i >= 0; i-- {
      item := self.items.at(i)

      if item.name == name {
        return item
      }
    }

    throw error_NewError("Type `" + name + "` doesn't exists")
  }

  fn getSelf (mut self: ref Self) (ref Type.Type)? {
    return self._self
  }

  fn has (mut self: ref Self, name: str) bool {
    if name == "Self" && self._self != nil {
      return true
    }

    loop i := self.items.len - 1; i >= 0; i-- {
      item := self.items.at(i)

      if item.name == name {
        return true
      }
    }

    return false
  }

  fn setSelf (mut self: ref Self, value: (ref Type.Type)?) void {
    self._self = value
  }

  fn unionAdd (mut self: ref Self, a: ref Type.Type, b: ref Type.Type) ref Type.Type {
    if !a.isUnion() {
      return self.createUnion([a, b])
    }

    t := a.asUnion()
    types := t.types
    types.push(b)
    return self.createUnion(types)
  }

  fn unionSub (mut self: ref Self, a: ref Type.Type, b: ref Type.Type) ref Type.Type {
    t := a.asUnion()
    mut types := t.types

    loop i := types.len - 1; i >= 0; i-- {
      if Type.match(types[i] as ref Type.Type, b) {
        types.remove(i)
      }
    }

    if types.len == 1 {
      return types[0] as ref Type.Type
    }

    return self.createUnion(types)
  }
}
