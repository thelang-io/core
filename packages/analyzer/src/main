/*!
 * Copyright (c) Aaron Delasy
 * Licensed under the MIT License
 */

import * as Parser from "the/parser"
import Type from "./type-map"
import * as TypeMap from "./type-map"
import * as VarMap from "./var-map"
import * as errors from "./errors"

export obj GuessTypeResult {
  first: Type
  second: Type
}

export obj TypeCastResult {
  consequent: Type[str]
  alternate: Type[str]
}

export fn expressionUnwrap (it: Parser.Expression) Parser.Expression {
  if it.isParenthesized() {
    expression := it.asParenthesized()
    return expressionUnwrap(expression.expression)
  }

  return it
}

export fn functionParameterInitializer (parameter: Parser.FunctionParameter) Parser.Expression {
  return parameter.initializer as Parser.Expression
}

export fn variableDeclarationInitializer (statement: Parser.VariableDeclaration) Parser.Expression {
  return statement.initializer as Parser.Expression
}

export obj Analyzer {
  mut errors: str[]
  mut reader: Parser.Reader
  mut tc: Type[str]
  mut tm: TypeMap.TypeMap
  mut vm: VarMap.VarMap

  // todo function|method missing return
  // todo object declaration builtin method `str` should have strict signature

  fn analyze (mut self: ref Self, it: Parser.Statement) {
    if it.isExpression() {
      statement := it.asExpression()
      self.e(statement.expression)
    } elif it.isVariableDeclaration() {
      statement := it.asVariableDeclaration()

      // todo global non-const
      // todo non-global const

      if self.vm.has(statement.name.name) {
        self.raise(errors.E1000(statement.name.name), statement.name.start, statement.name.end)
        return
      }

      varType := statement.t == nil
        ? self.e(statement.initializer as Parser.Expression)
        : self.t(statement.t)

      if statement.t != nil && statement.initializer != nil {
        initializerType := self.e(statement.initializer, varType)

        if !TypeMap.match(varType, initializerType) {
          self.raise(
            errors.E1005(initializerType.toString(), varType.toString()),
            statement.initializer.start,
            statement.initializer.end
          )
        }
      }

      self.vm.add(statement.name.name, varType, statement.mutable)
    }
  }

  // todo check ref being passed into non ref

  fn e (mut self: ref Self, it: Parser.Expression, targetType: Type? = nil, withMutable := false) Type {
    if it.isIdentifier() {
      expression := it.asIdentifier()

      if !self.vm.has(expression.name) {
        self.raise(errors.E1003(expression.name), it.start, it.end)
        return targetType == nil ? self.tm.get("any") : targetType
      }

      var := self.vm.get(expression.name)

      if withMutable && !var.mutable {
        self.raise(errors.E1011(expression.name), it.start, it.end)
      }

      return var.t
    } elif it.isBooleanLiteral() {
      return self.tm.get("bool")
    } elif it.isCharacterLiteral() {
      return self.tm.get("char")
    } elif it.isFloatingPointLiteral() {
      // todo validate float
      // todo too long number
      // todo validate exponent
      return self.tm.get("float")
    } elif it.isIntegerLiteral() {
      // todo if number more than 4M and targetType empty then explicitly should specify i64
      // todo too long number
      if targetType != nil {
        t := TypeMap.unwrap(targetType)

        if (
          TypeMap.match(t, self.tm.get("i64")) ||
          TypeMap.match(t, self.tm.get("u32")) ||
          TypeMap.match(t, self.tm.get("u64"))
        ) {
          return t
        }
      }

      return self.tm.get("int")
    } elif it.isNilLiteral() {
      if targetType == nil {
        self.raise(errors.E1004(), it.start, it.end)
        return self.tm.createOptional(self.tm.get("any"))
      }

      t := TypeMap.unwrap(targetType as Type, withOptional: false)

      if t.isOptional() {
        return t
      }

      self.raise(errors.E1006(t.toString()), it.start, it.end)
      return self.tm.createOptional(self.tm.get("any"))
    } elif it.isStringLiteral() {
      return self.tm.get("str")
    } elif it.isArray() {
      expression := it.asArray()
      mut elementType: Type?

      if targetType != nil {
        t := TypeMap.unwrap(targetType)

        if t.isArray() {
          t := t.asArray()
          elementType = t.elementType
        }
      }

      if expression.elements.empty {
        if elementType == nil {
          self.raise(errors.E1007(), it.start, it.end)
          return self.tm.createArray(self.tm.get("any"))
        }
      }

      elementsLen := expression.elements.len
      elementTypeForced := elementType != nil

      loop i := 0; i < elementsLen; i++ {
        element := expression.elements[i]
        t := self.e(element, elementType)

        if elementType == nil {
          elementType = t
        } elif !TypeMap.match(elementType, t) {
          if elementTypeForced {
            self.raise(errors.E1008(t.toString(), elementType.toString()), element.start, element.end)
          } else {
            elementType = self.tm.unionAdd(elementType, t)
          }
        }
      }

      return self.tm.createArray(elementType as Type)
    } elif it.isAs() {
      expression := it.asAs()
      expressionType := self.e(expression.expression, withMutable: withMutable)
      t := self.t(expression.t)

      if !expressionType.canBe(t) {
        self.raise(errors.E1009(expressionType.toString(), t.toString()), it.start, it.end)
      }

      return t
    } elif it.isAssignment() {
      expression := it.asAssignment()
      leftExpression := expressionUnwrap(expression.left)

      guessTypeResult := self.guessType((operandType: Type?) -> Type {
        initialTC := ref self.tc
        return TypeMap.unwrap(self.e(expression.left, operandType, withMutable: true), withOptional: false, withReference: false)
      }, (operandType: Type?) -> Type {
        initialTC := ref self.tc
        return TypeMap.unwrap(self.e(expression.right, operandType), withOptional: false, withReference: false)
      })

      leftType := guessTypeResult.first
      rightType := guessTypeResult.second

      if !self.operands(expression.operator, leftType, rightType) {
        self.raise(errors.E1027(expression.operator.val, leftType.toString()), expression.operator.start, expression.operator.end)
      }

      if (
        !leftExpression.isIdentifier() &&
        !leftExpression.isElementAccess() &&
        !leftExpression.isPropertyAccess()
      ) {
        self.raise(errors.E1010(), expression.left.start, expression.left.end)
      }

      return leftType.isReference() && !rightType.isReference()
        ? TypeMap.unwrap(leftType, withOptional: false)
        : leftType
    } elif it.isAwait() {
      expression := it.asAwait()
      expressionType := TypeMap.unwrap(self.e(expression.expression), withOptional: false)

      if !expressionType.isFunction() {
        self.raise(errors.E1013(), expression.expression.start, expression.expression.end)
        return self.tm.get("any")
      } else {
        t := expressionType.asFunction()

        if !t.asynchronous {
          self.raise(errors.E1013(), expression.expression.start, expression.expression.end)
        }

        return t.returnType
      }
    } elif it.isBinary() {
      expression := it.asBinary()

      guessTypeResult := self.guessType((operandType: Type?) -> Type {
        initialTC := ref self.tc
        return TypeMap.unwrap(self.e(expression.left, operandType), withOptional: false)
      }, (operandType: Type?) -> Type {
        initialTC := ref self.tc
        return TypeMap.unwrap(self.e(expression.right, operandType), withOptional: false)
      })

      leftType := guessTypeResult.first
      rightType := guessTypeResult.second

      if !self.operands(expression.operator, leftType, rightType) {
        self.raise(errors.E1026(expression.operator.val, leftType.toString(), rightType.toString()), expression.operator.start, expression.operator.end)
      }

      if (
        expression.operator.t == .OpEqEq ||
        expression.operator.t == .OpExclEq ||
        expression.operator.t == .OpGt ||
        expression.operator.t == .OpGtEq ||
        expression.operator.t == .OpLt ||
        expression.operator.t == .OpLtEq
      ) {
        return self.tm.get("bool")
      } elif leftType.name == "str" && rightType.name == "str" {
        return self.tm.get("str")
      } elif leftType.isNumber() && rightType.isNumber() {
        return TypeMap.largest(leftType, rightType)
      }

      return leftType
    } elif it.isCall() {
      // todo print void
      // todo required passed (Missing required arguments)
      // todo Extraneous passed
      // todo Extra argument
      // todo Variadic argument can't be passed by name
      // todo Named arguments can't be followed by regular arguments
      // todo Argument type doesn't match parameter type
      // todo Called object expected to be a function

      expression := it.asCall()
      calleeType := TypeMap.unwrap(self.e(expression.callee), withOptional: false)

      if calleeType.isFunction() {
        t := calleeType.asFunction()
        return t.returnType
      } elif calleeType.isMethod() {
        t := calleeType.asMethod()
        return t.returnType
      }

      return self.tm.get("void")
    } elif it.isClosure() {
      // todo variadic with initializer
      // todo Void type can only be used as function return type
      expression := it.asClosure()
      mut parameters: TypeMap.TypeParameter[]
      parametersLen := expression.parameters.len

      self.vm.increase()

      loop i := 0; i < parametersLen; i++ {
        parameter := expression.parameters[i]

        mut t := parameter.t == nil
          ? self.e(functionParameterInitializer(parameter))
          : self.t(parameter.t)

        if parameter.variadic {
          t = self.tm.createArray(t)
        }

        self.vm.add(parameter.name.name, t, parameter.mutable)

        parameters.push(TypeMap.TypeParameter{
          name: parameter.name.name,
          t: t,
          mutable: parameter.mutable,
          required: parameter.initializer == nil && !parameter.variadic,
          variadic: parameter.variadic
        })
      }

      self.vm.decrease()
      return self.tm.createFunction(expression.asynchronous, parameters, self.t(expression.returnType))
    } elif it.isConditional() {
      initialTC := self.tc
      expression := it.asConditional()
      typeCastResult := self.typeCast(expression.condition)
      conditionType := TypeMap.unwrap(self.e(expression.condition), withOptional: false)

      if conditionType.name != "bool" {
        self.raise(errors.E1018(conditionType.toString()), expression.condition.start, expression.condition.end)
      }

      guessTypeResult := self.guessType((operandType: Type?) -> Type {
        self.tc.merge(typeCastResult.consequent)
        result := TypeMap.unwrap(self.e(expression.consequent, operandType, withMutable: withMutable), withOptional: false)
        self.tc = initialTC

        return result
      }, (operandType: Type?) -> Type {
        self.tc.merge(typeCastResult.alternate)
        result := TypeMap.unwrap(self.e(expression.alternate, operandType, withMutable: withMutable), withOptional: false)
        self.tc = initialTC

        return result
      })

      consequentType := guessTypeResult.first
      alternateType := guessTypeResult.second

      if consequentType.isNumber() && alternateType.isNumber() {
        return TypeMap.largest(consequentType, alternateType)
      } elif !TypeMap.match(consequentType, alternateType) {
        self.raise(errors.E1019(consequentType.toString(), alternateType.toString()), expression.consequent.start, expression.alternate.end)
      }

      return consequentType
    } elif it.isElementAccess() {
      expression := it.asElementAccess()
      expressionType := TypeMap.unwrap(self.e(expression.expression, withMutable: withMutable), withOptional: false)
      argumentType := TypeMap.unwrap(self.e(expression.argument), withOptional: false)

      if argumentType.name != "i32" {
        self.raise(errors.E1014(argumentType.toString()), expression.argument.start, expression.argument.end)
      }

      if expressionType.isArray() {
        arrayType := expressionType.asArray()
        return self.tm.createReference(arrayType.elementType)
      } elif expressionType.name == "str" {
        return self.tm.createReference(self.tm.get("char"))
      }

      self.raise(errors.E1015(argumentType.toString()), expression.expression.start, expression.expression.end)
      return self.tm.get("any")
    } elif it.isIs() {
      expression := it.asIs()
      expressionType := self.e(expression.expression, withMutable: withMutable)
      t := self.t(expression.t)

      if !expressionType.canBe(t) {
        self.raise(errors.E1009(expressionType.toString(), t.toString()), expression.expression.start, expression.expression.end)
      }

      return self.tm.get("bool")
    } elif it.isMap() {
      expression := it.asMap()
      mut t: Type?

      if targetType != nil {
        maybeMapType := TypeMap.unwrap(targetType)

        if maybeMapType.isMap() {
          t = maybeMapType
        }
      }

      if expression.elements.empty && t == nil {
        self.raise(errors.E1016(), it.start, it.end)
        return self.tm.createMap(self.tm.get("any"), self.tm.get("any"))
      } elif expression.elements.empty {
        return t
      }

      mut keyType: Type?
      mut valueType: Type?

      if t != nil {
        mapType := t.asMap()
        keyType = mapType.keyType
        valueType = mapType.valueType
      }

      keyTypeForced := keyType != nil
      valueTypeForced := valueType != nil
      elementsLen := expression.elements.len

      loop i := 0; i < elementsLen; i++ {
        element := expression.elements[i]
        elementKeyType := self.e(element.key, keyType)
        elementValueType := self.e(element.value, valueType)

        if keyType == nil {
          keyType = elementKeyType
        } elif !TypeMap.match(keyType, elementKeyType) && keyTypeForced {
          self.raise(errors.E1017(keyType.toString(), elementKeyType.toString()), element.key.start, element.key.end)
        } elif !TypeMap.match(keyType, elementKeyType) {
          keyType = self.tm.unionAdd(keyType, elementKeyType)
        }

        if valueType == nil {
          valueType = elementValueType
        } elif !TypeMap.match(valueType, elementValueType) && valueTypeForced {
          self.raise(errors.E1017(valueType.toString(), elementValueType.toString()), element.value.start, element.value.end)
        } elif !TypeMap.match(valueType, elementValueType) {
          valueType = self.tm.unionAdd(valueType, elementValueType)
        }
      }

      return self.tm.createMap(keyType as Type, valueType as Type)
    } elif it.isMemberAccess() {
      expression := it.asMemberAccess()
      mut t: Type?

      if targetType != nil {
        maybeEnumType := TypeMap.unwrap(targetType, withOptional: false)

        if maybeEnumType.isEnum() {
          t = maybeEnumType
        }
      }

      if t == nil {
        self.raise(errors.E1020(), it.start, it.end)
        return self.tm.get("any")
      } elif !t.hasEnumerator(expression.name.name) {
        self.raise(errors.E1021(expression.name.name), it.start, it.end)
      }

      return t as Type
    } elif it.isObject() {
      expression := it.asObject()
      t := self.t(expression.id)
      propertiesLen := expression.properties.len

      loop i := 0; i < propertiesLen; i++ {
        property := expression.properties[i]

        if !t.has(property.name.name) {
          self.raise(errors.E1002(property.name.name, t.toString()), property.name.start, property.name.end)
          self.e(property.value)
        } else {
          p := t.get(property.name.name)
          propertyType := self.e(property.value, p.t)

          if !TypeMap.match(p.t, propertyType) {
            self.raise(errors.E1017(propertyType.toString(), p.t.toString()), property.value.start, property.value.end)
          }
        }
      }

      return t
    } elif it.isParenthesized() {
      expression := it.asParenthesized()
      return self.e(expression.expression, targetType, withMutable: withMutable)
    } elif it.isPropertyAccess() {
      expression := it.asPropertyAccess()
      t := TypeMap.unwrap(self.e(expression.expression, withMutable: withMutable), withOptional: false)

      if t.isEnum() {
        if !t.hasEnumerator(expression.name.name) {
          self.raise(errors.E1021(expression.name.name), expression.name.start, expression.name.end)
        }
        return t
      } elif !t.has(expression.name.name) {
        self.raise(errors.E1002(expression.name.name, t.toString()), expression.name.start, expression.name.end)
        return self.tm.get("any")
      }

      property := t.get(expression.name.name)

      if withMutable && !property.mutable {
        self.raise(errors.E1012(expression.name.name), it.start, it.end)
      }

      return property.t
    } elif it.isReference() {
      expression := it.asReference()
      return self.tm.createReference(self.e(expression.expression, withMutable: withMutable))
    } elif it.isUnary() {
      expression := it.asUnary()
      operandExpression := expressionUnwrap(expression.operand)
      operandType := TypeMap.unwrap(self.e(expression.operand), withOptional: false)

      if expression.operator.t == .OpExcl {
        if operandType.name != "bool" && operandType.name != "byte" && !operandType.isNumber() {
          self.raise(errors.E1025(expression.operator.val, operandType.toString()), expression.operator.start, expression.operator.end)
        }

        return self.tm.get("bool")
      } elif expression.operator.t == .OpMinusMinus || expression.operator.t == .OpPlusPlus {
        if (
          !operandExpression.isIdentifier() &&
          !operandExpression.isElementAccess() &&
          !operandExpression.isPropertyAccess()
        ) {
          self.raise(errors.E1024(), expression.operator.start, expression.operator.end)
        } elif !operandType.isNumber() {
          self.raise(errors.E1025(expression.operator.val, operandType.toString()), expression.operator.start, expression.operator.end)
        }
      } elif expression.operator.t == .OpMinus {
        if !operandType.isSignedInt() && !operandType.isFloat() {
          self.raise(errors.E1025(expression.operator.val, operandType.toString()), expression.operator.start, expression.operator.end)
        }
      } elif expression.operator.t == .OpPlus {
        if !operandType.isNumber() {
          self.raise(errors.E1025(expression.operator.val, operandType.toString()), expression.operator.start, expression.operator.end)
        }
      } elif expression.operator.t == .OpTilde {
        if !operandType.isInt() {
          self.raise(errors.E1025(expression.operator.val, operandType.toString()), expression.operator.start, expression.operator.end)
        }
      }

      return operandType
    }

    throw error_NewError("Tried analyzing unknown expression")
  }

  fn guessType (mut self: ref Self, cb1: (Type?) -> Type, cb2: (Type?) -> Type) GuessTypeResult {
    initialErrorsLen := self.errors.len
    mut targetType: Type? = nil
    mut firstType := cb1(targetType)
    firstTypeFailed := self.errors.len != initialErrorsLen

    if firstTypeFailed {
      self.errors = self.errors.slice(0, initialErrorsLen)
    } else {
      targetType = firstType
    }

    secondType := cb2(targetType)
    secondTypeFailed := self.errors.len != initialErrorsLen

    if !secondTypeFailed {
      targetType = secondType
    }

    if firstTypeFailed {
      firstType = cb1(targetType)
    }

    return GuessTypeResult{
      first: firstType,
      second: secondType
    }
  }

  fn operands (mut self: ref Self, op: Parser.Token, t1: Type, t2: Type) bool {
    if op.t == .OpEqEq || op.t == .OpExclEq {
      if t1.name == "void" || t2.name == "void" || !TypeMap.match(t1, t2) {
        return false
      }
    } elif op.t == .OpGt || op.t == .OpGtEq || op.t == .OpLt || op.t == .OpLtEq {
      if (
        !(t1.isNumber() || t1.name == "byte" || t1.name == "char" || t1.name == "str") ||
        !(t2.isNumber() || t2.name == "byte" || t2.name == "char" || t2.name == "str") ||
        !TypeMap.match(t1, t2)
      ) {
        return false
      }
    } elif op.t == .OpPlus || op.t == .OpPlusEq {
      if (
        !(t1.isNumber() || t1.name == "byte" || t1.name == "str") ||
        !(t2.isNumber() || t2.name == "byte" || t2.name == "str") ||
        !TypeMap.match(t1, t2)
      ) {
        return false
      }
    } elif (
      op.t == .OpMinus || op.t == .OpMinusEq ||
      op.t == .OpPercent || op.t == .OpPercentEq ||
      op.t == .OpSlash || op.t == .OpSlashEq ||
      op.t == .OpStar || op.t == .OpStarEq
    ) {
      if (
        !(t1.isNumber() || t1.name == "byte") ||
        !(t2.isNumber() || t2.name == "byte")
      ) {
        return false
      }
    } elif op.t == .OpAmpAmp || op.t == .OpAmpAmpEq || op.t == .OpPipePipe || op.t == .OpPipePipeEq {
      if (
        !(t1.isNumber() || t1.name == "bool" || t1.name == "byte") ||
        !(t2.isNumber() || t2.name == "bool" || t2.name == "byte")
      ) {
        return false
      }
    } elif (
      op.t == .OpAmp || op.t == .OpAmpEq ||
      op.t == .OpCaret || op.t == .OpCaretEq ||
      op.t == .OpLShift || op.t == .OpLShiftEq ||
      op.t == .OpPipe || op.t == .OpPipeEq ||
      op.t == .OpRShift || op.t == .OpRShiftEq
    ) {
      if !t1.isInt() || !t2.isInt() {
        return false
      }
    }

    return true
  }

  fn raise (mut self: ref Self, message: str, start: int, end: int) {
    error := Parser.Reader_error(ref self.reader, "AnalyzeError", message, start, end)
    self.errors.push(error)
  }

  fn t (mut self: ref Self, it: Parser.Type) Type {
    if it.isArray() {
      t := it.asArray()
      return self.tm.createArray(self.t(t.elementType))
    } elif it.isFunction() {
      t := it.asFunction()
      mut parameters: TypeMap.TypeParameter[]
      parametersLen := t.parameters.len

      loop i := 0; i < parametersLen; i++ {
        parameter := t.parameters[i]
        t := parameter.variadic ? self.tm.createArray(self.t(parameter.t)) : self.t(parameter.t)

        parameters.push(TypeMap.TypeParameter{
          name: parameter.name == nil ? nil : parameter.name.name,
          t: parameter.variadic ? self.tm.createArray(self.t(parameter.t)) : self.t(parameter.t),
          mutable: parameter.mutable,
          required: !parameter.variadic,
          variadic: parameter.variadic
        })
      }

      return self.tm.createFunction(t.asynchronous, parameters, self.t(t.returnType))
    } elif it.isIdentifier() {
      t := it.asIdentifier()

      if !self.tm.has(t.name.name) {
        self.raise(errors.E1001(t.name.name), t.name.start, t.name.end)
        return self.tm.get("any")
      }

      return self.tm.get(t.name.name)
    } elif it.isMap() {
      t := it.asMap()
      return self.tm.createMap(self.t(t.keyType), self.t(t.valueType))
    } elif it.isMember() {
      t := it.asMember()
      leftType := TypeMap.unwrap(self.t(t.t), withReference: false, withOptional: false)

      if !leftType.isNamespace() {
        self.raise(errors.E1022(leftType.toString()), t.name.start, t.name.end)
        return self.tm.get("any")
      } elif !leftType.has(t.name.name) {
        self.raise(errors.E1023(leftType.toString(), t.name.name), t.name.start, t.name.end)
        return self.tm.get("any")
      }

      property := leftType.get(t.name.name)
      return property.t
    } elif it.isOptional() {
      t := it.asOptional()
      return self.tm.createOptional(self.t(t.t))
    } elif it.isParenthesized() {
      t := it.asParenthesized()
      return self.t(t.t)
    } elif it.isReference() {
      t := it.asReference()
      return self.tm.createReference(self.t(t.t))
    } elif it.isUnion() {
      t := it.asUnion()
      mut types: Type[]
      typesLen := t.types.len

      loop i := 0; i < typesLen; i++ {
        types.push(self.t(t.types[i] as Parser.Type))
      }

      return self.tm.createUnion(types)
    }

    throw error_NewError("Tried analyzing unknown type")
  }

  fn typeCast (mut self: ref Self, expression: Parser.Expression) TypeCastResult {
    // todo
    return TypeCastResult{
      consequent: {},
      alternate: {}
    }
  }
}

export fn analyze (f: ref Parser.File) str[] {
  if f.hasErrors {
    return f.errors
  }

  bodyLen := f.program.body.len
  mut analyzer := Analyzer{}

  analyzer.reader = Parser.Reader_init(f.path == "anonymous" ? f.content : f.path)
  analyzer.tm = TypeMap.init()
  analyzer.vm = VarMap.init(ref analyzer.tm)

  loop i := 0; i < bodyLen; i++ {
    analyzer.analyze(f.program.body[i])
  }

  return analyzer.errors
}

main {
  args := process_args
  mut f := Parser.parse(args[1])
  errors := analyze(ref f)

  loop i := 0; i < errors.len; i++ {
    if i != 0 { print(to: "stderr") }
    print(errors[i] as str, terminator: "", to: "stderr")
  }

  if errors.len != 0 {
    process_exit(1)
  }
}
