/*!
 * Copyright (c) Aaron Delasy
 * Licensed under the MIT License
 */

import * as Parser from "the/parser"
import Type from "./type-map"
import * as TypeMap from "./type-map"
import * as VarMap from "./var-map"
import * as errors from "./errors"

export fn mutableLeftHand (it: Parser.Expression) Type {
  if it.isIdentifier() {
    expression := it.asIdentifier()
    var := self.vm.get(expression.name)

    if !var.mutable {
      self.raise(errors.E1011(), it.start, it.end)
    }

    return var.t
  } elif it.isElementAccess() {
    expression := it.asElementAccess()
    return mutableLeftHand(expression.expression)
  } elif it.isParenthesized() {
    expression := it.asParenthesized()
    return mutableLeftHand(expression.expression)
  } elif it.isPropertyAccess() {
    expression := it.asPropertyAccess()
    result := mutableLeftHand(expression.expression)

    if !result.has(expression.)
  }

  throw error_NewError("Tried mutable left hand on unknown expression")
}

export fn validLeftHand (it: Parser.Expression) bool {
  if it.isElementAccess() {
    expression := it.asElementAccess()
    return validLeftHand(expression.expression)
  } elif it.isParenthesized() {
    expression := it.asParenthesized()
    return validLeftHand(expression.expression)
  } elif it.isPropertyAccess() {
    expression := it.asPropertyAccess()
    // todo check property exists
    return validLeftHand(expression.expression)
  }

  return it.isIdentifier()
}

export fn functionParameterInitializer (parameter: Parser.FunctionParameter) Parser.Expression {
  return parameter.initializer as Parser.Expression
}

export fn variableDeclarationInitializer (statement: Parser.VariableDeclaration) Parser.Expression {
  return statement.initializer as Parser.Expression
}

export obj TypeCastResult {
  consequent: Type[str]
  alternate: Type[str]
}

export obj Analyzer {
  mut tc: Type[str]
  mut tm: TypeMap.TypeMap
  mut vm: VarMap.VarMap

  fn analyze (mut self: ref Self, it: Parser.Statement) {
    if it.isExpression() {
      statement := it.asExpression()
      self.e(statement.expression)
    } elif it.isVariableDeclaration() {
      statement := it.asVariableDeclaration()

      // todo global non-const
      // todo non-global const

      if self.vm.has(statement.name.name) {
        self.raise(errors.E1000(statement.name.name), statement.name.start, statement.name.end)
        return
      }

      varType := statement.t == nil
        ? self.e(statement.initializer as Parser.Expression)
        : self.t(statement.t)

      if statement.t != nil && statement.initializer != nil {
        initializerType := self.e(statement.initializer, varType)

        if !TypeMap.match(varType, initializerType) {
          self.raise(
            errors.E1005(initializerType.toString(), varType.toString()),
            statement.initializer.start,
            statement.initializer.end
          )
        }
      }

      self.vm.add(statement.name.name, varType, statement.mutable)
    }
  }

  // todo check everywhere for void type used
  fn e (mut self: ref Self, it: Parser.Expression, targetType: Type? = nil) Type {
    if it.isIdentifier() {
      expression := it.asIdentifier()

      if !self.vm.has(expression.name) {
        self.raise(errors.E1003(expression.name), it.start, it.end)
        return targetType == nil ? self.tm.get("any") : targetType
      }

      var := self.vm.get(expression.name)
      return var.t
    } elif it.isBooleanLiteral() {
      return self.tm.get("bool")
    } elif it.isCharacterLiteral() {
      return self.tm.get("char")
    } elif it.isFloatingPointLiteral() {
      // todo validate float
      // todo too long number
      // todo validate exponent
      return self.tm.get("float")
    } elif it.isIntegerLiteral() {
      // todo if number more than 4M and targetType empty then explicitly should specify i64
      // todo too long number
      if targetType != nil {
        t := TypeMap.unwrap(targetType)

        if (
          TypeMap.match(t, self.tm.get("i64")) ||
          TypeMap.match(t, self.tm.get("u32")) ||
          TypeMap.match(t, self.tm.get("u64"))
        ) {
          return t
        }
      }

      return self.tm.get("int")
    } elif it.isNilLiteral() {
      if targetType == nil {
        self.raise(errors.E1004(), it.start, it.end)
        return self.tm.createOptional(self.tm.get("any"))
      }

      t := TypeMap.unwrap(targetType as Type, withOptional: false)

      if t.isOptional() {
        return t
      }

      self.raise(errors.E1006(t.toString()), it.start, it.end)
      return self.tm.createOptional(self.tm.get("any"))
    } elif it.isStringLiteral() {
      return self.tm.get("str")
    } elif it.isArray() {
      expression := it.asArray()
      mut elementType: Type?

      if targetType != nil {
        t := TypeMap.unwrap(targetType)

        if t.isArray() {
          t := t.asArray()
          elementType = t.elementType
        }
      }

      if expression.elements.empty {
        if elementType == nil {
          self.raise(errors.E1007(), it.start, it.end)
          return self.tm.createArray(self.tm.get("any"))
        }
      }

      elementsLen := expression.elements.len
      elementTypeForced := elementType != nil

      loop i := 0; i < elementsLen; i++ {
        element := expression.elements[i]
        t := self.e(element, elementType)

        if elementType == nil {
          elementType = t
        } elif !TypeMap.match(elementType, t) {
          if elementTypeForced {
            self.raise(errors.E1008(t.toString()), element.start, element.end)
          } else {
            elementType = self.tm.unionAdd(elementType, t)
          }
        }
      }

      return self.tm.createArray(elementType as Type)
    } elif it.isAs() {
      expression := it.asAs()
      expressionType := self.e(expression.expression)
      t := self.t(expression.t)

      if !expressionType.canBe(t) {
        self.raise(errors.E1009(expressionType.toString(), t.toString()), it.start, it.end)
      }

      return t
    } elif it.isAssignment() {
      // todo non mutable
      expression := it.asAssignment()
      leftType := self.e(expression.left)
      leftType2: Type? = leftType
      rightType := self.e(expression.left, leftType2)

      if !validLeftHand(expression.left) {
        self.raise(errors.E1010(), expression.left.start, expression.left.end)
      }

      return leftType.isReference() && !rightType.isReference()
        ? TypeMap.unwrap(leftType, withOptional: false)
        : leftType
    } elif it.isAwait() {
      // todo Awaiting is only possible on asynchronous functions
      expression := it.asAwait()
      return self.e(expression.expression)
    } elif it.isBinary() {
      expression := it.asBinary()
      // todo unary bitwise on float
      // todo bitwise only on i8-i64, u8-u64
      // todo Binary operator cannot be applied to these operands

      if (
        expression.operator.t == .OpEqEq ||
        expression.operator.t == .OpExclEq ||
        expression.operator.t == .OpGt ||
        expression.operator.t == .OpGtEq ||
        expression.operator.t == .OpLt ||
        expression.operator.t == .OpLtEq
      ) {
        return self.tm.get("bool")
      }

      leftType := TypeMap.unwrap(self.e(expression.left), withOptional: false)
      leftType2: Type? = leftType
      rightType := TypeMap.unwrap(self.e(expression.right, leftType2), withOptional: false)

      if leftType.name == "str" && rightType.name == "str" && expression.operator.t == .OpPlus {
        return self.tm.get("str")
      } elif leftType.isNumber() && rightType.isNumber() {
        return TypeMap.largest(leftType, rightType)
      }

      return self.tm.get("any")
    } elif it.isCall() {
      // todo print void
      // todo required passed (Missing required arguments)
      // todo Extraneous passed
      // todo Extra argument
      // todo Variadic argument can't be passed by name
      // todo Named arguments can't be followed by regular arguments
      // todo Argument type doesn't match parameter type
      // todo Called object expected to be a function
      expression := it.asCall()
      calleeType := TypeMap.unwrap(self.e(expression.callee), withOptional: false)

      if calleeType.isFunction() {
        t := calleeType.asFunction()
        return t.returnType
      } elif calleeType.isMethod() {
        t := calleeType.asMethod()
        return t.returnType
      }

      return self.tm.get("void")
    } elif it.isClosure() {
      // todo variadic with initializer
      // todo Void type can only be used as function return type
      expression := it.asClosure()
      mut parameters: TypeMap.TypeParameter[]
      parametersLen := expression.parameters.len

      self.vm.increase()

      loop i := 0; i < parametersLen; i++ {
        parameter := expression.parameters[i]

        mut t := parameter.t == nil
          ? self.e(functionParameterInitializer(parameter))
          : self.t(parameter.t)

        if parameter.variadic {
          t = self.tm.createArray(t)
        }

        self.vm.add(parameter.name.name, t, parameter.mutable)

        parameters.push(TypeMap.TypeParameter{
          name: parameter.name.name,
          t: t,
          mutable: parameter.mutable,
          required: parameter.initializer == nil && !parameter.variadic,
          variadic: parameter.variadic
        })
      }

      self.vm.decrease()
      return self.tm.createFunction(expression.asynchronous, parameters, self.t(expression.returnType))
    } elif it.isConditional() {
      // todo condition only bool
      // todo Incompatible operand types
      initialTC := self.tc
      expression := it.asConditional()
      typeCastResult := self.typeCast(expression.condition)

      self.tc.merge(typeCastResult.consequent)
      consequentType := TypeMap.unwrap(self.e(expression.consequent), withOptional: false)
      self.tc = initialTC
      self.tc.merge(typeCastResult.alternate)
      alternateType := TypeMap.unwrap(self.e(expression.alternate), withOptional: false)
      self.tc = initialTC

      if consequentType.name == "any" || alternateType.name == "any" {
        return self.tm.get("any")
      } elif consequentType.isOptional() && !alternateType.isOptional() {
        return consequentType
      } elif !consequentType.isOptional() && alternateType.isOptional() {
        return alternateType
      } elif consequentType.isReference() && !alternateType.isReference() {
        return alternateType
      } elif !consequentType.isReference() && alternateType.isReference() {
        return consequentType
      } elif consequentType.isNumber() && alternateType.isNumber() {
        return TypeMap.largest(consequentType, alternateType)
      }

      return consequentType
    } elif it.isElementAccess() {
      // todo Index type expected to be integer
      // todo Indexing allowed only on arrays and strings
      expression := it.asElementAccess()
      t := TypeMap.unwrap(self.e(expression.expression), withOptional: false)

      if t.isArray() {
        arrayType := t.asArray()
        return self.tm.createReference(arrayType.elementType)
      } elif t.name == "str" {
        return self.tm.createReference(self.tm.get("char"))
      }
    } elif it.isIs() {
      // todo Type casting is not possible in this case
      expression := it.asIs()
      return self.t(expression.t)
    } elif it.isMap() {
      // todo Unable to deduce map type
      expression := it.asMap()
      mut t: Type?

      if targetType != nil {
        maybeMapType := TypeMap.unwrap(targetType)

        if maybeMapType.isMap() {
          t = maybeMapType
        }
      }

      if expression.elements.empty && t == nil {
        return self.tm.createMap(self.tm.get("any"), self.tm.get("any"))
      } elif expression.elements.empty {
        return t
      }

      mut keyType: Type?
      mut valueType: Type?

      if t != nil {
        mapType := t.asMap()
        keyType = mapType.keyType
        valueType = mapType.valueType
      }

      keyTypeForced := keyType != nil
      valueTypeForced := valueType != nil
      elementsLen := expression.elements.len

      loop i := 0; i < elementsLen; i++ {
        element := expression.elements[i]
        elementKeyType := self.e(element.key, keyType)
        elementValueType := self.e(element.value, valueType)

        if keyType == nil {
          keyType = elementKeyType
        } elif !TypeMap.match(keyType, elementKeyType) && !keyTypeForced {
          keyType = self.tm.unionAdd(keyType, elementKeyType)
        }

        if valueType == nil {
          valueType = elementValueType
        } elif !TypeMap.match(valueType, elementValueType) && !valueTypeForced {
          valueType = self.tm.unionAdd(valueType, elementValueType)
        }
      }

      return self.tm.createMap(keyType as Type, valueType as Type)
    } elif it.isMemberAccess() {
      // todo Unable to deduce enumeration member type
      // todo Tried accessing non-existing enumeration member
      expression := it.asMemberAccess()
      mut t: Type?

      if targetType != nil {
        maybeEnumType := TypeMap.unwrap(targetType, withOptional: false)

        if maybeEnumType.isEnum() {
          t = maybeEnumType
        }
      }

      if t == nil {
        return self.tm.get("any")
      }

      return t as Type
    } elif it.isObject() {
      // todo non existing object declaration (Tried setting non-existing object property)
      expression := it.asObject()
      return self.t(expression.id)
    } elif it.isParenthesized() {
      expression := it.asParenthesized()
      return self.e(expression.expression, targetType)
    } elif it.isPropertyAccess() {
      // todo non existign access
      // todo Tried accessing non-existing enumeration member
      expression := it.asPropertyAccess()
      t := TypeMap.unwrap(self.e(expression.expression), withOptional: false)

      if t.isEnum() && t.hasEnumerator(expression.name.name) {
        return t
      }

      if !t.has(expression.name.name) {
        return self.tm.get("any")
      }

      property := t.get(expression.name.name)
      return property.t
    } elif it.isReference() {
      expression := it.asReference()
      return self.tm.createReference(self.e(expression.expression))
    } elif it.isUnary() {
      expression := it.asUnary()
      // todo unary bitwise on float
      // todo increment decrement on lval
      // todo unary only on integers (no char/str/bool) (only i8-i32,u8-u16, int)

      if expression.operator.t == .OpExcl {
        return self.tm.get("bool")
      }

      return TypeMap.unwrap(self.e(expression.operand), withOptional: false)
    }

    throw error_NewError("Tried analyzing unknown expression")
  }

  fn raise (mut self: ref Self, message: str, start: int, end: int) {
    // todo
    print(message)
  }

  fn t (mut self: ref Self, it: Parser.Type) Type {
    if it.isArray() {
      t := it.asArray()
      return self.tm.createArray(self.t(t.elementType))
    } elif it.isFunction() {
      t := it.asFunction()
      mut parameters: TypeMap.TypeParameter[]
      parametersLen := t.parameters.len

      loop i := 0; i < parametersLen; i++ {
        parameter := t.parameters[i]
        t := parameter.variadic ? self.tm.createArray(self.t(parameter.t)) : self.t(parameter.t)

        parameters.push(TypeMap.TypeParameter{
          name: parameter.name == nil ? nil : parameter.name.name,
          t: parameter.variadic ? self.tm.createArray(self.t(parameter.t)) : self.t(parameter.t),
          mutable: parameter.mutable,
          required: !parameter.variadic,
          variadic: parameter.variadic
        })
      }

      return self.tm.createFunction(t.asynchronous, parameters, self.t(t.returnType))
    } elif it.isIdentifier() {
      t := it.asIdentifier()

      if !self.tm.has(t.name.name) {
        self.raise(errors.E1001(t.name.name), t.name.start, t.name.end)
        return self.tm.get("any")
      }

      return self.tm.get(t.name.name)
    } elif it.isMap() {
      t := it.asMap()
      return self.tm.createMap(self.t(t.keyType), self.t(t.valueType))
    } elif it.isMember() {
      t := it.asMember()
      leftType := self.t(t.t)

      if !leftType.has(t.name.name) {
        self.raise(errors.E1002(t.name.name), t.name.start, t.name.end)
        return self.tm.get("any")
      }

      property := leftType.get(t.name.name)
      return property.t
    } elif it.isOptional() {
      t := it.asOptional()
      return self.tm.createOptional(self.t(t.t))
    } elif it.isParenthesized() {
      t := it.asParenthesized()
      return self.t(t.t)
    } elif it.isReference() {
      t := it.asReference()
      return self.tm.createReference(self.t(t.t))
    } elif it.isUnion() {
      t := it.asUnion()
      mut types: Type[]
      typesLen := t.types.len

      loop i := 0; i < typesLen; i++ {
        types.push(self.t(t.types[i] as Parser.Type))
      }

      return self.tm.createUnion(types)
    }

    throw error_NewError("Tried analyzing unknown type")
  }

  fn typeCast (mut self: ref Self, expression: Parser.Expression) TypeCastResult {
    // todo
  }
}

export fn analyze (f: ref Parser.File) {
  bodyLen := f.program.body.len
  mut analyzer := Analyzer{}

  analyzer.tm = TypeMap.init()
  analyzer.vm = VarMap.init(ref analyzer.tm)

  loop i := 0; i < bodyLen; i++ {
    analyzer.analyze(f.program.body[i])
  }
}

main {
  args := process_args
  mut f := Parser.parse(args[1])
  analyze(ref f)
}
