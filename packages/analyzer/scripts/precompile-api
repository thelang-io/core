/*!
 * Copyright (c) Aaron Delasy
 * Licensed under the MIT License
 */

import * as Parser from "the/parser"
import Analyzer from "../src/analyzer"
import Type, TypeParameter, TypeProperty from "../src/type"

fn stringifyTypeParameter (it: ref TypeParameter, indent: int, selfName: str) str {
  return "Type.TypeParameter{name: " + (it.name == nil ? "nil" : "\"" + it.name + "\"") + ", " +
    "t: " + stringifyType(it.t, indent, selfName: selfName) + ", " +
    "mutable: " + it.mutable.str() + ", " +
    "required: " + it.required.str() + ", " +
    "variadic: " + it.variadic.str() + "}"
}

fn stringifyTypeProperty (it: ref TypeProperty, indent: int, selfName: str) str {
  return "Type.TypeProperty{name: \"" + it.name + "\", " +
    "t: " + stringifyType(it.t, indent, selfName: selfName) + ", " +
    "mutable: " + it.mutable.str() + "}"
}

fn stringifyTypeParameters (parameters: ref TypeParameter[], indent: int, selfName: str) str {
  mut result := ""

  loop i := 0; i < parameters.len; i++ {
    item := parameters[i]
    result += ' '.repeat(indent + 2) + stringifyTypeParameter(item, indent + 2, selfName) + os_EOL
  }

  return result.empty ? "[]" : "[" + os_EOL + result + ' '.repeat(indent) + "]"
}

fn stringifyTypeProperties (properties: ref TypeProperty[], indent: int, selfName: str) str {
  mut result := ""

  loop i := 0; i < properties.len; i++ {
    item := properties[i]
    if item.builtin { continue }
    result += ' '.repeat(indent + 2) + stringifyTypeProperty(item, indent + 2, selfName) + os_EOL
  }

  return result.empty ? "[]" : "[" + os_EOL + result + ' '.repeat(indent) + "]"
}

fn stringifyType (it: ref Type, indent: int, build := false, selfName := "self") str {
  if !build && (it.isAlias() || it.isEnum() || it.isNamespace() || it.isObject()) {
    return selfName + ".get(\"" + it.name + "\")"
  }

  if it.isAlias() {
    t := it.asAlias()
    return selfName + ".createAlias(\"" + it.name + "\", " + stringifyType(t.t, indent, selfName: selfName) + ")"
  } elif it.isArray() {
    t := it.asArray()
    return selfName + ".createArray(" + stringifyType(t.elementType, indent, selfName: selfName) + ")"
  } elif it.isEnum() {
    t := it.asEnum()
    mut content := ""
    loop i := 0; i < t.members.len; i++ {
      content += i == 0 ? "" : ", "
      content += "\"" + t.members[i] + "\""
    }
    return selfName + ".createAlias(\"" + it.name + "\", [" + content + "])"
  } elif it.isFunction() {
    t := it.asFunction()
    return selfName + ".createFunction(" + t.asynchronous.str() + ", " +
      stringifyTypeParameters(ref t.parameters, indent, selfName) + ", " +
      stringifyType(t.returnType, indent, selfName: selfName) + ")"
  } elif it.isMap() {
    t := it.asMap()
    return selfName + ".createMap(" + stringifyType(t.keyType, indent, selfName: selfName) + ", " +
      stringifyType(t.valueType, indent, selfName: selfName) + ")"
  } elif it.isMethod() {
    t := it.asMethod()
    return selfName + ".createMethod(" + t.asynchronous.str() + ", " +
      stringifyTypeParameters(ref t.parameters, indent, selfName) + ", " +
      stringifyType(t.returnType, indent, selfName: selfName) + ", " +
      t.withSelf.str() + ", " +
      t.selfMutable.str() + ", " +
      "\"" + t.selfName + "\", " +
      stringifyType(t.selfType, indent, selfName: selfName) + ")"
  } elif it.isNamespace() {
    t := it.asNamespace()
    return selfName + ".createNamespace(\"" + it.name + "\", " +
      stringifyTypeProperties(ref it.properties, indent, selfName) + ")"
  } elif it.isObject() {
    t := it.asObject()
    return selfName + ".createObject(\"" + it.name + "\", " +
      stringifyTypeProperties(ref it.properties, indent, selfName) + ")"
  } elif it.isOptional() {
    t := it.asOptional()
    return selfName + ".createOptional(" + stringifyType(t.t, indent, selfName: selfName) + ")"
  } elif it.isReference() {
    t := it.asReference()
    return selfName + ".createReference(" + stringifyType(t.t, indent, selfName: selfName) + ")"
  } else {
    t := it.asUnion()
    mut content := ""
    loop i := 0; i < t.types.len; i++ {
      item := t.types[i]
      content += i == 0 ? "" : ", "
      content += stringifyType(item, indent, selfName: selfName)
    }
    return selfName + ".createUnion([" + content + "])"
  }
}

main {
  args := process_args
  print(args)
  mut f := Parser.parse("./api/globals")
  Parser.interconnect(ref f)
  mut analyzer := Analyzer{}

  analyzer.reader = Parser.Reader_init(f.path == "anonymous" ? f.content : f.path)
  analyzer.tm.init()
  analyzer.vm.init(ref analyzer.tm)
  initialTypeMapLen := analyzer.tm.items.len
  analyzer.analyze(ref f.program.body)

  if !analyzer.errors.empty {
    loop i := 0; i < analyzer.errors.len; i++ {
      print((i == 0 ? "" : os_EOL) + (analyzer.errors[i] as str), to: "stderr")
    }

    process_exit(1)
  }

  mut globalsTM := ""
  mut globalsVM := ""

  loop i := initialTypeMapLen; i < analyzer.tm.items.len; i++ {
    item := analyzer.tm.items.at(i)
    if !item.isAlias() && !item.isEnum() && !item.isObject() { continue }
    globalsTM += "    " + stringifyType(item, 4, build: true) + os_EOL
  }

  loop i := 0; i < analyzer.vm.items.len; i++ {
    item := analyzer.vm.items[i]
    globalsVM += "    self.add(\"" + item.name + "\", " + stringifyType(item.t, 4, selfName: "tm")
    globalsVM += ", " + item.mutable.str() + ")" + os_EOL
  }

  mut content := "type-map:" + os_EOL
  content += globalsTM + os_EOL
  content += "var-map:" + os_EOL
  content += globalsVM

  print(content)
}
