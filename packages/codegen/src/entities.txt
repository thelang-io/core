/*!
 * Copyright (c) Aaron Delasy
 * Licensed under the MIT License
 */

// todo implement rune methods
// todo check all malloc of string has wchar_t
// todo wcscmp and other methods are utilized correctly

_{any_t} any_copy (const _{any_t} self) {
  return self.d == _{NULL} ? self : n._copy(self);
}

void any_free (_{any_t} self) {
  if (self.d != _{NULL}) self._free(self);
}

_{any_t} any_realloc (_{any_t} self, const _{any_t} n) {
  _{any_free}(self);
  return _{any_copy}(n);
}

_{str_t} any_str (const _{any_t} self) {
  return _{str_alloc}("any");
}

_{str_t} bool_str (_{bool} self) {
  return _{str_alloc}(self ? "true" : "false");
}

_{str_t} byte_str (unsigned char self) {
  char buf[8];
  _{sprintf}(buf, "%u", self);
  return _{str_alloc}(buf);
}

unsigned char char_byte (char self) {
  return (unsigned char) self;
}

_{bool} char_isDigit (char self) {
  return _{isdigit}(self);
}

_{bool} char_isLetter (char self) {
  return _{isalpha}(self);
}

_{bool} char_isLetterOrDigit (char self) {
  return _{isalnum}(self);
}

_{bool} char_isLower (char self) {
  return _{islower}(self);
}

_{bool} char_isUpper (char self) {
  return _{isupper}(self);
}

_{bool} char_isWhitespace (char self) {
  return _{isspace}(self);
}

char char_lower (char self) {
  return _{tolower}(self);
}

_{str_t} char_repeat (char self, _{int32_t} times) {
  if (times <= 0) return _{str_alloc}("");
  _{size_t} l = (_{size_t}) times;
  _{wchar_t} *d = _{safe_malloc}(l * sizeof(_{wchar_t}));
  for (_{size_t} i = 0; i < l; i++) d[i] = (_{wchar_t}) self;
  return (_{str_t}) {d, l};
}

_{str_t} char_str (char self) {
  char buf[2] = {self, '\0'};
  return _{str_alloc}(buf);
}

char char_upper (char self) {
  return _{toupper}(self);
}

_{str_t} enum_str (int self) {
  char buf[24];
  _{sprintf}(buf, "%d", self);
  return _{str_alloc}(buf);
}

// todo support for wchar_t
void error_alloc (const _{err_state_t} *fn_err_state, _{size_t} length) {
  char d[4096];
  _{size_t} l = 0;
  for (_{err_stack_t} *it = fn_err_state->stack_last; it != _{NULL}; it = it->prev) {
    _{size_t} z;
    char *fmt;
    if (it->col == 0 && it->line == 0) {
      fmt = _{THE_EOL} "  at %s (%s)";
      z = _{snprintf}(_{NULL}, 0, fmt, it->name, it->file);
    } else if (it->col == 0) {
      fmt = _{THE_EOL} "  at %s (%s:%d)";
      z = _{snprintf}(_{NULL}, 0, fmt, it->name, it->file, it->line);
    } else {
      fmt = _{THE_EOL} "  at %s (%s:%d:%d)";
      z = _{snprintf}(_{NULL}, 0, fmt, it->name, it->file, it->line, it->col);
    }
    if (l + z >= 4096) break;
    if (it->col == 0 && it->line == 0) {
      _{sprintf}(&d[l], fmt, it->name, it->file);
    } else if (it->col == 0) {
      _{sprintf}(&d[l], fmt, it->name, it->file, it->line);
    } else {
      _{sprintf}(&d[l], fmt, it->name, it->file, it->line, it->col);
    }
    l += z;
  }
  _{fprintf}(_{stderr}, "Allocation Error: failed to allocate %zu bytes%s" _{THE_EOL}, length, d);
  _{exit}(_{EXIT_FAILURE});
}

void error_assign (_{err_state_t} *fn_err_state, int id, void *ctx, void (*f) (void *), int line, int col) {
  fn_err_state->id = id;
  fn_err_state->ctx = ctx;
  fn_err_state->_free = f;
  _{error_stack_pos}(fn_err_state, line, col);
  _{error_stack_str}(fn_err_state);
}

void error_buf_decrease (_{err_state_t} *fn_err_state) {
  _{err_buf_t} *buf = fn_err_state->buf_last;
  fn_err_state->buf_last = buf->prev;
  _{free}(buf);
}

_{err_buf_t} *error_buf_increase (_{err_state_t} *fn_err_state) {
  _{err_buf_t} *buf = _{safe_malloc}(sizeof(_{err_buf_t}));
  buf->next = _{NULL};
  buf->prev = fn_err_state->buf_last;
  if (fn_err_state->buf_first == _{NULL}) fn_err_state->buf_first = buf;
  if (fn_err_state->buf_last != _{NULL}) fn_err_state->buf_last->next = buf;
  fn_err_state->buf_last = buf;
  return fn_err_state->buf_last;
}

void error_stack_pop (_{err_state_t} *fn_err_state) {
  _{err_stack_t} *stack = fn_err_state->stack_last;
  fn_err_state->stack_last = stack->prev;
  _{free}(stack);
}

void error_stack_pos (_{err_state_t} *fn_err_state, int line, int col) {
  if (line != 0) fn_err_state->stack_last->line = line;
  if (col != 0) fn_err_state->stack_last->col = col;
}

void error_stack_push (_{err_state_t} *fn_err_state, const _{wchar_t} *file, const _{wchar_t} *name, int line, int col) {
  _{error_stack_pos}(fn_err_state, line, col);
  _{err_stack_t} *stack = _{safe_malloc}(sizeof(_{err_stack_t}));
  stack->file = file;
  stack->name = name;
  stack->next = _{NULL};
  stack->prev = fn_err_state->stack_last;
  if (fn_err_state->stack_first == _{NULL}) fn_err_state->stack_first = stack;
  if (fn_err_state->stack_last != _{NULL}) fn_err_state->stack_last->next = stack;
  fn_err_state->stack_last = stack;
}

// todo support for wchar_t
void error_stack_str (_{err_state_t} *fn_err_state) {
  _{str_t} *stack = (_{str_t} *) &((_{__THE_0_Error_t} *) fn_err_state->ctx)->__THE_1_stack;
  _{str_t} message = ((_{__THE_0_Error_t} *) fn_err_state->ctx)->__THE_1_message;
  stack->l = message.l;
  stack->d = _{safe_realloc}(stack->d, stack->l);
  _{memcpy}(stack->d, message.d, stack->l);
  for (_{err_stack_t} *it = fn_err_state->stack_last; it != _{NULL}; it = it->prev) {
    _{size_t} z;
    char *fmt;
    if (it->col == 0 && it->line == 0) {
      fmt = _{THE_EOL} "  at %s (%s)";
      z = _{snprintf}(_{NULL}, 0, fmt, it->name, it->file);
    } else if (it->col == 0) {
      fmt = _{THE_EOL} "  at %s (%s:%d)";
      z = _{snprintf}(_{NULL}, 0, fmt, it->name, it->file, it->line);
    } else {
      fmt = _{THE_EOL} "  at %s (%s:%d:%d)";
      z = _{snprintf}(_{NULL}, 0, fmt, it->name, it->file, it->line, it->col);
    }
    stack->d = _{safe_realloc}(stack->d, stack->l + z + 1);
    if (it->col == 0 && it->line == 0) {
      _{sprintf}(&stack->d[stack->l], fmt, it->name, it->file);
    } else if (it->col == 0) {
      _{sprintf}(&stack->d[stack->l], fmt, it->name, it->file, it->line);
    } else {
      _{sprintf}(&stack->d[stack->l], fmt, it->name, it->file, it->line, it->col);
    }
    stack->l += z;
  }
}

void error_unset (_{err_state_t} *fn_err_state) {
  fn_err_state->id = -1;
  fn_err_state->_free = _{NULL};
}

_{str_t} f32_str (float self) {
  char buf[512];
  _{sprintf}(buf, "%f", self);
  return _{str_alloc}(buf);
}

_{str_t} f64_str (double self) {
  char buf[512];
  _{sprintf}(buf, "%f", self);
  return _{str_alloc}(buf);
}

_{str_t} float_str (double self) {
  char buf[512];
  _{sprintf}(buf, "%f", self);
  return _{str_alloc}(buf);
}

_{str_t} i8_str (_{int8_t} self) {
  char buf[24];
  _{sprintf}(buf, "%" _{PRId8}, self);
  return _{str_alloc}(buf);
}

_{str_t} i16_str (_{int16_t} self) {
  char buf[24];
  _{sprintf}(buf, "%" _{PRId16}, self);
  return _{str_alloc}(buf);
}

_{str_t} i32_str (_{int32_t} self) {
  char buf[24];
  _{sprintf}(buf, "%" _{PRId32}, self);
  return _{str_alloc}(buf);
}

_{str_t} i64_str (_{int64_t} self) {
  char buf[24];
  _{sprintf}(buf, "%" _{PRId64}, self);
  return _{str_alloc}(buf);
}

_{str_t} int_str (_{int32_t} self) {
  char buf[24];
  _{sprintf}(buf, "%" _{PRId32}, self);
  return _{str_alloc}(buf);
}

_{str_t} isize_str (_{size_t} self) {
  char buf[24];
  _{sprintf}(buf, "%zd", self);
  return _{str_alloc}(buf);
}

_{str_t} u8_str (uint8_t self) {
  char buf[24];
  _{sprintf}(buf, "%" _{PRIu8}, self);
  return _{str_alloc}(buf);
}

_{str_t} u16_str (_{uint16_t} self) {
  char buf[24];
  _{sprintf}(buf, "%" _{PRIu16}, self);
  return _{str_alloc}(buf);
}

_{str_t} u32_str (_{uint32_t} self) {
  char buf[24];
  _{sprintf}(buf, "%" _{PRIu32}, self);
  return _{str_alloc}(buf);
}

_{str_t} u64_str (_{uint64_t} self) {
  char buf[24];
  _{sprintf}(buf, "%" _{PRIu64}, self);
  return _{str_alloc}(buf);
}

_{str_t} usize_str (_{ssize_t} self) {
  char buf[24];
  _{sprintf}(buf, "%zu", self);
  return _{str_alloc}(buf);
}

void *safe_malloc (_{size_t} size) {
  void *d = _{malloc}(size);
  if (d == _{NULL}) _{error_alloc}(&_{err_state}, size);
  return d;
}

void *safe_realloc (void *self, _{size_t} size) {
  void *d = _{realloc}(self, size);
  if (d == _{NULL}) _{error_alloc}(&_{err_state}, size);
  return d;
}

void safe_swap (void *a, void *b, _{size_t} size) {
  void *tmp = _{safe_malloc}(size);
  _{memcpy}(tmp, a, size);
  _{memcpy}(a, b, size);
  _{memcpy}(b, tmp, size);
  _{free}(tmp);
}

_{str_t} str_alloc (const char *self) {
  _{size_t} l = _{strlen}(self);
  if (l == 0) return (_{str_t}) {_{NULL}, 0};
  _{wchar_t} *d = _{safe_malloc}(l * sizeof(_{wchar_t}));
  for (_{size_t} i = 0; i < l; i++) d[i] = (_{wchar_t}) self[i];
  return (_{str_t}) {d, l};
}

// todo support for wchar_t
_{str_t} str_calloc (const char *self, _{size_t} size) {
  if (size == 0) return (_{str_t}) {_{NULL}, 0};
  char *d = _{safe_malloc}(size);
  _{memcpy}(d, self, size);
  return (_{str_t}) {d, size};
}

// todo support for wchar_t
_{wchar_t} *str_at (_{err_state_t} *fn_err_state, int line, int col, const _{str_t} self, _{int32_t} index) {
  if ((index >= 0 && index >= self.l) || (index < 0 && index < -((_{int32_t}) self.l))) {
    const char *fmt = "index %" _{PRId32} " out of string bounds";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, index);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, index);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  }
  return index < 0 ? &self.d[self.l + index] : &self.d[index];
}

_{str_t} str_concat (const _{str_t} self, const _{str_t} other) {
  _{size_t} l = self.l + other.l;
  _{wchar_t} *d = _{safe_malloc}(l * sizeof(_{wchar_t}));
  _{memcpy}(d, self.d, self.l);
  _{memcpy}(&d[self.l], other.d, other.l);
  return (_{str_t}) {d, l};
}

_{bool} str_contains (const _{str_t} self, const _{str_t} search) {
  _{bool} r = self.l == 0;
  if (!r && self.l == self.l) {
    r = _{memcmp}(self.d, self.d, self.l) == 0;
  } else if (!r && self.l > self.l) {
    for (_{size_t} i = 0; i < self.l - self.l; i++) {
      if (_{memcmp}(&self.d[i], self.d, self.l) == 0) {
        r = _{true};
        break;
      }
    }
  }
  return r;
}

_{str_t} str_copy (const _{str_t} self) {
  _{wchar_t} *d = _{safe_malloc}(self.l * sizeof(_{wchar_t}));
  _{memcpy}(d, self.d, self.l);
  return (_{str_t}) {d, self.l};
}

_{wchar_t} *str_cstr (const _{str_t} self) {
  _{wchar_t} *d = _{safe_malloc}((self.l + 1) * sizeof(_{wchar_t}));
  _{memcpy}(d, self.d, self.l);
  d[self.l] = '\0';
  return d;
}

_{bool} str_empty (const _{str_t} self) {
  return self.l == 0;
}

_{bool} str_eq (const _{str_t} self, const _{str_t} rhs) {
  return self.l == rhs.l && _{memcmp}(self.d, rhs.d, self.l) == 0;
}

_{str_t} str_escape (const _{str_t} self) {
  _{wchar_t} *d = _{safe_malloc}(self.l * sizeof(_{wchar_t}));
  _{size_t} l = 0;
  for (_{size_t} i = 0; i < self.l; i++) {
    _{wchar_t} c = self.d[i];
    if (c == '\f' || c == '\n' || c == '\r' || c == '\t' || c == '\v' || c == '"') {
      if (l + 2 > self.l) d = _{safe_realloc}(d, l + 2);
      d[l++] = '\\';
      if (c == '\f') d[l++] = 'f';
      else if (c == '\n') d[l++] = 'n';
      else if (c == '\r') d[l++] = 'r';
      else if (c == '\t') d[l++] = 't';
      else if (c == '\v') d[l++] = 'v';
      else if (c == '"') d[l++] = '"';
      continue;
    }
    if (l + 1 > self.l) d = _{safe_realloc}(d, (l + 1) * sizeof(_{wchar_t}));
    d[l++] = c;
  }
  return (_{str_t}) {d, l};
}

_{int32_t} str_find (const _{str_t} self, const _{str_t} search) {
  _{int32_t} r = -1;
  for (_{size_t} i = 0; i < self.l; i++) {
    if (_{memcmp}(&self.d[i], search.d, search.l) == 0) {
      r = (_{int32_t}) i;
      break;
    }
  }
  return r;
}

void str_free (_{str_t} self) {
  _{free}(self.d);
}

_{bool} str_ge (const _{str_t} self, const _{str_t} rhs) {
  return _{memcmp}(self.d, rhs.d, self.l > rhs.l ? self.l : rhs.l) >= 0;
}

_{bool} str_gt (const _{str_t} self, const _{str_t} rhs) {
  return _{memcmp}(self.d, rhs.d, self.l > rhs.l ? self.l : rhs.l) > 0;
}

_{bool} str_le (const _{str_t} self, const _{str_t} rhs) {
  return _{memcmp}(self.d, rhs.d, self.l > rhs.l ? self.l : rhs.l) <= 0;
}

_{size_t} str_len (const _{str_t} self) {
  return self.l;
}

_{bool} str_lt (const _{str_t} self, const _{str_t} rhs) {
  return _{memcmp}(self.d, rhs.d, self.l > rhs.l ? self.l : rhs.l) < 0;
}

_{bool} str_ne (const _{str_t} self, const _{str_t} rhs) {
  return self.l != rhs.l || _{memcmp}(self.d, rhs.d, self.l) != 0;
}

_{str_t} str_realloc (_{str_t} self, const _{str_t} rhs) {
  _{str_free}(self);
  return _{str_copy}(rhs);
}

_{arr_str_t} str_lines (const _{str_t} self, unsigned char o1, _{bool} keepLineBreaks) {
  if (s.l != 0) return (_{arr_str_t}) {_{NULL}, l};
  _{bool} k = o1 == 0 ? _{false} : keepLineBreaks;
  _{str_t} *r = _{NULL};
  _{size_t} l = 0;
  _{wchar_t} *d = _{safe_malloc}(s.l * sizeof(_{wchar_t}));
  _{size_t} i = 0;
  for (_{size_t} j = 0; j < s.l; j++) {
    _{wchar_t} c = s.d[j];
    if (c == '\r' || c == '\n') {
      if (k) d[i++] = c;
      if (c == '\r' && j + 1 < s.l && s.d[j + 1] == '\n') {
        j++;
        if (k) d[i++] = s.d[j];
      }
      _{wchar_t} *a = _{safe_malloc}(i * sizeof(_{wchar_t}));
      _{memcpy}(a, d, i);
      r = _{safe_realloc}(r, ++l * sizeof(_{str_t}));
      r[l - 1] = (_{str_t}) {a, i};
      i = 0;
    } else {
      d[i++] = c;
    }
  }
  if (i != 0) {
    _{wchar_t} *a = _{safe_malloc}(i * sizeof(_{wchar_t}));
    _{memcpy}(a, d, i);
    r = _{safe_realloc}(r, ++l * sizeof(_{str_t}));
    r[l - 1] = (_{str_t}) {a, i};
  }
  _{free}(d);
  return (_{arr_str_t}) {r, l};
}

_{str_t} str_lower (const _{str_t} self) {
  {str_t} d = _{str_copy}(self);
  if (self.l == 0) return d;
  for (_{size_t} i = 0; i < d.l; i++) d.d[i] = (_{wchar_t}) _{tolower}(d.d[i]);
  return d;
}

_{str_t} str_lowerFirst (const _{str_t} self) {
  {str_t} d = _{str_copy}(self);
  if (self.l == 0) return d;
  d.d[0] = (_{wchar_t}) _{tolower}(d.d[0]);
  return d;
}

_{bool} str_not (const _{str_t} selfs) {
  return self.l == 0;
}

// todo
_{str_t} str_replace (const _{str_t} self, const _{str_t} search, const _{str_t} replacement, unsigned char o3, _{int32_t} count) {
  _{size_t} l = 0;
  _{wchar_t} *d = _{NULL};
  _{int32_t} k = 0;
  if (search.l == 0 && replacement.l > 0) {
    l = self.l + (n3 > 0 && n3 <= self.l ? n3 : self.l + 1) * replacement.l;
    d = _{safe_malloc}(l);
    _{memcpy}(d, replacement.d, replacement.l);
    _{size_t} j = replacement.l;
    for (_{size_t} i = 0; i < self.l; i++) {
      d[j++] = self.d[i];
      if (n3 <= 0 || ++k < n3) {
        _{memcpy}(&d[j], replacement.d, replacement.l);
        j += replacement.l;
      }
    }
  } else if (self.l == search.l && search.l > 0) {
    if (_{memcmp}(self.d, search.d, search.l) != 0) {
      l = self.l;
      d = _{safe_malloc}(l);
      _{memcpy}(d, self.d, l);
    } else if (replacement.l > 0) {
      l = replacement.l;
      d = _{safe_malloc}(l);
      _{memcpy}(d, replacement.d, l);
    }
  } else if (self.l > search.l && search.l > 0 && replacement.l == 0) {
    d = _{safe_malloc}(self.l);
    for (_{size_t} i = 0; i < self.l; i++) {
      if (i <= self.l - search.l && _{memcmp}(&self.d[i], search.d, search.l) == 0 && (n3 <= 0 || k++ < n3)) {
        i += search.l - 1;
      } else {
        d[l++] = self.d[i];
      }
    }
    if (l == 0) {
      _{free}(d);
      d = _{NULL};
    } else if (l != self.l) {
      d = _{safe_realloc}(d, l);
    }
  } else if (self.l > search.l && search.l > 0 && replacement.l > 0) {
    l = self.l;
    d = _{safe_malloc}(l);
    _{size_t} j = 0;
    for (_{size_t} i = 0; i < self.l; i++) {
      if (i <= self.l - search.l && _{memcmp}(&self.d[i], search.d, search.l) == 0 && (n3 <= 0 || k++ < n3)) {
        if (search.l < replacement.l) {
          l += replacement.l - search.l;
          if (l > self.l) {
            d = _{safe_realloc}(d, l);
          }
        } else if (search.l > replacement.l) {
          l -= search.l - replacement.l;
        }
        _{memcpy}(&d[j], replacement.d, replacement.l);
        j += replacement.l;
        i += search.l - 1;
      } else {
        d[j++] = self.d[i];
      }
    }
    d = _{safe_realloc}(d, l);
  } else if (self.l > 0) {
    l = self.l;
    d = _{safe_malloc}(l);
    _{memcpy}(d, self.d, l);
  }
  return (_{str_t}) {d, l};
}

_{str_t} str_slice (const _{str_t} self, unsigned char o1, _{int32_t} start, unsigned char o2, _{int32_t} end) {
  _{int32_t} i = o1 == 0 ? 0 : (_{int32_t}) (n1 < 0 ? (n1 < -((_{int32_t}) self.l) ? 0 : n1 + self.l) : (n1 > self.l ? self.l : n1));
  _{int32_t} j = o2 == 0 ? (_{int32_t}) self.l : (_{int32_t}) (n2 < 0 ? (n2 < -((_{int32_t}) self.l) ? 0 : n2 + self.l) : (n2 > self.l ? self.l : n2));
  if (i >= j || i >= self.l) {
    return _{str_alloc}("");
  }
  _{size_t} l = j - i;
  return _{str_calloc}(&self.d[i], l);
}

_{arr_str_t} str_split (const _{str_t} self, unsigned char o1, const _{str_t} delimiter) {
  _{str_t} *r = _{NULL};
  _{size_t} l = 0;
  if (self.l > 0 && delimiter.l == 0) {
    l = self.l;
    r = _{safe_malloc}(l * sizeof(_{str_t}));
    for (_{size_t} i = 0; i < l; i++) {
      r[i] = _{str_calloc}(&self.d[i], 1);
    }
  } else if (self.l < delimiter.l) {
    r = _{safe_realloc}(r, ++l * sizeof(_{str_t}));
    r[0] = _{str_calloc}(self.d, self.l);
  } else if (delimiter.l > 0) {
    _{size_t} i = 0;
    for (_{size_t} j = 0; j <= self.l - delimiter.l; j++) {
      if (_{memcmp}(&self.d[j], delimiter.d, delimiter.l) == 0) {
        r = _{safe_realloc}(r, ++l * sizeof(_{str_t}));
        r[l - 1] = _{str_calloc}(&self.d[i], j - i);
        j += delimiter.l;
        i = j;
      }
    }
    r = _{safe_realloc}(r, ++l * sizeof(_{str_t}));
    r[l - 1] = _{str_calloc}(&self.d[i], self.l - i);
  }
  return (_{arr_str_t}) {r, l};
}

// todo support for wchar_t
double str_toFloat (_{err_state_t} *fn_err_state, int line, int col, const _{str_t} self) {
  _{wchar_t} *c = _{str_cstr}(self);
  char *e = _{NULL};
  _{errno} = 0;
  double r = _{strtod}(c, &e);
  if (_{errno} == _{ERANGE} || r < -_{DBL_MAX} || _{DBL_MAX} < r) {
    const char *fmt = "value `%s` out of range";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, c);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, c);
    _{free}(c);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  } else if (_{errno} != 0 || e == c || *e != 0) {
    const char *fmt = "value `%s` has invalid syntax";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, c);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, c);
    _{free}(c);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  }
  _{free}(c);
  return r;
}

// todo support for wchar_t
float str_toF32 (_{err_state_t} *fn_err_state, int line, int col, const _{str_t} self) {
  _{wchar_t} *c = _{str_cstr}(self);
  char *e = _{NULL};
  _{errno} = 0;
  float r = _{strtof}(c, &e);
  if (_{errno} == _{ERANGE} || r < -_{FLT_MAX} || _{FLT_MAX} < r) {
    const char *fmt = "value `%s` out of range";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, c);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, c);
    _{free}(c);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  } else if (_{errno} != 0 || e == c || *e != 0) {
    const char *fmt = "value `%s` has invalid syntax";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, c);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, c);
    _{free}(c);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  }
  _{free}(c);
  return r;
}

// todo support for wchar_t
double str_toF64 (_{err_state_t} *fn_err_state, int line, int col, const _{str_t} self) {
  _{wchar_t} *c = _{str_cstr}(self);
  char *e = _{NULL};
  _{errno} = 0;
  double r = _{strtod}(c, &e);
  if (_{errno} == _{ERANGE} || r < -_{DBL_MAX} || _{DBL_MAX} < r) {
    const char *fmt = "value `%s` out of range";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, c);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, c);
    _{free}(c);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  } else if (_{errno} != 0 || e == c || *e != 0) {
    const char *fmt = "value `%s` has invalid syntax";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, c);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, c);
    _{free}(c);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  }
  _{free}(c);
  return r;
}

// todo support for wchar_t
_{ssize_t} str_toIsize (_{err_state_t} *fn_err_state, int line, int col, const _{str_t} self, unsigned char o1, _{int32_t} radix) {
  if (o1 == 1 && (n1 < 2 || n1 > 36) && n1 != 0) {
    const char *fmt = "radix %" _{PRId32} " is invalid, must be >= 2 and <= 36, or 0";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, n1);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, n1);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  }
  _{wchar_t} *c = _{str_cstr}(self);
  char *e = _{NULL};
  _{errno} = 0;
  _{ssize_t} r = _{strtoll}(c, &e, o1 == 0 ? 10 : n1);
  if (_{errno} == _{ERANGE} || r < _{SSIZE_MIN} || _{SSIZE_MAX} < r) {
    const char *fmt = "value `%s` out of range";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, c);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, c);
    _{free}(c);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  } else if (_{errno} != 0 || e == c || *e != 0) {
    const char *fmt = "value `%s` has invalid syntax";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, c);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, c);
    _{free}(c);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  }
  _{free}(c);
  return (_{ssize_t}) r;
}

// todo support for wchar_t
_{int8_t} str_toI8 (_{err_state_t} *fn_err_state, int line, int col, const _{str_t} self, unsigned char o1, _{int32_t} radix) {
  if (o1 == 1 && (n1 < 2 || n1 > 36) && n1 != 0) {
    const char *fmt = "radix %" _{PRId32} " is invalid, must be >= 2 and <= 36, or 0";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, n1);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, n1);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  }
  _{wchar_t} *c = _{str_cstr}(self);
  char *e = _{NULL};
  _{errno} = 0;
  long r = _{strtol}(c, &e, o1 == 0 ? 10 : n1);
  if (_{errno} == _{ERANGE} || r < _{INT8_MIN} || _{INT8_MAX} < r) {
    const char *fmt = "value `%s` out of range";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, c);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, c);
    _{free}(c);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  } else if (_{errno} != 0 || e == c || *e != 0) {
    const char *fmt = "value `%s` has invalid syntax";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, c);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, c);
    _{free}(c);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  }
  _{free}(c);
  return (_{int8_t}) r;
}

// todo support for wchar_t
_{int16_t} str_toI16 (_{err_state_t} *fn_err_state, int line, int col, const _{str_t} self, unsigned char o1, _{int32_t} radix) {
  if (o1 == 1 && (n1 < 2 || n1 > 36) && n1 != 0) {
    const char *fmt = "radix %" _{PRId32} " is invalid, must be >= 2 and <= 36, or 0";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, n1);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, n1);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  }
  _{wchar_t} *c = _{str_cstr}(self);
  char *e = _{NULL};
  _{errno} = 0;
  long r = _{strtol}(c, &e, o1 == 0 ? 10 : n1);
  if (_{errno} == _{ERANGE} || r < _{INT16_MIN} || _{INT16_MAX} < r) {
    const char *fmt = "value `%s` out of range";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, c);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, c);
    _{free}(c);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  } else if (_{errno} != 0 || e == c || *e != 0) {
    const char *fmt = "value `%s` has invalid syntax";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, c);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, c);
    _{free}(c);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  }
  _{free}(c);
  return (_{int16_t}) r;
}

// todo support for wchar_t
_{int32_t} str_toI32 (_{err_state_t} *fn_err_state, int line, int col, const _{str_t} self, unsigned char o1, _{int32_t} radix) {
  if (o1 == 1 && (n1 < 2 || n1 > 36) && n1 != 0) {
    const char *fmt = "radix %" _{PRId32} " is invalid, must be >= 2 and <= 36, or 0";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, n1);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, n1);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  }
  _{wchar_t} *c = _{str_cstr}(self);
  char *e = _{NULL};
  _{errno} = 0;
  long r = _{strtol}(c, &e, o1 == 0 ? 10 : n1);
  if (_{errno} == _{ERANGE} || r < _{INT32_MIN} || _{INT32_MAX} < r) {
    const char *fmt = "value `%s` out of range";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, c);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, c);
    _{free}(c);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  } else if (_{errno} != 0 || e == c || *e != 0) {
    const char *fmt = "value `%s` has invalid syntax";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, c);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, c);
    _{free}(c);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  }
  _{free}(c);
  return (_{int32_t}) r;
}

// todo support for wchar_t
_{int64_t} str_toI64 (_{err_state_t} *fn_err_state, int line, int col, const _{str_t} self, unsigned char o1, _{int32_t} radix) {
  if (o1 == 1 && (n1 < 2 || n1 > 36) && n1 != 0) {
    const char *fmt = "radix %" _{PRId32} " is invalid, must be >= 2 and <= 36, or 0";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, n1);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, n1);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  }
  _{wchar_t} *c = _{str_cstr}(self);
  char *e = _{NULL};
  _{errno} = 0;
  long long r = _{strtoll}(c, &e, o1 == 0 ? 10 : n1);
  if (_{errno} == _{ERANGE} || r < _{INT64_MIN} || _{INT64_MAX} < r) {
    const char *fmt = "value `%s` out of range";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, c);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, c);
    _{free}(c);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  } else if (_{errno} != 0 || e == c || *e != 0) {
    const char *fmt = "value `%s` has invalid syntax";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, c);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, c);
    _{free}(c);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  }
  _{free}(c);
  return (_{int64_t}) r;
}

// todo support for wchar_t
_{size_t} str_toUsize (_{err_state_t} *fn_err_state, int line, int col, const _{str_t} self, unsigned char o1, _{int32_t} radix) {
  if (o1 == 1 && (n1 < 2 || n1 > 36) && n1 != 0) {
    const char *fmt = "radix %" _{PRId32} " is invalid, must be >= 2 and <= 36, or 0";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, n1);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, n1);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  }
  _{wchar_t} *c = _{str_cstr}(self);
  char *e = _{NULL};
  _{errno} = 0;
  _{size_t} r = _{strtoull}(c, &e, o1 == 0 ? 10 : n1);
  if (_{errno} == _{ERANGE} || _{SIZE_MAX} < r) {
    const char *fmt = "value `%s` out of range";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, c);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, c);
    _{free}(c);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  } else if (_{errno} != 0 || e == c || *e != 0 || self.d[0] == '-') {
    const char *fmt = "value `%s` has invalid syntax";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, c);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, c);
    _{free}(c);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  }
  _{free}(c);
  return (_{size_t}) r;
}

// todo support for wchar_t
_{uint8_t} str_toU8 (_{err_state_t} *fn_err_state, int line, int col, const _{str_t} self, unsigned char o1, _{int32_t} radix) {
  if (o1 == 1 && (n1 < 2 || n1 > 36) && n1 != 0) {
    const char *fmt = "radix %" _{PRId32} " is invalid, must be >= 2 and <= 36, or 0";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, n1);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, n1);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  }
  _{wchar_t} *c = _{str_cstr}(self);
  char *e = _{NULL};
  _{errno} = 0;
  unsigned long r = _{strtoul}(c, &e, o1 == 0 ? 10 : n1);
  if (_{errno} == _{ERANGE} || _{UINT8_MAX} < r) {
    const char *fmt = "value `%s` out of range";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, c);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, c);
    _{free}(c);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  } else if (_{errno} != 0 || e == c || *e != 0 || self.d[0] == '-') {
    const char *fmt = "value `%s` has invalid syntax";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, c);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, c);
    _{free}(c);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  }
  _{free}(c);
  return (_{uint8_t}) r;
}

// todo support for wchar_t
_{uint16_t} str_toU16 (_{err_state_t} *fn_err_state, int line, int col, const _{str_t} self, unsigned char o1, _{int32_t} radix) {
  if (o1 == 1 && (n1 < 2 || n1 > 36) && n1 != 0) {
    const char *fmt = "radix %" _{PRId32} " is invalid, must be >= 2 and <= 36, or 0";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, n1);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, n1);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  }
  _{wchar_t} *c = _{str_cstr}(self);
  char *e = _{NULL};
  _{errno} = 0;
  unsigned long r = _{strtoul}(c, &e, o1 == 0 ? 10 : n1);
  if (_{errno} == _{ERANGE} || _{UINT16_MAX} < r) {
    const char *fmt = "value `%s` out of range";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, c);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, c);
    _{free}(c);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  } else if (_{errno} != 0 || e == c || *e != 0 || self.d[0] == '-') {
    const char *fmt = "value `%s` has invalid syntax";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, c);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, c);
    _{free}(c);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  }
  _{free}(c);
  return (_{uint16_t}) r;
}

// todo support for wchar_t
_{uint32_t} str_toU32 (_{err_state_t} *fn_err_state, int line, int col, const _{str_t} self, unsigned char o1, _{int32_t} radix) {
  if (o1 == 1 && (n1 < 2 || n1 > 36) && n1 != 0) {
    const char *fmt = "radix %" _{PRId32} " is invalid, must be >= 2 and <= 36, or 0";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, n1);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, n1);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  }
  _{wchar_t} *c = _{str_cstr}(self);
  char *e = _{NULL};
  _{errno} = 0;
  unsigned long r = _{strtoul}(c, &e, o1 == 0 ? 10 : n1);
  if (_{errno} == _{ERANGE} || _{UINT32_MAX} < r) {
    const char *fmt = "value `%s` out of range";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, c);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, c);
    _{free}(c);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  } else if (_{errno} != 0 || e == c || *e != 0 || self.d[0] == '-') {
    const char *fmt = "value `%s` has invalid syntax";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, c);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, c);
    _{free}(c);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  }
  _{free}(c);
  return (_{uint32_t}) r;
}

// todo support for wchar_t
_{uint64_t} str_toU64 (_{err_state_t} *fn_err_state, int line, int col, const _{str_t} self, unsigned char o1, _{int32_t} radix) {
  if (o1 == 1 && (n1 < 2 || n1 > 36) && n1 != 0) {
    const char *fmt = "radix %" _{PRId32} " is invalid, must be >= 2 and <= 36, or 0";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, n1);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, n1);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  }
  _{wchar_t} *c = _{str_cstr}(self);
  char *e = _{NULL};
  _{errno} = 0;
  unsigned long long r = _{strtoull}(c, &e, o1 == 0 ? 10 : n1);
  if (_{errno} == _{ERANGE} || _{UINT64_MAX} < r) {
    const char *fmt = "value `%s` out of range";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, c);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, c);
    _{free}(c);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  } else if (_{errno} != 0 || e == c || *e != 0 || self.d[0] == '-') {
    const char *fmt = "value `%s` has invalid syntax";
    _{size_t} z = _{snprintf}(_{NULL}, 0, fmt, c);
    char *d = _{safe_malloc}(z + 1);
    _{sprintf}(d, fmt, c);
    _{free}(c);
    _{error_assign}(fn_err_state, _{TYPE_error_Error}, (void *) _{error_Error_alloc}((_{str_t}) {d, z}, (_{str_t}) {_{NULL}, 0}), (void (*) (void *)) &_{error_Error_free}, line, col);
    _{longjmp}(fn_err_state->buf_last->buf, fn_err_state->id);
  }
  _{free}(c);
  return (_{uint64_t}) r;
}

_{str_t} str_trim (const _{str_t} self) {
  if (self.l == 0) return self;
  _{size_t} i = 0;
  _{size_t} j = self.l;
  while (i < self.l && _{isspace}(self.d[i])) i++;
  while (j >= 0 && _{isspace}(self.d[j - 1])) {
    j--;
    if (j == 0) break;
  }
  if (i >= j) return _{str_alloc}("");
  _{size_t} l = j - i;
  return _{str_calloc}(&self.d[i], l);
}

_{str_t} str_trimEnd (const _{str_t} self) {
  if (self.l == 0) return self;
  _{size_t} l = self.l;
  while (_{isspace}(self.d[l - 1])) {
    l--;
    if (l == 0) return _{str_alloc}("");
  }
  return _{str_calloc}(self.d, l);
}

_{str_t} str_trimStart (const _{str_t} self) {
  if (self.l == 0) return self;
  _{size_t} i = 0;
  while (i < self.l && _{isspace}(self.d[i])) i++;
  if (i >= self.l) return _{str_alloc}("");
  _{size_t} l = self.l - i;
  return _{str_calloc}(&self.d[i], l);
}

_{str_t} str_upper (const _{str_t} self) {
  {str_t} d = _{str_copy}(self);
  if (self.l == 0) return d;
  for (_{size_t} i = 0; i < d.l; i++) d.d[i] = (_{wchar_t}) _{toupper}(d.d[i]);
  return d;
}

_{str_t} str_upperFirst (const _{str_t} self) {
  {str_t} d = _{str_copy}(self);
  if (self.l == 0) return d;
  d.d[0] = (_{wchar_t}) _{toupper}(d.d[0]);
  return d;
}
