/*!
 * Copyright (c) Aaron Delasy
 * Licensed under the MIT License
 */

export type CExpressionBody =
  CLiteral |
  CAssignmentExpression |
  CBinaryExpression |
  CCallExpression |
  CCastExpression |
  CConditionalExpression |
  CInitializerListExpression |
  CUnaryExpression

export type CStatementBody =
  CBreakStatement |
  CCaseStatement |
  CCompoundStatement |
  CContinueStatement |
  CEmptyStatement |
  CExpressionStatement |
  CFunctionDeclaration |
  CForStatement |
  CGotoStatement |
  CIfStatement |
  CLabelStatement |
  CReturnStatement |
  CStructureDeclaration |
  CSwitchStatement |
  CVariableDeclaration |
  CWhileStatement

export obj CType {
  mut value: str

  fn stringify (self: ref Self, declaration := false, definition := false) str {
    if declaration {
      lastChar := self.value.slice(-1)
      return self.value + (lastChar == " " || lastChar == "*" ? "" : " ")
    } elif definition {
      lastChar := self.value.slice(-1)
      l := self.value.len
      return self.value.slice(0, l + (lastChar == " " ? 0 : 1))
    } else {
      throw error_NewError("Unable to stringify specified type")
    }
  }
}

export obj CExpression {
  mut body: CExpressionBody
  mut parent: (ref CExpression)?
  mut parentStatement: (ref CStatement)?
  mut parenthesized: bool

  fn asCastExpression (mut self: ref Self) ref CCastExpression { return ref (self.body as CCastExpression) }
  fn asLiteral (mut self: ref Self) ref CLiteral { return ref (self.body as CLiteral) }
  fn isCastExpression (self: ref Self) bool { return self.body is CCastExpression }
  fn isLiteral (self: ref Self) bool { return self.body is CLiteral }

  fn statement (self: ref Self) CStatement {
    return createExpressionStatement(self)
  }

  fn stringify (self: ref Self) str {
    mut result := ""

    if self.isLiteral() {
      expression := self.asLiteral()
      result = expression.stringify()
    } else {
      throw error_NewError("Unable to stringify specified expression")
    }

    return self.parenthesized ? "(" + result + ")" : result
  }

  fn wrap (mut self: CExpression) CExpression {
    return createExpression(self.body, parenthesized: true)
  }
}

export obj CStatement {
  mut body: CStatementBody
  mut parent: (ref CStatement)?
  mut nextSibling: (ref CStatement)?
  mut prevSibling: (ref CStatement)?

  fn asCompoundStatement (mut self: ref Self) ref CCompoundStatement { return ref (self.body as CCompoundStatement) }
  fn asEmptyStatement (mut self: ref Self) ref CEmptyStatement { return ref (self.body as CEmptyStatement) }
  fn asExpressionStatement (mut self: ref Self) ref CExpressionStatement { return ref (self.body as CExpressionStatement) }
  fn asFunctionDeclaration (mut self: ref Self) ref CFunctionDeclaration { return ref (self.body as CFunctionDeclaration) }
  fn isCompoundStatement (self: ref Self) bool { return self.body is CCompoundStatement }
  fn isEmptyStatement (self: ref Self) bool { return self.body is CEmptyStatement }
  fn isExpressionStatement (self: ref Self) bool { return self.body is CExpressionStatement }
  fn isFunctionDeclaration (self: ref Self) bool { return self.body is CFunctionDeclaration }

  fn stringify (self: ref Self, indent := 0, root := true) str {
    if self.isCompoundStatement() {
      statement := self.asCompoundStatement()
      return statement.stringify(indent, root)
    } elif self.isEmptyStatement() {
      statement := self.asEmptyStatement()
      return statement.stringify()
    } elif self.isExpressionStatement() {
      statement := self.asExpressionStatement()
      return statement.stringify(indent, root)
    } elif self.isFunctionDeclaration() {
      statement := self.asFunctionDeclaration()
      return statement.stringify()
    }

    throw error_NewError("Unable to stringify specified statement")
  }

  // fn endsWith<T> () bool
  // fn exit () ref Statement
  // fn getBody () ref Statement
  // fn hasBody () bool
  // fn increaseAsyncCounter (ref int) ref Statement
  // fn merge (other: ref (ref Statement)[]) void
  // fn prepend (mut statement: Statement) ref Statement
  // fn setIfAlt (mut statement: ref Statement) void
}

export obj CIdentifier {
  mut name: str

  fn stringify (self: ref Self) str {
    return self.name
  }
}

export obj CLiteral {
  mut intValue: int
  mut stringValue: str

  fn stringify (self: ref Self) str {
    return self.stringValue.empty && self.intValue != 0
      ? self.intValue.str()
      : self.stringValue
  }
}

export obj CAssignmentExpression {
  mut left: CExpression
  mut operator: str
  mut right: CExpression

  fn stringify (self: ref Self) str {
    return "TODO"
  }
}

export obj CBinaryExpression {
  mut left: CExpression
  mut operator: str
  mut right: CExpression

  fn stringify (self: ref Self) str {
    return "TODO"
  }
}

export obj CCallExpression {
  mut callee: CExpression
  mut arguments: (CExpression | CType)[]

  fn stringify (self: ref Self) str {
    return "TODO"
  }
}

export obj CCastExpression {
  mut t: CType
  mut argument: CExpression

  fn stringify (self: ref Self) str {
    return "(" + self.t.stringify(definition: true) + ") " + self.arg.stringify()
  }
}

export obj CConditionalExpression {
  mut condition: CExpression
  mut consequent: CExpression
  mut alternate: CExpression

  fn stringify (self: ref Self) str {
    return "TODO"
  }
}

export obj CElementAccessExpression {
  mut expression: CExpression
  mut element: CExpression

  fn stringify (self: ref Self) str {
    return "TODO"
  }
}

export obj CInitializerListExpression {
  mut items: CExpression[]

  fn stringify (self: ref Self) str {
    return "TODO"
  }
}

export obj CPropertyAccessExpression {
  mut expression: CExpression
  mut property: str
  mut pointed: bool

  fn stringify (self: ref Self) str {
    return "TODO"
  }
}

export obj CUnaryExpression {
  mut argument: CExpression
  mut operator: str
  mut prefix: bool

  fn stringify (self: ref Self) str {
    return "TODO"
  }
}

export obj CBreakStatement {
  fn stringify (self: ref Self, indent := 0, root := true) str {
    if !root { return "break" }
    return ' '.repeat(indent) + "break;" + os_EOL
  }
}

export obj CCaseStatement {
  mut test: CExpression
  mut body: CStatement

  fn stringify (self: ref Self, indent := 0, root := true) str {
    return "todo"
  }
}

export obj CCompoundStatement {
  mut body: CStatement[]

  fn stringify (self: ref Self, indent := 0, root := true) str {
    mut content := ""
    l := self.body.len
    loop i := 0; i < l; i++ {
      content = self.body[i].stringify(indent + 2)
    }
    content = "{" + os_EOL + content + ' '.repeat(indent) + "}"
    if !root {
      return content
    }
    return ' '.repeat(indent) + content + os_EOL
  }
}

export obj CContinueStatement {
  fn stringify (self: ref Self, indent := 0, root := true) str {
    if !root { return "continue" }
    return ' '.repeat(indent) + "continue;" + os_EOL
  }
}

export obj CEmptyStatement {
  fn stringify () str {
    return ""
  }
}

export obj CExpressionStatement {
  mut expression: CExpression

  fn stringify (self: ref Self, indent := 0, root := true) str {
    result := self.expression.stringify()
    if !root { return result }
    return ' '.repeat(indent) + result + ";" + os_EOL
  }
}

export obj CForStatement {
  mut initializer: CStatement
  mut condition: CExpression
  mut update: CExpression
  mut body: CStatement

  fn stringify (self: ref Self) str {
    return "todo"
  }
}

export obj CFunctionDeclaration {
  mut name: str
  mut returnType: CType
  mut body: CStatement

  fn definition (self: ref Self) str {
    return self.returnType.stringify(declaration: true) + self.name + " ();" + os_EOL
  }

  fn stringify (self: ref Self) str {
    return self.returnType.stringify(declaration: true) + self.name + " () " +
      self.body.stringify(root: false) + os_EOL
  }
}

export obj CGotoStatement {
  mut label: str

  fn stringify (self: ref Self) str {
    return "todo"
  }
}

export obj CIfStatement {
  mut condition: CExpression
  mut consequent: CStatement
  mut alternate: CStatement

  fn stringify (self: ref Self) str {
    return "todo"
  }
}

export obj CLabelStatement {
  mut name: str

  fn stringify (self: ref Self) str {
    return "todo"
  }
}

export obj CReturnStatement {
  mut argument: CExpression

  fn stringify (self: ref Self) str {
    return "todo"
  }
}

export obj CStructureDeclaration {
  mut name: str
  mut members: CStructureDeclarationMember[]

  fn definition (self: ref Self) str {
    return "struct " + self.name + ";" + os_EOL
  }

  fn stringify (self: ref Self) str {
    mut content := ""
    l := self.members.len
    loop i := 0; i < l; i++ {
      content += self.members[i].stringify(2)
    }
    return "struct " + self.name + " {" + os_EOL + content + "}" + os_EOL
  }
}

export obj CStructureDeclarationMember {
  mut t: CType
  mut name: str

  fn stringify (self: ref Self, indent := 0) str {
    return ' '.repeat(indent) + self.t.stringify(declaration: true) + self.name + ";" + os_EOL
  }
}

export obj CSwitchStatement {
  mut discriminant: CExpression
  mut body: CStatement[]

  fn stringify (self: ref Self) str {
    return "todo"
  }
}

export obj CVariableDeclaration {
  mut t: CType
  mut name: str
  mut initializer: CExpression?

  fn stringify (self: ref Self) str {
    return "todo"
  }
}

export obj CWhileStatement {
  mut condition: CExpression
  mut body: CStatement

  fn stringify (self: ref Self) str {
    return "todo"
  }
}

export fn createIdentifier (name: str) CExpression {
  // todo
}

export fn createLiteral (value: str | int) CExpression {
  intValue := (value is int) ? value : 0
  stringValue := (value is str) ? value : ""
  return createExpression(CLiteral{intValue: intValue, stringValue: stringValue})
}

export fn createAssignmentExpression (left: CExpression, operator: str, right: CExpression) CExpression {
  // todo
}

export fn createBinaryExpression (left: CExpression, operator: str, right: CExpression) CExpression {
  // todo
}

export fn createCallExpression (callee: CExpression, arguments: (CExpression | CType)[]) CExpression {
  // todo
}

export fn createCastExpression (t: CType, argument: CExpression) CExpression {
  // todo
}

export fn createConditionalExpression (
  condition: CExpression,
  consequent: CExpression,
  alternate: CExpression
) CExpression {
  // todo
}

export fn createElementAccessExpression (expression: CExpression, element: CExpression) CExpression {
  // todo
}

export fn createInitializerListExpression (items: CExpression[]) CExpression {
  // todo
}

export fn createPropertyAccessExpression (expression: CExpression, property: str, pointed: bool) CExpression {
  // todo
}

export fn createUnaryExpression (argument: CExpression, operator: str, prefix: bool) CExpression {
  // todo
}

export fn createBreakStatement () CStatement {
  // todo
}

export fn createCaseStatement (test: CExpression, body: CStatement) CStatement {
  // todo
}

export fn createCompoundStatement (body: CStatement[]) CStatement {
  return createStatement(CCompoundStatement{body: body})
}

export fn createContinueStatement () CStatement {
  // todo
}

export fn createEmptyStatement () CStatement {
  return createStatement(CEmptyStatement{})
}

export fn createExpressionStatement (expression: CExpression) CStatement {
  return createStatement(CExpressionStatement{expression: expression})
}

export fn createForStatement (
  initializer: CStatement,
  condition: CExpression,
  update: CExpression,
  body: CStatement
) CStatement {
  // todo
}

export fn createFunctionDeclaration (name: str, returnType: CType, body: CStatement) CStatement {
  return createStatement(CFunctionDeclaration{
    name: name,
    returnType: returnType,
    body: body
  })
}

export fn createGotoStatement (label: str) CStatement {
  // todo
}

export fn createIfStatement (condition: CExpression, consequent: CStatement, alternate: CStatement) CStatement {
  // todo
}

export fn createLabelStatement (name: str) CStatement {
  // todo
}

export fn createReturnStatement () CStatement {
  // todo
}

export fn createReturnStatement (argument: CExpression? = nil) CStatement {
  // todo
}

export fn createStructureDeclaration (name: str, members: CStructureDeclarationMember[]) CStatement {
  // todo
}

export fn createSwitchStatement (discriminant: CExpression, body: CStatement[]) CStatement {
  // todo
}

export fn createVariableDeclaration (t: CType, name: str, initializer: CExpression? = nil) CStatement {
  // todo
}

export fn createWhileStatement (condition: CExpression, body: CStatement) CStatement {
  // todo
}

export fn createExpression (body: CExpressionBody, parenthesized := false) CExpression {
  return CExpression{body: body, parenthesized: parenthesized}
}

export fn createStatement (body: CStatementBody) CStatement {
  return CStatement{body: body}
}

export fn createType (value: str) CType {
  return CType{value: value}
}
