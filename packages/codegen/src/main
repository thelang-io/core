/*!
 * Copyright (c) Aaron Delasy
 * Licensed under the MIT License
 */

import * as Analyzer from "the/analyzer"
import * as Parser from "the/parser"
import Printer from "./printer"

export obj Codegen {
  mut printer: Printer

  fn init (mut self: ref Self) {
    self.printer.init()
  }

  fn onIdentifier (mut self: ref Self, expression: ref Parser.Expression, ctx: Analyzer.IdentifierContext) {
    it := expression.asIdentifier()

    if !ctx.currentType.isReference() && ctx.originalType.isReference() {
      self.printer.token("*")
    }

    self.printer.word(it.name)
    self.printer.newline()
  }
}

export fn codegen (inputPathOrCode: str, executablePath: str) str {
  print("Parsing file")
  mut f := Parser.parse(inputPathOrCode)
  print("Interconnecting")
  Parser.interconnect(ref f)
  mut generator := Codegen{}
  print("Initializing generator")
  generator.init()

  errors := Analyzer.analyze(ref f, Analyzer.Hooks{
    onIdentifier: (it: ref Parser.Expression, ctx: Analyzer.IdentifierContext) -> void {
      generatorRef := ref generator
      generator.onIdentifier(it, ctx)
    }
  })

  if !errors.empty {
    print(errors)
    process_exit(1)
  }

  print("Done")
  return generator.printer.data
}

export fn compile (inputPathOrCode: str, executablePath: str) {
  print("Generating code for '" + inputPathOrCode + "'")
  output := codegen(inputPathOrCode, executablePath)
  codePath := executablePath + ".c"

  fs_writeFileSync(codePath, output.toBuffer())
  process_runSync("clang '" + codePath + "' -O0 -w -o '" + executablePath + "'")
  fs_rmSync(codePath)
}

main {
  compile("./build/test-file", "./build/a.out")
}
