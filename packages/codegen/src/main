/*!
 * Copyright (c) Aaron Delasy
 * Licensed under the MIT License
 */

import * as Analyzer from "the/analyzer"
import * as Parser from "the/parser"
import * as AST from "./ast"

const BUILTIN_ENTITIES := ["print"]

export fn codeName (name: str) str {
  return "__THE_1_" + name
}

export fn typeName (name: str) str {
  return "__THE_1_" + name
}

export obj APIEntity {
  mut active: bool
  mut statement: AST.CStatement
}

export obj Codegen {
  mut analyzer: ref Analyzer.Analyzer
  mut api: APIEntity[str]
  mut statements: AST.CStatement[]
  mut flags: str[]
  mut mainStatements: AST.CStatement[]

  fn init (mut self: ref Self) {
    mut file := self.analyzer.files.last()
    mut tm := file.tm

    self.api.set("print", APIEntity{
      statement: AST.createFunctionDeclaration(AST.createType("void"), codeName("print"), [
        AST.createFunctionParameter(AST.createType("void *"), "params")
      ], AST.createCompoundStatement([
        AST.createVariableDeclaration(
          AST.createType("struct " + self._typeName(tm.createFunction(false, [
            Analyzer.TypeParameter{t: tm.createArray(tm.get("any")), variadic: true}
          ], tm.get("void"))) + "p" + " *"),
          "p",
          AST.createIdentifier("params")
        )
      ]))
    })
  }

  fn _ (mut self: ref Self, name: str) str {
    print("has name: ", name)
    if self.api.has(name) {
      mut item := self.api.get(name)
      if !item.active {
        item.active = true
        self.api.set(name, item)
      }

      return codeName(name)
    }

    return ""
  }

  fn generate (mut self: ref Self) {
    mut file := self.analyzer.files.last()
    self.statements = self._generateBlock(ref file.f.program.body)
    self._assemble()
  }

  fn getFlags () str {
    return "-O0 -w"
  }

  fn stringify (self: ref Self) str {
    mut result := ""
    l := self.statements.len

    loop i := 0; i < l; i++ {
      result += self.statements[i].stringify()
    }

    return result
  }

  fn _assemble (mut self: ref Self) {
    apiKeys := self.api.keys

    loop i := 0; i < apiKeys.len; i++ {
      apiKey := apiKeys[i]
      apiValue :=self.api.get(apiKey)

      if !apiValue.active {
        continue
      }

      self.statements.push(apiValue.statement)
    }

    self.statements.push(
      AST.createFunctionDeclaration(
        AST.createType("int"),
        "main",
        [],
        AST.createCompoundStatement(self.mainStatements)
      )
    )
  }

  fn _generateBlock (mut self: ref Self, items: ref Parser.Statement[]) AST.CStatement[] {
    mut result: AST.CStatement[]
    l := items.len

    loop i := 0; i < l; i++ {
      result.push(self._generateStatement(items[i]))
    }

    return result
  }

  fn _generateExpression (mut self: ref Self, item: ref Parser.Expression) AST.CExpression {
    if item.isIdentifier() {
      expression := item.asIdentifier()

      return AST.createIdentifier(
        BUILTIN_ENTITIES.contains(expression.name) ? self._(expression.name) : codeName(expression.name)
      )
    } elif item.isCall() {
      expression := item.asCall()
      return AST.createCallExpression(self._generateExpression(ref expression.callee))
    }

    return AST.createLiteral("NULL")
  }

  fn _generateStatement (mut self: ref Self, item: ref Parser.Statement) AST.CStatement {
    if item.isBlock() {
      statement := item.asBlock()
      return AST.createCompoundStatement(self._generateBlock(ref statement.body))
    } elif item.isExpression() {
      statement := item.asExpression()
      return AST.createExpressionStatement(self._generateExpression(ref statement.expression))
    } elif item.isMainDeclaration() {
      statement := item.asMainDeclaration()
      statementBody := statement.body.asBlock()
      self.mainStatements = self._generateBlock(ref statementBody.body)
      return AST.createEmptyStatement()
    }

    return AST.createExpressionStatement(AST.createLiteral("NULL2"))
  }

  fn _typeName (mut self: ref Self, it: ref Analyzer.Type) str {
    if it.isFunction() {
      t := it.asFunction()
      return "fn_sFP___FR" + self._typeName(t.returnType) + "FE"
    } elif it.isObject() {
      return it.name
    }

    return "nothing"
  }
}

export fn compile (analyzer: ref Analyzer.Analyzer, executablePath: str) {
  mut generator := Codegen{analyzer: analyzer}
  generator.init()
  generator.generate()

  codePath := executablePath + ".c"

  fs_writeFileSync(codePath, generator.stringify().toBuffer())
  process_runSync("clang '" + codePath + "' -o '" + executablePath + "' " + generator.getFlags())
  fs_rmSync(codePath)
}

main {
  inputPathOrCode := "./build/test-file"
  mut analyzer := Analyzer.Analyzer{}

  analyzer.files.push(Analyzer.AnalyzerFile{
    cwd: process_cwd(),
    analyzer: ref analyzer,
    f: Parser.parse(inputPathOrCode),
  })

  mut file := analyzer.files.last()
  Parser.interconnect(ref file.f)
  file.reader = Parser.Reader_init(file.f.path == "anonymous" ? file.f.content : file.f.path)
  file.init()
  file.analyze(ref file.f.program.body)

  if !analyzer.errors.empty {
    throw error_NewError("Failure when analyzing file")
  }

  compile(ref analyzer, "./build/a.out")
  print("Generated code for '" + inputPathOrCode + "'")
}
