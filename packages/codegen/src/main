/*!
 * Copyright (c) Aaron Delasy
 * Licensed under the MIT License
 */

import * as Analyzer from "the/analyzer"
import * as AST from "the/c"
import * as Parser from "the/parser"
import BlockData from "./block-data"

export fn typeParameterId (parameter: ref Analyzer.TypeParameter) str {
  if parameter.mutable && parameter.required { return "FP5" }
  elif parameter.mutable && parameter.variadic { return "FP6" }
  elif parameter.mutable { return "FP2" }
  elif parameter.required { return "FP3" }
  elif parameter.variadic { return "FP4" }
  else { return "FP1" }
}

export obj APIBuiltin {
  mut stddef: bool
  mut stdint: bool
  mut stdio: bool
  mut stdlib: bool
  mut theAny: bool
  mut theByte: bool
  mut theMacro: bool
  mut theSafe: bool
  mut theString: bool
}

export obj CodegenEntity {
  mut active: bool
  mut name: str
  mut codeName: str
  mut context: any
  mut generate: (mut self: ref Codegen, mut tm: ref Analyzer.TypeMap, entity: ref CodegenEntity) -> AST.CStatement
}

export fn typeShouldBeFreed (self: ref Analyzer.Type) bool {
  if self.isAlias() {
    t := self.asAlias()
    return typeShouldBeFreed(t.t)
  } elif self.isUnion() {
    t := self.asUnion()

    loop i := 0; i < t.types.len; i++ {
      subType := t.types[i]

      if typeShouldBeFreed(subType) {
        return true
      }
    }

    return false
  }

  return
    self.name == "any" ||
    self.name == "str" ||
    self.isArray() ||
    self.isFunction() ||
    self.isMap() ||
    self.isOptional()
}

export obj Codegen {
  mut analyzer: ref Analyzer.Analyzer
  mut builtin: APIBuiltin
  mut blockData: BlockData
  mut entities: CodegenEntity[]
  mut flags: str[]
  mut mainStatements: AST.CStatement[]
  mut globalStatements: AST.CStatement[]
  mut statements: AST.CStatement[]

  fn init (mut self: ref Self) {
  }

  fn generate (mut self: ref Self) {
    mut file := self.analyzer.files.last()
    self.globalStatements = self._generateBlock(ref file.f.program.body)
    self._assemble()
  }

  fn getFlags (self: ref Self) str {
    mut extraFlags: str[]

    if (
      self.builtin.theAny ||
      self.builtin.theByte ||
      self.builtin.theMacro ||
      self.builtin.theSafe ||
      self.builtin.theString
    ) {
      extraFlags.push("-lthe")
    }

    return ["-O0", "-w"].concat(extraFlags).join(" ")
  }

  fn stringify (self: ref Self) str {
    mut result := ""
    l := self.statements.len

    loop i := 0; i < l; i++ {
      result += self.statements[i].stringify()
    }

    return result
  }

  fn _ (mut self: ref Self, name: str) str {
    if self._hasEntity(name) {
      mut item := self._getEntity(name)

      if !item.active {
        item.active = true
      }

      return item.codeName
    } elif (
      name == "EXIT_FAILURE" ||
      name == "EXIT_SUCCESS" ||
      name == "NULL" ||
      name == "exit" ||
      name == "size_t"
    ) {
      self.builtin.stddef = true
    } elif (
      name == "fprintf" ||
      name == "printf" ||
      name == "snprintf" ||
      name == "sprintf" ||
      name == "stderr" ||
      name == "stdin" ||
      name == "stdout"
    ) {
      self.builtin.stdio = true
    } elif (
      name == "int8_t" ||
      name == "int16_t" ||
      name == "int32_t" ||
      name == "int64_t" ||
      name == "uint8_t" ||
      name == "uint16_t" ||
      name == "uint32_t" ||
      name == "uint64_t"
    ) {
      self.builtin.stdint = true
    } elif name == "the_any_t" {
      self.builtin.theAny = true
    } elif name == "the_byte_str" {
      self.builtin.theByte = true
    } elif name == "THE_EOL" {
      self.builtin.theMacro = true
    } elif ["the_safe_alloc", "the_safe_free", "the_safe_realloc"].contains(name) {
      self.builtin.theSafe = true
    } elif (
      name == "err_stack_t" ||
      name == "err_state_t" ||
      name == "err_state"
    ) {
      // todo
    } elif ["the_str_t", "the_str_alloc", "the_str_free"].contains(name) {
      self.builtin.theString = true
    } elif ["str_free"].contains(name) {
      return self._("the_str_free")
    } else {
      throw error_NewError("Tried activating unknown entity '" + name + "'")
    }

    return name
  }

  fn _assemble (mut self: ref Self) {
    mut statements: AST.CStatement[]
    mut file := self.analyzer.files.last()
    mut prevActive := 0

    loop {
      statements = []
      mut currentActive := 0

      loop i := 0; i < self.entities.len; i++ {
        entity := self.entities[i]

        if !entity.active {
          continue
        }

        statements.push(entity.generate(self, ref file.tm, entity))
        currentActive++
      }

      if prevActive == currentActive {
        break
      }

      prevActive = currentActive
    }

    if self.builtin.theAny { self.statements.push(AST.createIncludeDirective("the/any.h")) }
    if self.builtin.theByte { self.statements.push(AST.createIncludeDirective("the/byte.h")) }
    if self.builtin.theMacro { self.statements.push(AST.createIncludeDirective("the/macro.h")) }
    if self.builtin.theSafe { self.statements.push(AST.createIncludeDirective("the/safe.h")) }
    if self.builtin.theString { self.statements.push(AST.createIncludeDirective("the/string.h")) }
    if self.builtin.stddef { self.statements.push(AST.createIncludeDirective("stddef.h")) }
    if self.builtin.stdio { self.statements.push(AST.createIncludeDirective("stdio.h")) }
    if self.builtin.stdint { self.statements.push(AST.createIncludeDirective("stdint.h")) }
    if self.builtin.stdlib { self.statements.push(AST.createIncludeDirective("stdlib.h")) }

    self.statements.merge(statements)

    self.statements.push(
      AST.createFunctionDeclaration(
        AST.createType("int"),
        "main",
        [],
        AST.createCompoundStatement(self.mainStatements)
      )
    )
  }

  fn _generateBlock (mut self: ref Self, items: ref Parser.Statement[]) AST.CStatement[] {
    mut result: AST.CStatement[]
    l := items.len

    loop i := 0; i < l; i++ {
      result.push(self._generateStatement(items[i]))
    }

    return result
  }

  fn _generateExpression (mut self: ref Self, item: ref Parser.Expression) AST.CExpression {
    if item.isIntegerLiteral() {
      expression := item.asIntegerLiteral()
      return AST.createLiteral(expression.value)
    } elif item.isStringLiteral() {
      expression := item.asStringLiteral()
      rawValue := "L\"" + expression.value + "\""

      if !item.hasParent() {
        return AST.createCallExpression(
          AST.createIdentifier(self._("the_str_alloc")),
          [AST.createLiteral(rawValue)]
        )
      }

      return AST.createLiteral(rawValue)
    } elif item.isIdentifier() {
      expression := item.asIdentifier()
      if self._hasEntity(expression.name) {
        return AST.createIdentifier(self._(expression.name))
      } else {
        return AST.createIdentifier(expression.name)
      }
    } elif item.isCall() {
      expression := item.asCall()
      return AST.createCallExpression(self._generateExpression(ref expression.callee))
    } elif item.isReference() {
      expression := item.asReference()
      return AST.createUnaryExpression("&", self._generateExpression(ref expression.expression))
    }

    throw error_NewError("Tried code generation for unknown expression")
  }

  fn _generateStatement (mut self: ref Self, item: ref Parser.Statement) AST.CStatement {
    if item.isBlock() {
      statement := item.asBlock()
      return AST.createCompoundStatement(self._generateBlock(ref statement.body))
    } elif item.isExpression() {
      statement := item.asExpression()
      return AST.createExpressionStatement(self._generateExpression(ref statement.expression))
    } elif item.isMainDeclaration() {
      statement := item.asMainDeclaration()
      statementBody := statement.body.asBlock()

      self.mainStatements = self._generateBlock(ref statementBody.body)
      self.mainStatements.merge(self.blockData.getCleanup())

      return AST.createEmptyStatement()
    } elif item.isVariableDeclaration() {
      statement := item.asVariableDeclaration()
      self._validateContext(item.context is Analyzer.VariableDeclarationContext)
      context := item.context as Analyzer.VariableDeclarationContext
      typeName := self._typeName(context.varType)
      t := AST.createType(self._type(context.varType))

      if typeShouldBeFreed(context.varType) {
        self.blockData.addCleanup(
          AST.createExpressionStatement(
            AST.createCallExpression(
              AST.createIdentifier(self._(typeName + "_free")),
              [AST.createIdentifier(statement.name.name)]
            )
          )
        )
      }

      if context.varType.isOptional() {
        mut initializer: AST.CExpression?

        if statement.initializer != nil {
          if !statement.initializer.isNilLiteral() {
            initializer = self._generateExpression(ref statement.initializer)
          }
        }

        return AST.createVariableDeclaration(
          t,
          statement.name.name,
          initializer == nil
            ? AST.createIdentifier(self._("NULL"))
            : AST.createCallExpression(AST.createIdentifier(self._(typeName + "_alloc")), [initializer])
        )
      } else {
        mut initializer: AST.CExpression?

        if statement.initializer != nil {
          initializer = self._generateExpression(ref statement.initializer)
        }

        return AST.createVariableDeclaration(t, statement.name.name, initializer)
      }
    }

    throw error_NewError("Tried code generation for unknown statement")
  }

  fn _getEntity (self: ref Self, name: str) ref CodegenEntity {
    loop i := self.entities.len - 1; i >= 0; i-- {
      entity := self.entities[i]

      if entity.name == name {
        return entity
      }
    }

    throw error_NewError("Entity with name '" + name + "' doesn't exists")
  }

  fn _hasEntity (self: ref Self, name: str) bool {
    loop i := self.entities.len - 1; i >= 0; i-- {
      entity := self.entities[i]

      if entity.name == name {
        return true
      }
    }

    return false
  }

  fn _type (mut self: ref Self, it: ref Analyzer.Type) str {
    if it.isAlias() {
      t := it.asAlias()
      return self._type(t.t)
    } elif it.name == "any" {
      return self._("the_any_t") + " "
    } elif it.name == "bool" {
      return self._("bool_t") + " "
    } elif it.name == "byte" {
      return "unsigned char "
    } elif it.name == "char" {
      return "char "
    } elif it.name == "f32" {
      return "float "
    } elif it.name == "f64" || it.name == "float" {
      return "double "
    } elif it.name == "i8" {
      return self._("int8_t") + " "
    } elif it.name == "i16" {
      return self._("int16_t") + " "
    } elif it.name == "i32" || it.name == "int" {
      return self._("int32_t") + " "
    } elif it.name == "i64" {
      return self._("int64_t") + " "
    } elif it.name == "isize" {
      return self._("ssize_t") + " "
    } elif it.name == "str" {
      self.builtin.theString = true
      return self._("the_str_t") + " "
    } elif it.name == "u8" {
      return self._("uint8_t") + " "
    } elif it.name == "u16" {
      return self._("uint16_t") + " "
    } elif it.name == "u32" {
      return self._("uint32_t") + " "
    } elif it.name == "u64" {
      return self._("uint64_t") + " "
    } elif it.name == "usize" {
      return self._("size_t") + " "
    } elif it.name == "void" {
      return "void "
    } elif it.isOptional() {
      typeName := self._typeName(it)
      name := typeName + "_t"
      if !self._hasEntity(name) { self._typeOptional(it, typeName, name) }
      return self._(name) + " "
    } elif it.isReference() {
      typeName := self._typeName(it)
      name := typeName + "_t"
      if !self._hasEntity(name) { self._typeReference(it, typeName, name) }
      return self._(name) + " "
    } elif (
      it.isEnum() ||
      it.isFunction() ||
      it.isMap() ||
      it.isObject() ||
      it.isOptional() ||
      it.isUnion()
    ) {
      return self._(self._typeName(it) + "_t") + " "
    }

    throw error_NewError("Failed to generate type for '" + it.name + "'")
  }

  fn _typeName (mut self: ref Self, it: ref Analyzer.Type) str {
    if it.isAlias() {
      t := it.asAlias()
      return self._typeName(t.t)
    } elif it.isArray() {
      t := it.asArray()
      return "arr_" + self._typeName(t.elementType)
    } elif it.isEnum() || it.isObject() {
      return it.name
    } elif it.isFunction() {
      t := it.asFunction()
      mut name := "fn_" + (t.asynchronous ? "a" : "s")

      loop i := 0; i < t.parameters.len; i++ {
        parameter := t.parameters[i]
        name += typeParameterId(parameter) + self._typeName(parameter.t)
      }

      return name + "FR" + self._typeName(t.returnType) + "FE"
    } elif it.isMap() {
      t := it.asMap()
      return "map_" + self._typeName(t.keyType) + "MS" + self._typeName(t.valueType) + "ME"
    } elif it.isMethod() {
      t := it.asMethod()
      mut name := "fn_" + (t.asynchronous ? "a" : "s")

      if t.withSelf {
        name += "FS" + self._typeName(t.selfType)
      }

      loop i := 0; i < t.parameters.len; i++ {
        parameter := t.parameters[i]
        name += typeParameterId(parameter) + self._typeName(parameter.t)
      }

      return name + "FR" + self._typeName(t.returnType) + "FE"
    } elif it.isOptional() {
      t := it.asOptional()
      return "opt_" + self._typeName(t.t)
    } elif it.isReference() {
      t := it.asReference()
      return "ref_" + self._typeName(t.t)
    } elif it.isUnion() {
      t := it.asUnion()
      mut name := ""

      loop i := 0; i < t.types.len; i++ {
        subType := t.types[i] as ref Analyzer.Type
        name += i == 0 ? "" : "US"
        name += self._typeName(subType)
      }

      return "union_" + name + "UE"
    }

    throw error_NewError("Failed to generate type name for '" + it.name + "'")
  }

  fn _typeOptional (mut self: ref Self, it: ref Analyzer.Type, typeName: str, name: str) {
    self.entities.push(CodegenEntity{
      name: name,
      codeName: name,
      context: it,
      generate: (mut self: ref Codegen, mut tm: ref Analyzer.TypeMap, entity: ref CodegenEntity) -> AST.CStatement {
        it := entity.context as ref Analyzer.Type
        t := it.asOptional()
        return AST.createTypedefDeclaration(AST.createType(self._type(t.t) + "*"), entity.codeName)
      }
    })

    self.entities.push(CodegenEntity{
      name: typeName + "_alloc",
      codeName: typeName + "_alloc",
      context: it,
      generate: (mut self: ref Codegen, mut tm: ref Analyzer.TypeMap, entity: ref CodegenEntity) -> AST.CStatement {
        it := entity.context as ref Analyzer.Type
        t := it.asOptional()
        typeName := self._typeName(it)
        name := typeName + "_t"
        underlyingCType := AST.createType(self._type(t.t))

        return AST.createFunctionDeclaration(AST.createType(self._(name)), entity.codeName, [
          AST.createFunctionParameter(underlyingCType, "n")
        ], AST.createCompoundStatement([
          AST.createVariableDeclaration(
            AST.createType(self._(name)),
            "r",
            AST.createCallExpression(AST.createIdentifier(self._("the_safe_alloc")), [
              AST.createCallExpression(AST.createIdentifier("sizeof"), [underlyingCType])
            ])
          ),
          AST.createExpressionStatement(
            AST.createAssignmentExpression(
              AST.createUnaryExpression("*", AST.createIdentifier("r")),
              "=",
              AST.createIdentifier("n")
            )
          ),
          AST.createReturnStatement(AST.createIdentifier("r"))
        ]))
      }
    })

    self.entities.push(CodegenEntity{
      name: typeName + "_free",
      codeName: typeName + "_free",
      context: it,
      generate: (mut self: ref Codegen, mut tm: ref Analyzer.TypeMap, entity: ref CodegenEntity) -> AST.CStatement {
        it := entity.context as ref Analyzer.Type
        typeName := self._typeName(it)
        name := typeName + "_t"

        return AST.createFunctionDeclaration(AST.createType("void"), entity.codeName, [
          AST.createFunctionParameter(AST.createType(self._(name)), "n")
        ], AST.createCompoundStatement([
          AST.createIfStatement(
            AST.createBinaryExpression(AST.createIdentifier("n"), "==", AST.createIdentifier(self._("NULL"))),
            AST.createReturnStatement()
          ),
          // todo
          // if (underlyingTypeInfo.type->shouldBeFreed()) {
          //   def += "  " + this->_genFreeFn(underlyingTypeInfo.type, CodegenASTExprUnary::create("*", CodegenASTExprAccess::create("n")))->str() + ";" EOL;
          // }
          AST.createExpressionStatement(AST.createCallExpression(AST.createIdentifier(self._("the_safe_free")), [AST.createIdentifier("n")]))
        ]))
      }
    })
  }

  fn _typeReference (mut self: ref Self, it: ref Analyzer.Type, typeName: str, name: str) {
    self.entities.push(CodegenEntity{
      name: name,
      codeName: name,
      context: it,
      generate: (mut self: ref Codegen, mut tm: ref Analyzer.TypeMap, entity: ref CodegenEntity) -> AST.CStatement {
        it := entity.context as ref Analyzer.Type
        t := it.asReference()
        return AST.createTypedefDeclaration(AST.createType(self._type(t.t) + "*"), entity.codeName)
      }
    })
  }

  fn _validateContext (valid: bool) {
    if !valid {
      throw error_NewError("Context is not set")
    }
  }
}

export fn compile (analyzer: ref Analyzer.Analyzer, executablePath: str) {
  mut generator := Codegen{analyzer: analyzer}
  generator.init()
  generator.generate()

  codePath := executablePath + ".c"

  fs_writeFileSync(codePath, generator.stringify().toBuffer())
  process_runSync("clang '" + codePath + "' -o '" + executablePath + "' " + generator.getFlags())
  // fs_rmSync(codePath)
}

main {
  inputPathOrCode := "./build/test-file"
  mut analyzer := Analyzer.Analyzer{}

  analyzer.files.push(Analyzer.AnalyzerFile{
    cwd: process_cwd(),
    analyzer: ref analyzer,
    f: Parser.parse(inputPathOrCode),
  })

  mut file := analyzer.files.last()
  Parser.interconnect(ref file.f)
  file.reader = Parser.Reader_init(file.f.path == "anonymous" ? file.f.content : file.f.path)
  file.init()
  file.analyze(ref file.f.program.body)

  if !analyzer.errors.empty {
    throw error_NewError("Failure when analyzing file")
  }

  compile(ref analyzer, "./build/a.out")
  print("Generated code for '" + inputPathOrCode + "'")
}
