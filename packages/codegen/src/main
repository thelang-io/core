/*!
 * Copyright (c) Aaron Delasy
 * Licensed under the MIT License
 */

import * as Analyzer from "the/analyzer"
import * as Parser from "the/parser"
import Printer from "./printer"

export obj Codegen {
  mut printer: Printer

  fn init (mut self: ref Self) {
    self.printer.init()
  }

  fn onIdentifier (mut self: ref Self, it: ref Parser.Identifier, ctx: Analyzer.IdentifierContext) {
    if !ctx.currentType.isReference() && ctx.originalType.isReference() {
      self.printer.token("*")
    }

    self.printer.word(it.name)
    self.printer.newline()
  }
}

export fn codegen (inputPathOrCode: str, executablePath: str) str {
  mut f := Parser.parse(inputPathOrCode)
  Parser.interconnect(ref f)
  mut generator := Codegen{}
  generator.init()

  errors := Analyzer.analyze(ref f, Analyzer.Hooks{
    onIdentifier: generator.onIdentifier
  })

  if !errors.empty {
    print(errors)
    process_exit(1)
  }

  return generator.data
}

export fn compile (inputPathOrCode: str, executablePath: str) {
  output := codegen(inputPathOrCode, executablePath)
  codePath := executablePath + ".c"

  fs_writeFileSync(codePath, output.toBuffer())
  process_runSync("clang '" + codePath + "' -O0 -w -o '" + executablePath + "'")
  fs_rmSync(codePath)
}

main {
  compile("./build/test-file", "./build/a.out")
}
