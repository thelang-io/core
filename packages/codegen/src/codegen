/*!
 * Copyright (c) Aaron Delasy
 * Licensed under the MIT License
 */

import * as Analyzer from "the/analyzer"
import * as AST from "the/c"
import * as Parser from "the/parser"

export obj CodegenAPIBuiltin {
  mut theAny: bool
  mut theBool: bool
  mut theByte: bool
  mut theError: bool
  mut theMacro: bool
  mut theNumber: bool
  mut theSafe: bool
  mut theString: bool
  mut stdbool: bool
  mut stddef: bool
  mut stdint: bool
  mut stdio: bool
  mut stdlib: bool
  mut wchar: bool
}

export obj BlockData {
  mut cleanup: AST.CStatement[]

  fn addCleanup (mut self: ref Self, item: AST.CStatement) {
    self.cleanup.push(item)
  }

  fn getCleanup (mut self: ref Self) AST.CStatement[] {
    mut cleanup := self.cleanup.reverse()
    self.cleanup = []
    return cleanup
  }
}

export obj CodegenEntity {
  mut active: bool
  mut name: str
  mut codeName: str
  mut context: any
  mut generate: (mut state: ref CodegenState, mut tm: ref Analyzer.TypeMap, entity: ref CodegenEntity) -> AST.CStatement
}

export obj CodegenState {
  _: (str) -> str
  block: (ref Parser.Statement[]) -> AST.CStatement[]
  defaultInitializerVariableDeclaration: (ref Analyzer.Type) -> AST.CExpression
  e: (ref Parser.Expression) -> AST.CExpression
  functionCopy: (ref Analyzer.Type, AST.CExpression) -> AST.CExpression
  functionEq: (ref Analyzer.Type, AST.CExpression, AST.CExpression) -> AST.CExpression
  functionFree: (ref Analyzer.Type, AST.CExpression) -> AST.CExpression
  functionNe: (ref Analyzer.Type, AST.CExpression, AST.CExpression) -> AST.CExpression
  functionRealloc: (ref Analyzer.Type, AST.CExpression, AST.CExpression) -> AST.CExpression
  functionStr: (ref Analyzer.Type, AST.CExpression) -> AST.CExpression
  get: (str) -> ref CodegenEntity
  has: (str) -> bool
  t: (ref Analyzer.Type) -> str
  typeDef: (ref Analyzer.Type) -> str
  typeName: (ref Analyzer.Type) -> str

  mut builtin: CodegenAPIBuiltin
  mut blockData: BlockData
  mut entities: CodegenEntity[]
  mut flags: str[]
  mut lastTypeId: int
  mut mainStatements: AST.CStatement[]
  mut globalStatements: AST.CStatement[]
  mut statements: AST.CStatement[]
}

export fn generateIdentifier (mut state: ref CodegenState, item: ref Parser.Expression) AST.CExpression? {
  if item.isIdentifier() {
    expression := item.asIdentifier()

    if state.has(expression.name) {
      return AST.createIdentifier(state._(expression.name))
    } else {
      return AST.createIdentifier(expression.name)
    }
  }

  return nil
}

export fn generateLiteral (mut state: ref CodegenState, item: ref Parser.Expression) AST.CExpression? {
  if item.isBooleanLiteral() {
    expression := item.asBooleanLiteral()
    return AST.createLiteral(state._(expression.value))
  } elif item.isCharacterLiteral() {
    expression := item.asCharacterLiteral()
    return AST.createLiteral("L'" + expression.value + "'")
  } elif item.isFloatingPointLiteral() {
    expression := item.asFloatingPointLiteral()
    return AST.createLiteral(expression.value)
  } elif item.isIntegerLiteral() {
    expression := item.asIntegerLiteral()
    rawValue := expression.value.replace("O", "").replace("o", "")

    if !rawValue.contains("b") && !rawValue.contains("B") && !rawValue.contains("x") && !rawValue.contains("X") {
      numValue := rawValue.toU64()
      return AST.createLiteral(rawValue + (numValue > 9223372036854775807 ? "U" : ""))
    }

    return AST.createLiteral(rawValue)
  } elif item.isNilLiteral() {
    expression := item.asNilLiteral()
    return AST.createIdentifier(state._("NULL"))
  } elif item.isStringLiteral() {
    expression := item.asStringLiteral()
    sanitizedValue := expression.value
      .replace(os_EOL, "\" " + state._("THE_EOL") + " \"")
      .replace("\n", "\" " + state._("THE_EOL") + " \"")
    rawValue := "L\"" + sanitizedValue + "\""

    if !item.hasParent() && item.hasParentNode() {
      node := item.parentNode()

      if node.isVariableDeclaration() {
        return AST.createCallExpression(
          AST.createIdentifier(state._("the_str_alloc")),
          [AST.createLiteral(rawValue)]
        )
      }
    }

    return AST.createLiteral(rawValue)
  }

  return nil
}

export fn generateArrayExpression (mut state: ref CodegenState, item: ref Parser.Expression) AST.CExpression? {
  if item.isArray() {
    expression := item.asArray()
    validateContext(item.context is Analyzer.ArrayExpressionContext)
    context := item.context as Analyzer.ArrayExpressionContext
    typeName := state.typeName(context.t)
    mut arguments: (AST.CExpression | AST.CType)[] = [AST.createLiteral(expression.elements.len)]

    loop i := 0; i < expression.elements.len; i++ {
      element := expression.elements[i]
      arguments.push(state.e(element))
    }

    result := AST.createCallExpression(AST.createIdentifier(state._(typeName + "_alloc")), arguments)
    return item.hasParent() ? result : state.functionFree(context.t, result)
  }

  return nil
}

export fn generateAssignmentExpression (mut state: ref CodegenState, item: ref Parser.Expression) AST.CExpression? {
  if item.isAssignment() {
    expression := item.asAssignment()
    validateContext(item.context is Analyzer.AssignmentExpressionContext)
    context := item.context as Analyzer.AssignmentExpressionContext
    leftType := Analyzer.unwrap(context.leftType, withReference: false)
    rightType := Analyzer.unwrap(context.rightType, withReference: false)
    left := state.e(ref expression.left)
    mut right := state.e(ref expression.right)

    if expression.operator.t == .OpPlusEq && (leftType.name == "str" || rightType.name == "str") {
      return AST.createAssignmentExpression(
        left,
        "=",
        AST.createCallExpression(AST.createIdentifier(state._("the_str_realloc")), [
          left,
          AST.createCallExpression(AST.createIdentifier(state._("the_str_concat")), [left, right])
        ])
      )
    } elif !typePrimitive(leftType) || !typePrimitive(rightType) {
      result := state.functionRealloc(leftType, left, right)
      return item.hasParent() ? result : state.functionCopy(leftType, result)
    } elif expression.operator.t == .OpAmpAmp || expression.operator.t == .OpPipePipe {
      right = AST.createBinaryExpression(left, expression.operator.val, right)
      return AST.createAssignmentExpression(left, "=", right)
    }

    return AST.createAssignmentExpression(left, expression.operator.val, right)
  }

  return nil
}

export fn generateBinaryExpression (mut state: ref CodegenState, item: ref Parser.Expression) AST.CExpression? {
  if item.isBinary() {
    expression := item.asBinary()
    validateContext(item.context is Analyzer.BinaryExpressionContext)
    context := item.context as Analyzer.BinaryExpressionContext
    leftType := Analyzer.unwrap(context.leftType, withReference: false)
    rightType := Analyzer.unwrap(context.rightType, withReference: false)
    left := state.e(ref expression.left)
    mut right := state.e(ref expression.right)

    if (
      (expression.operator.t == .OpEqEq || expression.operator.t == .OpExclEq) &&
      (!typePrimitive(context.leftType) || !typePrimitive(context.rightType))
    ) {
      return expression.operator.t == .OpEqEq ? state.functionEq(leftType, left, right) : state.functionNe(leftType, left, right)
    } elif leftType.name == "str" && rightType.name == "str" && (
      expression.operator.t == .OpLt ||
      expression.operator.t == .OpLtEq ||
      expression.operator.t == .OpGt ||
      expression.operator.t == .OpGtEq
    ) {
      direction := expression.operator.t == .OpLt
        ? "lt"
        : expression.operator.t == .OpLtEq
          ? "le"
          : expression.operator.t == .OpGt
            ? "gt"
            : "ge"

      return AST.createCallExpression(AST.createIdentifier(state._("the_str_" + direction)), [left, right])
    } elif expression.operator.t == .OpPlus && leftType.name == "str" && rightType.name == "str" {
      result := AST.createCallExpression(AST.createIdentifier(state._("the_str_concat")), [left, right])
      return item.hasParent() ? result : state.functionFree(leftType, result)
    }

    return AST.createBinaryExpression(left, expression.operator.val, right)
  }

  return nil
}

// todo finalize
export fn generateCallExpression (mut state: ref CodegenState, item: ref Parser.Expression) AST.CExpression? {
  if item.isCall() {
    expression := item.asCall()
    return AST.createCallExpression(state.e(ref expression.callee))
  }

  return nil
}

export fn generateConditionalExpression (mut state: ref CodegenState, item: ref Parser.Expression) AST.CExpression? {
  if item.isConditional() {
    expression := item.asConditional()
    validateContext(item.context is Analyzer.ConditionalExpressionContext)
    context := item.context as Analyzer.ConditionalExpressionContext
    alternateType := Analyzer.unwrap(context.alternateType, withReference: false)
    mut alternate := state.e(ref expression.alternate)

    if expression.alternate.isAssignment() && !typeSafeForTernaryAlternate(alternateType) {
      alternate = alternate.wrap()
    }

    return AST.createConditionalExpression(
      state.e(ref expression.condition),
      state.e(ref expression.consequent),
      alternate
    )
  }

  return nil
}

export fn generateIsExpression (mut state: ref CodegenState, item: ref Parser.Expression) AST.CExpression? {
  if item.isIs() {
    expression := item.asIs()
    validateContext(item.context is Analyzer.IsExpressionContext)
    context := item.context as Analyzer.IsExpressionContext
    left := AST.createPropertyAccessExpression(state.e(ref expression.expression), "t")
    right := AST.createIdentifier(state.typeDef(context.rightType))

    return AST.createBinaryExpression(left, "==", right)
  }

  return nil
}

export fn generateParenthesizedExpression (mut state: ref CodegenState, item: ref Parser.Expression) AST.CExpression? {
  if item.isParenthesized() {
    expression := item.asParenthesized()
    result := state.e(ref expression.expression)
    return result.wrap()
  }

  return nil
}

export fn generateReferenceExpression (mut state: ref CodegenState, item: ref Parser.Expression) AST.CExpression? {
  if item.isReference() {
    expression := item.asReference()
    return AST.createUnaryExpression("&", state.e(ref expression.expression))
  }

  return nil
}

export fn generateUnaryExpression (mut state: ref CodegenState, item: ref Parser.Expression) AST.CExpression? {
  if item.isUnary() {
    expression := item.asUnary()
    validateContext(item.context is Analyzer.UnaryExpressionContext)
    context := item.context as Analyzer.UnaryExpressionContext

    if context.operandType.isFloat() {
      castExpression := AST.createCastExpression(AST.createType(state._("bool")), state.e(ref expression.operand))

      return AST.createUnaryExpression(
        expression.operator.val,
        castExpression.wrap(),
        postfix: !expression.prefix
      )
    }

    return AST.createUnaryExpression(
      expression.operator.val,
      state.e(ref expression.operand),
      postfix: !expression.prefix
    )
  }

  return nil
}

export fn generateBlockStatement (mut state: ref CodegenState, item: ref Parser.Statement) AST.CStatement? {
  if item.isBlock() {
    statement := item.asBlock()
    return AST.createCompoundStatement(state.block(ref statement.body))
  }

  return nil
}

export fn generateExpressionStatement (mut state: ref CodegenState, item: ref Parser.Statement) AST.CStatement? {
  if item.isExpression() {
    statement := item.asExpression()
    return AST.createExpressionStatement(state.e(ref statement.expression))
  }

  return nil
}

export fn generateMainDeclaration (mut state: ref CodegenState, item: ref Parser.Statement) AST.CStatement? {
  if item.isMainDeclaration() {
    statement := item.asMainDeclaration()
    statementBody := statement.body.asBlock()

    state.mainStatements = state.block(ref statementBody.body)
    state.mainStatements.merge(state.blockData.getCleanup())

    return AST.createEmptyStatement()
  }

  return nil
}

export fn generateVariableDeclaration (mut state: ref CodegenState, item: ref Parser.Statement) AST.CStatement? {
  if item.isVariableDeclaration() {
    statement := item.asVariableDeclaration()
    validateContext(item.context is Analyzer.VariableDeclarationContext)
    context := item.context as Analyzer.VariableDeclarationContext
    typeName := state.typeName(context.varType)
    t := AST.createType(state.t(context.varType))

    if typeShouldBeFreed(context.varType) {
      state.blockData.addCleanup(
        AST.createExpressionStatement(
          AST.createCallExpression(
            AST.createIdentifier(state._(typeName + "_free")),
            [AST.createIdentifier(statement.name.name)]
          )
        )
      )
    }

    initializer := statement.initializer == nil
      ? state.defaultInitializerVariableDeclaration(context.varType)
      : state.e(ref statement.initializer)

    return AST.createVariableDeclaration(t, statement.name.name, initializer)
  }

  return nil
}

export fn typeParameterId (parameter: ref Analyzer.TypeParameter) str {
  if parameter.mutable && parameter.required { return "FP5" }
  elif parameter.mutable && parameter.variadic { return "FP6" }
  elif parameter.mutable { return "FP2" }
  elif parameter.required { return "FP3" }
  elif parameter.variadic { return "FP4" }
  else { return "FP1" }
}

export fn typePrimitive (it: ref Analyzer.Type) bool {
  return !(
    it.name == "any" ||
    it.name == "str" ||
    it.isArray() ||
    it.isFunction() ||
    it.isMap() ||
    // todo
    // it.isObject() ||
    it.isOptional() ||
    it.isUnion()
  )
}

export fn typeSafeForTernaryAlternate (it: ref Analyzer.Type) bool {
  return it.name == "any" ||
    it.name == "str" ||
    it.isArray() ||
    it.isFunction() ||
    it.isMap() ||
    // todo
    // it.isObj() ||
    it.isOptional() ||
    it.isUnion()
}

export fn typeShouldBeFreed (self: ref Analyzer.Type) bool {
  if self.isAlias() {
    t := self.asAlias()
    return typeShouldBeFreed(t.t)
  } elif self.isUnion() {
    t := self.asUnion()

    loop i := 0; i < t.types.len; i++ {
      subType := t.types[i]

      if typeShouldBeFreed(subType) {
        return true
      }
    }

    return false
  }

  return
    self.name == "any" ||
    self.name == "str" ||
    self.isArray() ||
    self.isFunction() ||
    self.isMap() ||
    self.isOptional()
}

export fn validateContext (valid: bool) {
  if !valid {
    throw error_NewError("Context is not set")
  }
}

export obj Codegen {
  mut analyzer: ref Analyzer.Analyzer
  mut state: CodegenState

  fn init (mut self: ref Self) {
    self.state = CodegenState{
      _: (name: str) -> str {
        selfRef := ref self // todo remove after v1
        return self._(name)
      },
      block: (items: ref Parser.Statement[]) -> AST.CStatement[] {
        selfRef := ref self // todo remove after v1
        return self._generateBlock(items)
      },
      defaultInitializerVariableDeclaration: (item: ref Analyzer.Type) -> AST.CExpression {
        selfRef := ref self // todo remove after v1
        return self._defaultInitializerVariableDeclaration(item)
      },
      e: (item: ref Parser.Expression) -> AST.CExpression {
        selfRef := ref self // todo remove after v1
        return self._generateExpression(item)
      },
      functionCopy: (it: ref Analyzer.Type, expression: AST.CExpression) -> AST.CExpression {
        selfRef := ref self // todo remove after v1
        return self._functionCopy(it, expression)
      },
      functionEq: (it: ref Analyzer.Type, left: AST.CExpression, right: AST.CExpression) -> AST.CExpression {
        selfRef := ref self // todo remove after v1
        return self._functionEq(it, left, right)
      },
      functionFree: (it: ref Analyzer.Type, expression: AST.CExpression) -> AST.CExpression {
        selfRef := ref self // todo remove after v1
        return self._functionFree(it, expression)
      },
      functionNe: (it: ref Analyzer.Type, left: AST.CExpression, right: AST.CExpression) -> AST.CExpression {
        selfRef := ref self // todo remove after v1
        return self._functionNe(it, left, right)
      },
      functionRealloc: (it: ref Analyzer.Type, left: AST.CExpression, right: AST.CExpression) -> AST.CExpression {
        selfRef := ref self // todo remove after v1
        return self._functionRealloc(it, left, right)
      },
      functionStr: (it: ref Analyzer.Type, expression: AST.CExpression) -> AST.CExpression {
        selfRef := ref self // todo remove after v1
        return self._functionStr(it, expression)
      },
      get: (item: str) -> ref CodegenEntity {
        selfRef := ref self // todo remove after v1
        return self._getEntity(item)
      },
      has: (item: str) -> bool {
        selfRef := ref self // todo remove after v1
        return self._hasEntity(item)
      },
      t: (it: ref Analyzer.Type) -> str {
        selfRef := ref self // todo remove after v1
        return self._type(it)
      },
      typeDef: (it: ref Analyzer.Type) -> str {
        selfRef := ref self // todo remove after v1
        return self._typeDef(it)
      },
      typeName: (it: ref Analyzer.Type) -> str {
        selfRef := ref self // todo remove after v1
        return self._typeName(it)
      }
    }
  }

  fn generate (mut self: ref Self) {
    mut file := self.analyzer.files.last()
    self.state.globalStatements = self._generateBlock(ref file.f.program.body)
    self._assemble()
  }

  fn getFlags (self: ref Self) str {
    mut extraFlags: str[]

    if (
      self.state.builtin.theAny ||
      self.state.builtin.theBool ||
      self.state.builtin.theByte ||
      self.state.builtin.theError ||
      self.state.builtin.theMacro ||
      self.state.builtin.theNumber ||
      self.state.builtin.theSafe ||
      self.state.builtin.theString
    ) {
      extraFlags.push("-lthe")
    }

    result := [
      "-O0",
      "-Wall",
      "-Werror",
      "-Wextra",
      "-pedantic-errors",
      "-Wno-gnu-binary-literal",
      "-Wno-strict-prototypes",
      "-Wno-unused-but-set-variable",
      "-Wno-unused-value",
      "-Wno-unused-variable",
    ].concat(extraFlags).join(" ")
    return result.empty ? "" : (" " + result)
  }

  fn stringify (self: ref Self) str {
    mut result := ""
    l := self.state.statements.len

    loop i := 0; i < l; i++ {
      result += self.state.statements[i].stringify()
    }

    return result
  }

  fn _ (mut self: ref Self, name: str) str {
    if self._hasEntity(name) {
      mut item := self._getEntity(name)

      if !item.active {
        item.active = true
      }

      return item.codeName
    } elif ["bool", "false", "true"].contains(name) {
      self.state.builtin.stdbool = true
    } elif (
      [
        "EXIT_FAILURE",
        "NULL",
        "exit",
        "size_t"
      ].contains(name)
    ) {
      self.state.builtin.stddef = true
    } elif (
      [
        "fprintf",
        "printf",
        "snprintf",
        "sprintf",
        "stderr",
        "stdin",
        "stdout"
      ].contains(name)
    ) {
      self.state.builtin.stdio = true
    } elif (
      [
        "int8_t",
        "int16_t",
        "int32_t",
        "int64_t",
        "uint8_t",
        "uint16_t",
        "uint32_t",
        "uint64_t"
      ].contains(name)
    ) {
      self.state.builtin.stdint = true
    } elif (
      [
        "wchar_t"
      ].contains(name)
    ) {
      self.state.builtin.wchar = true
    } elif (
      [
        "the_any_t",
        "the_any_copy",
        "the_any_eq",
        "the_any_free",
        "the_any_ne",
        "the_any_realloc",
        "the_any_str"
      ].contains(name)
    ) {
      self.state.builtin.theAny = true
    } elif ["the_bool_str"].contains(name) {
      self.state.builtin.theBool = true
    } elif ["the_byte_str"].contains(name) {
      self.state.builtin.theByte = true
    } elif (
      [
        "the_Error_t",
        "the_err_buf_t",
        "the_err_stack_t",
        "the_err_state",
        "the_err_state_t",
        "the_error_assign",
        "the_error_assign_generic",
        "the_error_buf_decrease",
        "the_error_buf_increase",
        "the_error_stack_pop",
        "the_error_stack_push",
        "the_error_unset",
        "the_Error_alloc",
        "the_Error_free"
      ].contains(name)
    ) {
      self.state.builtin.theError = true
    } elif ["THE_OS_WINDOWS", "THE_OS_MACOS", "THE_OS_LINUX", "THE_EOL", "THE_PATH_SEP"].contains(name) {
      self.state.builtin.theMacro = true
    } elif (
      [
        "the_f32_str",
        "the_f64_str",
        "the_float_str",
        "the_i8_str",
        "the_i16_str",
        "the_i32_str",
        "the_i64_str",
        "the_int_str",
        "the_isize_str",
        "the_u8_str",
        "the_u16_str",
        "the_u32_str",
        "the_u64_str",
        "the_usize_str"
      ].contains(name)
    ) {
      self.state.builtin.theNumber = true
    } elif ["the_safe_alloc", "the_safe_free", "the_safe_realloc", "the_safe_swap"].contains(name) {
      self.state.builtin.theSafe = true
    } elif (
      [
        "the_str_t",
        "the_str_alloc",
        "the_str_calloc",
        "the_str_at",
        "the_str_concat",
        "the_str_contains",
        "the_str_copy",
        "the_str_empty",
        "the_str_eq",
        "the_str_escape",
        "the_str_find",
        "the_str_free",
        "the_str_ge",
        "the_str_gt",
        "the_str_le",
        "the_str_lines",
        "the_str_lower",
        "the_str_lowerFirst",
        "the_str_lt",
        "the_str_ne",
        "the_str_not",
        "the_str_realloc",
        "the_str_replace",
        "the_str_slice",
        "the_str_split",
        "the_str_toFloat",
        "the_str_toF32",
        "the_str_toF64",
        "the_str_toIsize",
        "the_str_toI8",
        "the_str_toI16",
        "the_str_toI32",
        "the_str_toI64",
        "the_str_toUsize",
        "the_str_toU8",
        "the_str_toU16",
        "the_str_toU32",
        "the_str_toU64",
        "the_str_trim",
        "the_str_trimEnd",
        "the_str_trimStart",
        "the_str_upper",
        "the_str_upperFirst"
      ].contains(name)
    ) {
      self.state.builtin.theString = true
    } else {
      throw error_NewError("Tried activating unknown entity '" + name + "'")
    }

    return name
  }

  fn _assemble (mut self: ref Self) {
    mut statements: AST.CStatement[]
    mut file := self.analyzer.files.last()
    mut prevActive := 0

    loop {
      statements = []
      mut currentActive := 0

      loop i := 0; i < self.state.entities.len; i++ {
        entity := self.state.entities[i]

        if !entity.active {
          continue
        }

        statements.push(entity.generate(ref self.state, ref file.tm, entity))
        currentActive++
      }

      if prevActive == currentActive {
        break
      }

      prevActive = currentActive
    }

    if self.state.builtin.theAny { self.state.statements.push(AST.createIncludeDirective("the/any.h")) }
    if self.state.builtin.theBool { self.state.statements.push(AST.createIncludeDirective("the/bool.h")) }
    if self.state.builtin.theByte { self.state.statements.push(AST.createIncludeDirective("the/byte.h")) }
    if self.state.builtin.theError { self.state.statements.push(AST.createIncludeDirective("the/error.h")) }
    if self.state.builtin.theMacro { self.state.statements.push(AST.createIncludeDirective("the/macro.h")) }
    if self.state.builtin.theNumber { self.state.statements.push(AST.createIncludeDirective("the/number.h")) }
    if self.state.builtin.theSafe { self.state.statements.push(AST.createIncludeDirective("the/safe.h")) }
    if self.state.builtin.theString { self.state.statements.push(AST.createIncludeDirective("the/string.h")) }

    if self.state.builtin.stdbool { self.state.statements.push(AST.createIncludeDirective("stdbool.h")) }
    if self.state.builtin.stddef { self.state.statements.push(AST.createIncludeDirective("stddef.h")) }
    if self.state.builtin.stdio { self.state.statements.push(AST.createIncludeDirective("stdio.h")) }
    if self.state.builtin.stdint { self.state.statements.push(AST.createIncludeDirective("stdint.h")) }
    if self.state.builtin.stdlib { self.state.statements.push(AST.createIncludeDirective("stdlib.h")) }
    if self.state.builtin.wchar { self.state.statements.push(AST.createIncludeDirective("wchar.h")) }

    self.state.statements.merge(statements)

    self.state.statements.push(
      AST.createFunctionDeclaration(
        AST.createType("int"),
        "main",
        [],
        AST.createCompoundStatement(self.state.mainStatements)
      )
    )
  }

  fn _defaultInitializerObjectExpression (mut self: ref Self, it: ref Analyzer.Type) AST.CExpression {
    if it.isAlias() {
      t := it.asAlias()
      return self._defaultInitializerObjectExpression(t.t)
    } elif it.name == "any" {
      return AST.createCastExpression(AST.createType(self._("the_any_t")), AST.createInitializerListExpression([
        AST.createLiteral(-1),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL"))
      ]))
    } elif it.name == "bool" {
      return AST.createIdentifier(self._("false"))
    } elif it.name == "char" {
      return AST.createLiteral("'\\0'")
    } elif it.name == "str" {
      return AST.createCallExpression(AST.createIdentifier(self._("the_str_alloc")), [
        AST.createLiteral("\"\"")
      ])
    } elif it.isArray() || it.isMap() {
      typeName := self._typeName(it)
      return AST.createCallExpression(AST.createIdentifier(self._(typeName + "_alloc")), [
        AST.createLiteral(0)
      ])
    // todo
    // } elif it.isObject() {
      // typeName := self._typeName(it)
      // mut args: AST.CExpression[]
      // loop i := 0; i < it.properties.len; i++ {
      //   property := it.properties[i]
      //   if property.builtin || property.t.isMethod() {
      //     continue
      //   }
      //   args.push(self._defaultInitializerObjectExpression(property.t))
      // }
      // return AST.createCallExpression(AST.createIdentifier(self._(typeName + "_alloc")), args)
    } elif it.isOptional() {
      return AST.createIdentifier(self._("NULL"))
    } elif it.isUnion() {
      // todo
    } elif !it.isFunction() && !it.isReference() {
      return AST.createLiteral(0)
    }

    throw error_NewError("Tried default object expressions declaration on unknown type")
  }

  fn _defaultInitializerVariableDeclaration (mut self: ref Self, it: ref Analyzer.Type) AST.CExpression {
    if it.isAlias () {
      t := it.asAlias()
      return self._defaultInitializerVariableDeclaration(t.t)
    } elif it.name == "any" {
      return AST.createInitializerListExpression([
        AST.createLiteral(-1),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL"))
      ])
    } elif it.name == "bool" {
      return AST.createIdentifier(self._("false"))
    } elif it.name == "char" {
      return AST.createLiteral("'\\0'")
    } elif it.name == "str" {
      return AST.createCallExpression(AST.createIdentifier(self._("the_str_alloc")), [AST.createLiteral("\"\"")])
    } elif it.isArray() || it.isMap() {
      typeName := self._typeName(it)
      return AST.createCallExpression(AST.createIdentifier(self._(typeName + "_alloc")), [
        AST.createLiteral(0)
      ])
    // todo
    // } elif it.isObject() {
      // typeName := self._typeName(it)
      // mut args : AST.CExpression[]
      // loop i := 0; i < it.properties.len; i++ {
      //   property := it.properties[i]
      //   if property.builtin || property.t.isMethod() {
      //     continue
      //   }
      //   args.push(self._defaultInitializerObjectExpression(property.t))
      // }
      // return AST.createCallExpression(AST.createIdentifier(self._(typeName + "_alloc")), args)
    } elif it.isOptional() {
      return AST.createIdentifier(self._("NULL"))
    } elif it.isUnion() {
      // todo
    } elif !it.isFunction() && !it.isReference() {
      return AST.createLiteral(0)
    }

    throw error_NewError("Tried default initializer variable declaration on unknown type")
  }

  fn _functionCopy (mut self: ref Self, it: ref Analyzer.Type, expression: AST.CExpression) AST.CExpression {
    if it.isAlias() {
      t := it.asAlias()
      return self._functionCopy(t.t, expression)
    } elif it.name == "any" {
      return AST.createCallExpression(AST.createIdentifier(self._("the_any_copy")), [expression])
    } elif it.name == "str" {
      return AST.createCallExpression(AST.createIdentifier(self._("the_str_copy")), [expression])
    } elif (
      it.isArray() ||
      it.isFunction() ||
      it.isMap() ||
      // todo
      // it.isObject() ||
      it.isOptional() ||
      it.isUnion()
    ) {
      typeName := self._typeName(it)
      return AST.createCallExpression(AST.createIdentifier(self._(typeName + "_copy")), [expression])
    }

    return expression
  }

  fn _functionEq (mut self: ref Self, it: ref Analyzer.Type, left: AST.CExpression, right: AST.CExpression, reverse := false) AST.CExpression {
    direction := reverse ? "ne" : "eq"

    if it.isAlias() {
      t := it.asAlias()
      return self._functionEq(t.t, left, right, reverse)
    } elif it.name == "any" {
      return AST.createCallExpression(AST.createIdentifier(self._("the_any_" + direction)), [left, right])
    } elif it.name == "str" {
      return AST.createCallExpression(AST.createIdentifier(self._("the_str_" + direction)), [left, right])
    } elif (
      it.isArray() ||
      it.isMap() ||
      // todo
      // it.isObject() ||
      it.isOptional() ||
      it.isUnion()
    ) {
      typeName := self._typeName(it)
      return AST.createCallExpression(AST.createIdentifier(self._(typeName + "_" + direction)), [left, right])
    } else {
      return AST.createAssignmentExpression(left, reverse ? "!=" : "==", right)
    }
  }

  fn _functionFree (mut self: ref Self, it: ref Analyzer.Type, expression: AST.CExpression) AST.CExpression {
    if it.isAlias() {
      t := it.asAlias()
      return self._functionFree(t.t, expression)
    } elif it.name == "any" {
      return AST.createCallExpression(AST.createIdentifier(self._("the_any_free")), [
        AST.createCastExpression(AST.createType(self._("the_any_t")), expression)
      ])
    } elif it.name == "str" {
      return AST.createCallExpression(AST.createIdentifier(self._("the_str_free")), [
        AST.createCastExpression(AST.createType(self._("the_str_t")), expression)
      ])
    } elif (
      it.isArray() ||
      it.isFunction() ||
      it.isMap() ||
      // todo
      // it.isObject() ||
      it.isOptional() ||
      it.isUnion()
    ) {
      typeName := self._typeName(it)

      return AST.createCallExpression(AST.createIdentifier(self._(typeName + "_free")), [
        AST.createCastExpression(AST.createType(self._type(it)), expression)
      ])
    }

    return expression
  }

  fn _functionNe (mut self: ref Self, it: ref Analyzer.Type, left: AST.CExpression, right: AST.CExpression) AST.CExpression {
    return self._functionEq(it, left, right, reverse: true)
  }

  fn _functionRealloc (mut self: ref Self, it: ref Analyzer.Type, left: AST.CExpression, right: AST.CExpression) AST.CExpression {
    if it.isAlias() {
      t := it.asAlias()
      return self._functionRealloc(t.t, left, right)
    } elif it.name == "any" {
      return AST.createAssignmentExpression(
        left,
        "=",
        AST.createCallExpression(AST.createIdentifier(self._("the_any_realloc")), [left, right])
      )
    } elif it.name == "str" {
      return AST.createAssignmentExpression(
        left,
        "=",
        AST.createCallExpression(AST.createIdentifier(self._("the_str_realloc")), [left, right])
      )
    } elif (
      it.isArray() ||
      it.isFunction() ||
      it.isMap() ||
      // todo
      // it.isObject() ||
      it.isOptional() ||
      it.isUnion()
    ) {
      typeName := self._typeName(it)

      return AST.createAssignmentExpression(
        left,
        "=",
        AST.createCallExpression(AST.createIdentifier(self._(typeName + "_realloc")), [left, right])
      )
    }

    return AST.createIdentifier(self._("NULL"))
  }

  fn _functionStr (mut self: ref Self, it: ref Analyzer.Type, expression: AST.CExpression, escape := true) AST.CExpression {
    if it.isAlias() {
      t := it.asAlias()
      return self._functionStr(t.t, expression, escape)
    } elif it.name == "any" {
      return AST.createCallExpression(AST.createIdentifier(self._("the_any_str")), [expression])
    } elif it.name == "str" && escape {
      return AST.createCallExpression(AST.createIdentifier(self._("the_str_escape")), [expression])
    } elif it.name == "str" && escape {
      return expression
    } elif it.isEnum() {
      return AST.createCallExpression(AST.createIdentifier(self._("the_enum_str")), [expression])
    } else {
      typeName := self._typeName(it)
      return AST.createCallExpression(AST.createIdentifier(self._(typeName + "_str")), [expression])
    }
  }

  fn _generateBlock (mut self: ref Self, items: ref Parser.Statement[]) AST.CStatement[] {
    mut result: AST.CStatement[]
    l := items.len

    loop i := 0; i < l; i++ {
      result.push(self._generateStatement(items[i]))
    }

    return result
  }

  fn _generateExpression (mut self: ref Self, item: ref Parser.Expression) AST.CExpression {
    mut result: AST.CExpression?

    if (
      (result = generateIdentifier(ref self.state, item)) != nil || // todo test
      (result = generateCallExpression(ref self.state, item)) != nil || // todo test
      (result = generateLiteral(ref self.state, item)) != nil ||
      (result = generateParenthesizedExpression(ref self.state, item)) != nil ||
      (result = generateAssignmentExpression(ref self.state, item)) != nil ||
      (result = generateBinaryExpression(ref self.state, item)) != nil ||
      (result = generateConditionalExpression(ref self.state, item)) != nil ||
      (result = generateReferenceExpression(ref self.state, item)) != nil ||
      (result = generateUnaryExpression(ref self.state, item)) != nil
    ) {
      return result
    }

    throw error_NewError("Tried code generation for unknown expression")
  }

  fn _generateStatement (mut self: ref Self, item: ref Parser.Statement) AST.CStatement {
    mut result: AST.CStatement?

    if (
      (result = generateBlockStatement(ref self.state, item)) != nil || // todo test
      (result = generateExpressionStatement(ref self.state, item)) != nil || // todo test
      (result = generateMainDeclaration(ref self.state, item)) != nil || // todo test
      (result = generateVariableDeclaration(ref self.state, item)) != nil
    ) {
      return result
    }

    throw error_NewError("Tried code generation for unknown statement")
  }

  fn _getEntity (self: ref Self, name: str) ref CodegenEntity {
    loop i := self.state.entities.len - 1; i >= 0; i-- {
      entity := self.state.entities[i]

      if entity.name == name {
        return entity
      }
    }

    throw error_NewError("Entity with name '" + name + "' doesn't exists")
  }

  fn _hasEntity (self: ref Self, name: str) bool {
    loop i := self.state.entities.len - 1; i >= 0; i-- {
      entity := self.state.entities[i]

      if entity.name == name {
        return true
      }
    }

    return false
  }

  fn _type (mut self: ref Self, it: ref Analyzer.Type) str {
    if it.isAlias() {
      t := it.asAlias()
      return self._type(t.t)
    } elif it.name == "any" {
      return self._("the_any_t") + " "
    } elif it.name == "bool" {
      return self._("bool") + " "
    } elif it.name == "byte" {
      return "unsigned char "
    } elif it.name == "char" {
      return "char "
    } elif it.name == "f32" {
      return "float "
    } elif it.name == "f64" || it.name == "float" {
      return "double "
    } elif it.name == "i8" {
      return self._("int8_t") + " "
    } elif it.name == "i16" {
      return self._("int16_t") + " "
    } elif it.name == "i32" || it.name == "int" {
      return self._("int32_t") + " "
    } elif it.name == "i64" {
      return self._("int64_t") + " "
    } elif it.name == "isize" {
      return self._("ptrdiff_t") + " "
    } elif it.name == "rune" {
      return self._("wchar_t") + " "
    } elif it.name == "str" {
      return self._("the_str_t") + " "
    } elif it.name == "u8" {
      return self._("uint8_t") + " "
    } elif it.name == "u16" {
      return self._("uint16_t") + " "
    } elif it.name == "u32" {
      return self._("uint32_t") + " "
    } elif it.name == "u64" {
      return self._("uint64_t") + " "
    } elif it.name == "usize" {
      return self._("size_t") + " "
    } elif it.name == "void" {
      return "void "
    } elif it.isOptional() {
      typeName := self._typeName(it)
      name := typeName + "_t"
      if !self._hasEntity(name) { self._typeOptional(it, typeName, name) }
      return self._(name) + " "
    } elif it.isReference() {
      typeName := self._typeName(it)
      name := typeName + "_t"
      if !self._hasEntity(name) { self._typeReference(it, typeName, name) }
      return self._(name) + " "
    } elif (
      it.isArray() ||
      it.isEnum() ||
      it.isFunction() ||
      it.isMap() ||
      it.isObject() ||
      it.isOptional() ||
      it.isUnion()
    ) {
      return self._(self._typeName(it) + "_t") + " "
    }

    throw error_NewError("Failed to generate type for '" + it.name + "'")
  }

  fn _typeDef (mut self: ref Self, it: ref Analyzer.Type) str {
    typeName := "TYPE_" + self._typeName(it)

    if self._hasEntity(typeName) {
      return typeName
    }

    self.state.entities.push(CodegenEntity{
      name: typeName,
      codeName: typeName,
      context: it,
      generate: (mut state: ref CodegenState, mut tm: ref Analyzer.TypeMap, entity: ref CodegenEntity) -> AST.CStatement {
        lastTypeId := ++state.lastTypeId
        return AST.createDefineDirective(entity.codeName, nil, lastTypeId.str())
      }
    })
  }

  fn _typeName (mut self: ref Self, it: ref Analyzer.Type) str {
    if it.isAlias() {
      t := it.asAlias()
      return self._typeName(t.t)
    } elif it.isArray() {
      t := it.asArray()
      return "arr_" + self._typeName(t.elementType)
    } elif it.isEnum() || it.isObject() {
      return it.name
    } elif it.isFunction() {
      t := it.asFunction()
      mut name := "fn_" + (t.asynchronous ? "a" : "s")

      loop i := 0; i < t.parameters.len; i++ {
        parameter := t.parameters[i]
        name += typeParameterId(parameter) + self._typeName(parameter.t)
      }

      return name + "FR" + self._typeName(t.returnType) + "FE"
    } elif it.isMap() {
      t := it.asMap()
      return "map_" + self._typeName(t.keyType) + "MS" + self._typeName(t.valueType) + "ME"
    } elif it.isMethod() {
      t := it.asMethod()
      mut name := "fn_" + (t.asynchronous ? "a" : "s")

      if t.withSelf {
        name += "FS" + self._typeName(t.selfType)
      }

      loop i := 0; i < t.parameters.len; i++ {
        parameter := t.parameters[i]
        name += typeParameterId(parameter) + self._typeName(parameter.t)
      }

      return name + "FR" + self._typeName(t.returnType) + "FE"
    } elif it.isOptional() {
      t := it.asOptional()
      return "opt_" + self._typeName(t.t)
    } elif it.isReference() {
      t := it.asReference()
      return "ref_" + self._typeName(t.t)
    } elif it.isUnion() {
      t := it.asUnion()
      mut name := ""

      loop i := 0; i < t.types.len; i++ {
        subType := t.types[i] as ref Analyzer.Type
        name += i == 0 ? "" : "US"
        name += self._typeName(subType)
      }

      return "union_" + name + "UE"
    }

    throw error_NewError("Failed to generate type name for '" + it.name + "'")
  }

  fn _typeOptional (mut self: ref Self, it: ref Analyzer.Type, typeName: str, name: str) {
    self.state.entities.push(CodegenEntity{
      name: name,
      codeName: name,
      context: it,
      generate: (mut state: ref CodegenState, mut tm: ref Analyzer.TypeMap, entity: ref CodegenEntity) -> AST.CStatement {
        it := entity.context as ref Analyzer.Type
        t := it.asOptional()
        return AST.createTypedefDeclaration(AST.createType(state.t(t.t) + "*"), entity.codeName)
      }
    })

    self.state.entities.push(CodegenEntity{
      name: typeName + "_alloc",
      codeName: typeName + "_alloc",
      context: it,
      generate: (mut state: ref CodegenState, mut tm: ref Analyzer.TypeMap, entity: ref CodegenEntity) -> AST.CStatement {
        it := entity.context as ref Analyzer.Type
        t := it.asOptional()
        typeName := state.typeName(it)
        name := typeName + "_t"
        underlyingCType := AST.createType(state.t(t.t))

        return AST.createFunctionDeclaration(AST.createType(state._(name)), entity.codeName, [
          AST.createFunctionParameter(underlyingCType, "n")
        ], AST.createCompoundStatement([
          AST.createVariableDeclaration(
            AST.createType(state._(name)),
            "r",
            AST.createCallExpression(AST.createIdentifier(state._("the_safe_alloc")), [
              AST.createCallExpression(AST.createIdentifier("sizeof"), [underlyingCType])
            ])
          ),
          AST.createExpressionStatement(
            AST.createAssignmentExpression(
              AST.createUnaryExpression("*", AST.createIdentifier("r")),
              "=",
              AST.createIdentifier("n")
            )
          ),
          AST.createReturnStatement(AST.createIdentifier("r"))
        ]))
      }
    })

    self.state.entities.push(CodegenEntity{
      name: typeName + "_free",
      codeName: typeName + "_free",
      context: it,
      generate: (mut state: ref CodegenState, mut tm: ref Analyzer.TypeMap, entity: ref CodegenEntity) -> AST.CStatement {
        it := entity.context as ref Analyzer.Type
        typeName := state.typeName(it)
        name := typeName + "_t"

        return AST.createFunctionDeclaration(AST.createType("void"), entity.codeName, [
          AST.createFunctionParameter(AST.createType(state._(name)), "n")
        ], AST.createCompoundStatement([
          AST.createIfStatement(
            AST.createBinaryExpression(AST.createIdentifier("n"), "==", AST.createIdentifier(state._("NULL"))),
            AST.createReturnStatement()
          ),
          // todo
          // if shouldBeFreed(underlyingTypeInfo.type) {
          //   self.functionFree(underlyingTypeInfo.type, AST.createUnaryExpression("*", CodegenASTExprAccess::create("n")))
          // }
          AST.createExpressionStatement(
            AST.createCallExpression(AST.createIdentifier(state._("the_safe_free")), [AST.createIdentifier("n")])
          )
        ]))
      }
    })
  }

  fn _typeReference (mut self: ref Self, it: ref Analyzer.Type, typeName: str, name: str) {
    self.state.entities.push(CodegenEntity{
      name: name,
      codeName: name,
      context: it,
      generate: (mut state: ref CodegenState, mut tm: ref Analyzer.TypeMap, entity: ref CodegenEntity) -> AST.CStatement {
        it := entity.context as ref Analyzer.Type
        t := it.asReference()
        return AST.createTypedefDeclaration(AST.createType(state.t(t.t) + "*"), entity.codeName)
      }
    })
  }
}

export fn defaultState () CodegenState {
  return CodegenState{
    _: (_1: str) -> str { return "" },
    block: (_1: ref Parser.Statement[]) -> AST.CStatement[] { return [] },
    defaultInitializerVariableDeclaration: (_1: ref Analyzer.Type) -> AST.CExpression { throw error_NewError("") },
    e: (_1: ref Parser.Expression) -> AST.CExpression { throw error_NewError("") },
    functionCopy: (_1: ref Analyzer.Type, _2: AST.CExpression) -> AST.CExpression { throw error_NewError("") },
    functionEq: (_1: ref Analyzer.Type, _2: AST.CExpression, _3: AST.CExpression) -> AST.CExpression { throw error_NewError("") },
    functionFree: (_1: ref Analyzer.Type, _2: AST.CExpression) -> AST.CExpression { throw error_NewError("") },
    functionNe: (_1: ref Analyzer.Type, _2: AST.CExpression, _3: AST.CExpression) -> AST.CExpression { throw error_NewError("") },
    functionRealloc: (_1: ref Analyzer.Type, _2: AST.CExpression, _3: AST.CExpression) -> AST.CExpression { throw error_NewError("") },
    functionStr: (_1: ref Analyzer.Type, _2: AST.CExpression) -> AST.CExpression { throw error_NewError("") },
    get: (_1: str) -> ref CodegenEntity { throw error_NewError("") },
    has: (_1: str) -> bool { return false },
    t: (_1: ref Analyzer.Type) -> str { return "" },
    typeDef: (_1: ref Analyzer.Type) -> str { return "" },
    typeName: (_1: ref Analyzer.Type) -> str { return "" },
  }
}

export fn compile (analyzer: ref Analyzer.Analyzer, executablePath: str) {
  mut generator := Codegen{analyzer: analyzer, state: defaultState()}
  generator.init()
  generator.generate()

  codePath := executablePath + ".c"

  fs_writeFileSync(codePath, generator.stringify().toBuffer())
  process_runSync("clang '" + codePath + "' -o '" + executablePath + "' " + generator.getFlags())
  fs_rmSync(codePath)
}
