/*!
* Copyright (c) Aaron Delasy
* Licensed under the MIT License
*/

import * as AST from "the/c"
import * as Parser from "the/parser"
import ExpressionHelpers from "./expression-helpers"

export fn generateLiteral (helpers: ExpressionHelpers, item: ref Parser.Expression) AST.CExpression? {
  if item.isBooleanLiteral() {
    expression := item.asBooleanLiteral()
    return AST.createLiteral(helpers._(expression.value))
  } elif item.isCharacterLiteral() {
    expression := item.asCharacterLiteral()
    return AST.createLiteral("L'" + expression.value + "'")
  } elif item.isFloatingPointLiteral() {
    expression := item.asFloatingPointLiteral()
    return AST.createLiteral(expression.value)
  } elif item.isIntegerLiteral() {
    expression := item.asIntegerLiteral()
    rawValue := expression.value.replace("O", "").replace("o", "")
    return AST.createLiteral(rawValue)
  } elif item.isNilLiteral() {
    expression := item.asNilLiteral()
    return AST.createLiteral(helpers._("NULL"))
  } elif item.isStringLiteral() {
    expression := item.asStringLiteral()
    sanitizedValue := expression.value
      .replace(os_EOL, "\" " + helpers._("THE_EOL") + " \"")
      .replace("\n", "\" " + helpers._("THE_EOL") + " \"")
    rawValue := "L\"" + sanitizedValue + "\""

    if !item.hasParent() && item.hasParentNode() {
      node := item.parentNode()

      if node.isVariableDeclaration() {
        return AST.createCallExpression(
          AST.createIdentifier(helpers._("the_str_alloc")),
          [AST.createLiteral(rawValue)]
        )
      }
    }

    return AST.createLiteral(rawValue)
  }

  return nil
}
