/*!
 * Copyright (c) Aaron Delasy
 * Licensed under the MIT License
 */

type TokenizerWrapIntChecker = (char) -> bool

const ignoredTokenTypes: TokenType[] = [
  .CommentBlock,
  .CommentLine,
  .Whitespace
]

obj TokenizerState {
  mut idx: int
  mut pos: int
  mut ch: char
  mut handled: bool
}

obj Tokenizer {
  mut reader: ref Reader
  mut state: TokenizerState
  mut data: Token[]
  mut errors: str[]

  fn next (mut self: ref Self, withIgnored := false) Token {
    if self.data.len < self.state.idx {
      return self.data[self.state.idx++]
    } elif !self.data.empty() && self.data[-1].t == .Eof {
      RaiseError("Tried to tokenize on eof")
    }

    loop {
      tok := self._getToken()

      self.data.push(tok)
      self.state.idx++

      if withIgnored || ignoredTokenTypes.contains(tok.t) {
        return tok
      }
    }
  }

  fn _getToken (mut self: ref Self) Token {
    if self.reader.eof() {
      return Token{
        t: .Eof,
        val: "",
        start: self.state.pos,
        end: self.state.pos
      }
    }

    self.state.ch = self.reader.next()
    self.state.handled = false
    mut tok: Token?

    if (tok = self._maybeWhitespace()) != nil {
      return tok
    } elif (tok = self._maybeCommentBlock()) != nil {
      return tok
    } elif (tok = self._maybeCommentLine()) != nil {
      return tok
    } elif (tok = self._maybeOp()) != nil {
      return tok
    } elif (tok = self._maybeKeyword()) != nil {
      return tok
    } elif (tok = self._maybeNumber()) != nil {
      return tok
    } elif (tok = self._maybeString()) != nil {
      return tok
    } elif (tok = self._maybeChar()) != nil {
      return tok
    } else {
      self._raise(E0000(self.state.ch), self.state.pos)
      return self._wrapToken(.Unknown)
    }
  }

  fn _maybeChar (mut self: ref Self) Token? {
    if self.state.ch != '\'' {
      return nil
    }

    if self.reader.eof() {
      self._raise(E0002(), self.state.pos)
      return self._wrapToken(.LitChar)
    }

    ch1 := self.reader.next()

    if ch1 == '\n' {
      self._raise(E0002(), self.state.pos)
      return self._wrapToken(.LitChar)
    } elif ch1 == '\'' {
      self._raise(E0004(), self.state.pos)
      return self._wrapToken(.LitChar)
    } elif ch1 == '\\' {
      if self.reader.eof() {
        self._raise(E0002(), self.state.pos)
        return self._wrapToken(.LitChar)
      }

      ch2 := self.reader.next()

      if !Token_isCharEsc(ch2) {
        self._raise(E0005(), self.state.pos)
      }
    }

    if !self.reader.lookahead('\'') {
      loop {
        if self.reader.eof() {
          self._raise(E0002(), self.state.pos)
          break
        }

        pos3 := self.reader.pos
        ch3 := self.reader.next()

        if ch3 == '\'' {
          self._raise(E0007(), self.state.pos)
          break
        } elif ch3 == '\n' {
          self.reader.seek(pos3)
          self._raise(E0002(), self.state.pos)
          break
        }
      }
    }

    return self._wrapToken(.LitChar)
  }

  fn _maybeCommentBlock (mut self: ref Self) Token? {
    if self.state.ch != '/' || !self.reader.lookahead('*') {
      return nil
    }

    loop {
      if self.reader.eof() {
        self._raise(E0001(), self.state.pos)
        break
      }

      ch := self.reader.next()

      if ch == '*' && self.reader.lookahead('/') {
        break
      }
    }

    return self._wrapToken(.CommentBlock)
  }

  fn _maybeCommentLine (mut self: ref Self) Token? {
    if self.state.ch != '/' || !self.reader.lookahead('/') {
      return nil
    }

    self.reader.walk(Token_isNotNewLine)
    return self._wrapToken(.CommentLine)
  }

  fn _maybeKeyword (mut self: ref Self) Token? {
    if !Token_isIdStart(self.state.ch) {
      return nil
    }

    self.reader.walk(Token_isId)
    val := self.reader.slice(self.state.pos, self.reader.pos)

    if val == "async" {
      return self._wrapToken(.KwAsync)
    } elif val == "await" {
      return self._wrapToken(.KwAwait)
    } elif val == "break" {
      return self._wrapToken(.KwBreak)
    } elif val == "catch" {
      return self._wrapToken(.KwCatch)
    } elif val == "continue" {
      return self._wrapToken(.KwContinue)
    } elif val == "elif" {
      return self._wrapToken(.KwElif)
    } elif val == "else" {
      return self._wrapToken(.KwElse)
    } elif val == "enum" {
      return self._wrapToken(.KwEnum)
    } elif val == "export" {
      return self._wrapToken(.KwExport)
    } elif val == "false" {
      return self._wrapToken(.KwFalse)
    } elif val == "fn" {
      return self._wrapToken(.KwFn)
    } elif val == "from" {
      return self._wrapToken(.KwFrom)
    } elif val == "if" {
      return self._wrapToken(.KwIf)
    } elif val == "import" {
      return self._wrapToken(.KwImport)
    } elif val == "is" {
      return self._wrapToken(.KwIs)
    } elif val == "loop" {
      return self._wrapToken(.KwLoop)
    } elif val == "main" {
      return self._wrapToken(.KwMain)
    } elif val == "mut" {
      return self._wrapToken(.KwMut)
    } elif val == "nil" {
      return self._wrapToken(.KwNil)
    } elif val == "obj" {
      return self._wrapToken(.KwObj)
    } elif val == "ref" {
      return self._wrapToken(.KwRef)
    } elif val == "return" {
      return self._wrapToken(.KwReturn)
    } elif val == "throw" {
      return self._wrapToken(.KwThrow)
    } elif val == "true" {
      return self._wrapToken(.KwTrue)
    } elif val == "try" {
      return self._wrapToken(.KwTry)
    } elif val == "type" {
      return self._wrapToken(.KwType)
    }

    return self._wrapToken(.Id)
  }

  fn _maybeNumber (mut self: ref Self) Token? {
    if !self.state.ch.isDigit() {
      return nil
    }

    if self.state.ch == '0' {
      if self.reader.eof() {
        return self._wrapToken(.LitIntDec)
      }

      pos := self.reader.pos
      ch := self.reader.next()

      if Token_isIntDec(ch) {
        self.reader.walk(Token_isId)
        self._raise(E0008(), self.state.pos)

        return self._wrapToken(.LitIntDec)
      } elif ch == 'B' || ch == 'b' {
        return self._wrapInt(.LitIntBin, E0009("binary"), Token_isIntBin)
      } elif ch == 'X' || ch == 'x' {
        return self._wrapInt(.LitIntHex, E0009("hexadecimal"), Token_isIntHex)
      } elif ch == 'O' || ch == 'o' {
        return self._wrapInt(.LitIntOct, E0009("octal"), Token_isIntOct)
      }

      self.reader.seek(pos)
    } else {
      self.reader.walk(Token_isIntDec)
    }

    return self._wrapInt(.LitIntDec, E0009("decimal"), Token_isIntDec)
  }

  fn _maybeOp (mut self: ref Self) Token? {
    if self.state.ch == '&' {
      if self.reader.lookahead('&') {
        if self.reader.lookahead('=') {
          return self._wrapToken(.OpAmpAmpEq)
        } else {
          return self._wrapToken(.OpAmpAmp)
        }
      } elif self.reader.lookahead('=') {
        return self._wrapToken(.OpAmpEq)
      } else {
        return self._wrapToken(.OpAmp)
      }
    } elif self.state.ch == '@' {
      return self._wrapToken(.OpAt)
    } elif self.state.ch == '`' {
      return self._wrapToken(.OpBacktick)
    } elif self.state.ch == '\\' {
      return self._wrapToken(.OpBackslash)
    } elif self.state.ch == '^' {
      if self.reader.lookahead('=') {
        return self._wrapToken(.OpCaretEq)
      } else {
        return self._wrapToken(.OpCaret)
      }
    } elif self.state.ch == ':' {
      if self.reader.lookahead('=') {
        return self._wrapToken(.OpColonEq)
      } else {
        return self._wrapToken(.OpColon)
      }
    } elif self.state.ch == ',' {
      return self._wrapToken(.OpComma)
    } elif self.state.ch == '.' {
      pos := self.reader.pos

      if self.reader.lookahead('.') && self.reader.lookahead('.') {
        return self._wrapToken(.OpEllipsis)
      }

      self.reader.seek(pos)
      return self._wrapToken(.OpDot)
    } elif self.state.ch == '$' {
      return self._wrapToken(.OpDollar)
    } elif self.state.ch == '=' {
      if self.reader.lookahead('=') {
        return self._wrapToken(.OpEqEq)
      } else {
        return self._wrapToken(.OpEq)
      }
    } elif self.state.ch == '!' {
      if self.reader.lookahead('=') {
        return self._wrapToken(.OpExclEq)
      } else {
        return self._wrapToken(.OpExcl)
      }
    } elif self.state.ch == '>' {
      if self.reader.lookahead('>') {
        if self.reader.lookahead('=') {
          return self._wrapToken(.OpRShiftEq)
        } else {
          return self._wrapToken(.OpRShift)
        }
      } elif self.reader.lookahead('=') {
        return self._wrapToken(.OpGtEq)
      } else {
        return self._wrapToken(.OpGt)
      }
    } elif self.state.ch == '#' {
      return self._wrapToken(.OpHash)
    } elif self.state.ch == '{' {
      return self._wrapToken(.OpLBrace)
    } elif self.state.ch == '[' {
      return self._wrapToken(.OpLBrack)
    } elif self.state.ch == '(' {
      return self._wrapToken(.OpLPar)
    } elif self.state.ch == '<' {
      if self.reader.lookahead('<') {
        if self.reader.lookahead('=') {
          return self._wrapToken(.OpLShiftEq)
        } else {
          return self._wrapToken(.OpLShift)
        }
      } elif self.reader.lookahead('=') {
        return self._wrapToken(.OpLtEq)
      } else {
        return self._wrapToken(.OpLt)
      }
    } elif self.state.ch == '-' {
      if self.reader.lookahead('-') {
        return self._wrapToken(.OpMinusMinus)
      } elif self.reader.lookahead('=') {
        return self._wrapToken(.OpMinusEq)
      } elif self.reader.lookahead('>') {
        return self._wrapToken(.OpArrow)
      } else {
        return self._wrapToken(.OpMinus)
      }
    } elif self.state.ch == '|' {
      if self.reader.lookahead('|') {
        if self.reader.lookahead('=') {
          return self._wrapToken(.OpPipePipeEq)
        } else {
          return self._wrapToken(.OpPipePipe)
        }
      } elif self.reader.lookahead('=') {
        return self._wrapToken(.OpPipeEq)
      } else {
        return self._wrapToken(.OpPipe)
      }
    } elif self.state.ch == '%' {
      if self.reader.lookahead('=') {
        return self._wrapToken(.OpPercentEq)
      } else {
        return self._wrapToken(.OpPercent)
      }
    } elif self.state.ch == '+' {
      if self.reader.lookahead('+') {
        return self._wrapToken(.OpPlusPlus)
      } elif self.reader.lookahead('=') {
        return self._wrapToken(.OpPlusEq)
      } else {
        return self._wrapToken(.OpPlus)
      }
    } elif self.state.ch == '?' {
      return self._wrapToken(.OpQn)
    } elif self.state.ch == '}' {
      return self._wrapToken(.OpRBrace)
    } elif self.state.ch == ']' {
      return self._wrapToken(.OpRBrack)
    } elif self.state.ch == ')' {
      return self._wrapToken(.OpRPar)
    } elif self.state.ch == ';' {
      return self._wrapToken(.OpSemi)
    } elif self.state.ch == '/' {
      if self.reader.lookahead('=') {
        return self._wrapToken(.OpSlashEq)
      } else {
        return self._wrapToken(.OpSlash)
      }
    } elif self.state.ch == '*' {
      if self.reader.lookahead('=') {
        return self._wrapToken(.OpStarEq)
      } else {
        return self._wrapToken(.OpStar)
      }
    } elif self.state.ch == '~' {
      return self._wrapToken(.OpTilde)
    }

    return nil
  }

  fn _maybeString (mut self: ref Self) Token? {
    if self.state.ch != '"' {
      return nil
    }

    loop {
      if self.reader.eof() {
        self._raise(E0003(), self.state.pos)
        break
      }

      pos1 := self.reader.pos
      ch1 := self.reader.next()

      if ch1 == '"' {
        break
      } elif ch1 == '\\' {
        ch2 := self.reader.next()

        if !Token_isStrEsc(ch2) {
          self._raise(E0006(), pos1)
        }
      }
    }

    return self._wrapToken(.LitStr)
  }

  fn _maybeWhitespace (mut self: ref Self) Token? {
    if !self.state.ch.isSpace() {
      return nil
    }

    self.reader.walk(Token_isWhitespace)
    return self._wrapToken(.Whitespace)
  }

  fn _raise (mut self: ref Self, message: str, start: int) {
    if self.state.handled {
      return
    }

    startLoc := Location_locate(self.reader.content, start)
    endLoc := Location_locate(self.reader.content, self.reader.pos)
    lines := self.reader.content.lines()

    mut errorLines: str[]
    mut errorLinesNums: int[]

    if startLoc.line != 1 {
      errorLines.push(lines[startLoc.line - 2])
      errorLinesNums.push(startLoc.line - 1)
    }

    errorLines.push(lines[startLoc.line - 1])
    errorLinesNums.push(startLoc.line)

    if startLoc.line == endLoc.line && startLoc.col == endLoc.col {
      mut x: u32 = startLoc.col - 1
      errorLines.push(' '.repeat(x) + "^")
    } elif startLoc.line == endLoc.line {
      mut x1: u32 = startLoc.col - 1
      mut x2: u32 = endLoc.col - startLoc.col
      errorLines.push(' '.repeat(x1) + '~'.repeat(x2))
    } else {
      errorLine := lines[startLoc.line - 1]
      mut x1: u32 = startLoc.col - 1
      mut x2: u32 = errorLine.len - startLoc.col
      errorLines.push(' '.repeat(x1) + '~'.repeat(x2))
    }

    errorLinesNums.push(startLoc.line)

    if startLoc.line != lines.len && !lines[startLoc.line].empty() {
      errorLines.push(lines[startLoc.line])
      errorLinesNums.push(startLoc.line + 1)
    }

    gutterLen := errorLinesNums[-1].str().len + 1

    mut error := self.reader.path + ":" + startLoc.line.str() + ":" +
      startLoc.col.str() + ": SyntaxError: " + message + os_EOL

    mut prevLineNum := 0

    loop i := 0; i < errorLinesNums.len; i++ {
      errorLineNum := errorLinesNums[i]

      if prevLineNum == errorLineNum {
        mut x: u32 = gutterLen
        error += ' '.repeat(x)
      } else {
        errorLineNumLen := errorLineNum.str().len
        mut x: u32 = gutterLen - errorLineNumLen
        error += errorLineNum.str() + ' '.repeat(x)
      }

      error += "| " + errorLines[i] + os_EOL
      prevLineNum = errorLineNum
    }

    self.errors.push(error)
    self.state.handled = true
  }

  fn _wrapFloat (mut self: ref Self, t: int, errorMessage: str) Token {
    if self.reader.eof() {
      return self._wrapToken(t)
    }

    pos1 := self.reader.pos
    ch1 := self.reader.next()

    if Token_isId(ch1) && ch1 != 'E' && ch1 != 'e' {
      self.reader.walk(Token_isId)
      self._raise(errorMessage, self.state.pos)

      return self._wrapToken(t)
    } elif ch1 != '.' && ch1 != 'E' && ch1 != 'e' {
      self.reader.seek(pos1)
      return self._wrapToken(t)
    }

    mut expStartPos := pos1

    if ch1 == '.' {
      if self.reader.eof() {
        self._raise(E0010(), self.state.pos)
        return self._wrapToken(.LitFloat)
      }

      pos2 := self.reader.pos
      ch2 := self.reader.next()

      if ch2 == '.' {
        self.reader.seek(pos1)
        return self._wrapToken(t)
      } elif !Token_isIntDec(ch2) {
        self.reader.walk(Token_isId)
        self._raise(E0010(), self.state.pos)

        return self._wrapToken(.LitFloat)
      }

      self.reader.walk(Token_isIntDec)

      if self.reader.eof() {
        return self._wrapTokenFloat(t)
      }

      pos3 := self.reader.pos
      ch3 := self.reader.next()

      if Token_isId(ch3) && ch3 != 'E' && ch3 != 'e' {
        self.reader.walk(Token_isId)
        self._raise(E0010(), self.state.pos)

        return self._wrapToken(.LitFloat)
      } elif ch3 != 'E' && ch3 != 'e' {
        self.reader.seek(pos3)
        return self._wrapTokenFloat(t)
      }

      expStartPos = pos3
    }

    if self.reader.eof() {
      self._raise(E0011(), expStartPos)
      return self._wrapToken(.LitFloat)
    }

    ch4 := self.reader.next()

    if !Token_isIntDec(ch4) && ch4 != '+' && ch4 != '-' {
      self.reader.walk(Token_isId)
      self._raise(E0011(), expStartPos)

      return self._wrapToken(.LitFloat)
    }

    if ch4 == '+' || ch4 == '-' {
      if self.reader.eof() {
        self._raise(E0011(), expStartPos)
        return self._wrapToken(.LitFloat)
      }

      ch5 := self.reader.next()

      if !Token_isIntDec(ch5) {
        self.reader.walk(Token_isId)
        self._raise(E0011(), expStartPos)

        return self._wrapToken(.LitFloat)
      }
    }

    self.reader.walk(Token_isIntDec)
    return self._wrapTokenFloat(t)
  }

  fn _wrapInt (
    mut self: ref Self,
    t: int,
    errorMessage: str,
    check: TokenizerWrapIntChecker
  ) Token {
    if t != .LitIntDec {
      if self.reader.eof() {
        self._raise(errorMessage, self.state.pos)
        return self._wrapToken(t)
      }

      ch := self.reader.next()

      if t != .LitIntDec && !check(ch) {
        self.reader.walk(Token_isId)
        self._raise(errorMessage, self.state.pos)

        return self._wrapToken(t)
      }

      self.reader.walk(check)
    }

    return self._wrapFloat(t, errorMessage)
  }

  fn _wrapToken (mut self: ref Self, t: int) Token {
    start := self.state.pos
    self.state.pos = self.reader.pos
    self.state.handled = true

    return Token{
      t: t,
      val: self.reader.slice(start, self.state.pos),
      start: start,
      end: self.state.pos
    }
  }

  fn _wrapTokenFloat (mut self: ref Self, t: int) Token {
    if !self.reader.eof() {
      pos := self.reader.pos
      ch := self.reader.next()

      if Token_isId(ch) {
        self.reader.walk(Token_isId)
        self._raise(E0010(), self.state.pos)

        return self._wrapToken(.LitFloat)
      }

      self.reader.seek(pos)
    }

    if t == .LitIntBin {
      self._raise(E0012("binary"), self.state.pos)
    } elif t == .LitIntHex {
      self._raise(E0012("hexadecimal"), self.state.pos)
    } elif t == .LitIntOct {
      self._raise(E0012("octal"), self.state.pos)
    }

    return self._wrapToken(.LitFloat)
  }
}

fn Tokenizer_init (mut reader: ref Reader) Tokenizer {
  return Tokenizer{
    reader: reader,
    state: TokenizerState{
      idx: 0,
      pos: 0,
      ch: '\0',
      handled: false
    },
    data: [],
    errors: []
  }
}
