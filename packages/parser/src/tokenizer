/*!
 * Copyright (c) Aaron Delasy
 * Licensed under the MIT License
 */

import Reader, Reader_locate from "./reader"
import
  Token,
  Token_isCharEsc,
  Token_isId,
  Token_isIdStart,
  Token_isIntBin,
  Token_isIntDec,
  Token_isIntHex,
  Token_isIntOct,
  Token_isNotNewLine,
  Token_isStrEsc,
  Token_isWhitespace
from "./token"
import TokenType, TokenizerState from "./types"
import * as errors from "./errors"

export obj Tokenizer {
  mut reader: ref Reader
  mut state: TokenizerState
  mut data: Token[]
  mut errors: str[]

  fn next (mut self: ref Self, withIgnored := false) Token {
    if self.data.len < self.state.idx {
      return self.data[self.state.idx++]
    } elif !self.data.empty && self.data[-1].t == .Eof {
      throw error_NewError("Tried next on Tokenizer eof")
    }

    loop {
      tok := self._getToken()

      self.data.push(tok)
      self.state.idx++

      if tok.t != .Whitespace {
        return tok
      }
    }
  }

  fn _getToken (mut self: ref Self) Token {
    if self.reader.eof() {
      return Token{
        t: .Eof,
        val: "",
        start: self.state.pos,
        end: self.state.pos
      }
    }

    self.state.ch = self.reader.next()
    self.state.handled = false
    mut tok: Token?

    if (tok = self._maybeWhitespace()) != nil {
      return tok
    } elif (tok = self._maybeCommentBlock()) != nil {
      return tok
    } elif (tok = self._maybeCommentLine()) != nil {
      return tok
    } elif (tok = self._maybeOp()) != nil {
      return tok
    } elif (tok = self._maybeKeyword()) != nil {
      return tok
    } elif (tok = self._maybeNumber()) != nil {
      return tok
    } elif (tok = self._maybeString()) != nil {
      return tok
    } elif (tok = self._maybeChar()) != nil {
      return tok
    } else {
      self._raise(errors.E0000(self.state.ch), self.state.pos)
      return self._wrapToken(.Unknown)
    }
  }

  fn _maybeChar (mut self: ref Self) Token? {
    if self.state.ch != '\'' {
      return nil
    }

    if self.reader.eof() {
      self._raise(errors.E0002(), self.state.pos)
      return self._wrapToken(.LitChar)
    }

    ch1 := self.reader.next()

    if ch1 == '\n' {
      self._raise(errors.E0002(), self.state.pos)
      return self._wrapToken(.LitChar)
    } elif ch1 == '\'' {
      self._raise(errors.E0004(), self.state.pos)
      return self._wrapToken(.LitChar)
    } elif ch1 == '\\' {
      if self.reader.eof() {
        self._raise(errors.E0002(), self.state.pos)
        return self._wrapToken(.LitChar)
      }

      ch2 := self.reader.next()

      if !Token_isCharEsc(ch2) {
        self._raise(errors.E0005(), self.state.pos)
      }
    }

    if !self.reader.lookahead('\'') {
      loop {
        if self.reader.eof() {
          self._raise(errors.E0002(), self.state.pos)
          break
        }

        pos3 := self.reader.pos
        ch3 := self.reader.next()

        if ch3 == '\'' {
          self._raise(errors.E0007(), self.state.pos)
          break
        } elif ch3 == '\n' {
          self.reader.seek(pos3)
          self._raise(errors.E0002(), self.state.pos)
          break
        }
      }
    }

    return self._wrapToken(.LitChar)
  }

  fn _maybeCommentBlock (mut self: ref Self) Token? {
    if self.state.ch != '/' || !self.reader.lookahead('*') {
      return nil
    }

    loop {
      if self.reader.eof() {
        self._raise(errors.E0001(), self.state.pos)
        break
      }

      ch := self.reader.next()

      if ch == '*' && self.reader.lookahead('/') {
        break
      }
    }

    return self._wrapToken(.CommentBlock)
  }

  fn _maybeCommentLine (mut self: ref Self) Token? {
    if self.state.ch != '/' || !self.reader.lookahead('/') {
      return nil
    }

    self.reader.walk(Token_isNotNewLine)
    return self._wrapToken(.CommentLine)
  }

  fn _maybeKeyword (mut self: ref Self) Token? {
    if !Token_isIdStart(self.state.ch) {
      return nil
    }

    self.reader.walk(Token_isId)
    val := self.reader.slice(self.state.pos, self.reader.pos)

    if val == "as" { return self._wrapToken(.KwAs) }
    if val == "async" { return self._wrapToken(.KwAsync) }
    if val == "await" { return self._wrapToken(.KwAwait) }
    if val == "break" { return self._wrapToken(.KwBreak) }
    if val == "catch" { return self._wrapToken(.KwCatch) }
    if val == "const" { return self._wrapToken(.KwConst) }
    if val == "continue" { return self._wrapToken(.KwContinue) }
    if val == "elif" { return self._wrapToken(.KwElif) }
    if val == "else" { return self._wrapToken(.KwElse) }
    if val == "enum" { return self._wrapToken(.KwEnum) }
    if val == "export" { return self._wrapToken(.KwExport) }
    if val == "false" { return self._wrapToken(.KwFalse) }
    if val == "fn" { return self._wrapToken(.KwFn) }
    if val == "from" { return self._wrapToken(.KwFrom) }
    if val == "if" { return self._wrapToken(.KwIf) }
    if val == "import" { return self._wrapToken(.KwImport) }
    if val == "is" { return self._wrapToken(.KwIs) }
    if val == "loop" { return self._wrapToken(.KwLoop) }
    if val == "main" { return self._wrapToken(.KwMain) }
    if val == "mut" { return self._wrapToken(.KwMut) }
    if val == "nil" { return self._wrapToken(.KwNil) }
    if val == "obj" { return self._wrapToken(.KwObj) }
    if val == "ref" { return self._wrapToken(.KwRef) }
    if val == "return" { return self._wrapToken(.KwReturn) }
    if val == "throw" { return self._wrapToken(.KwThrow) }
    if val == "true" { return self._wrapToken(.KwTrue) }
    if val == "try" { return self._wrapToken(.KwTry) }
    if val == "type" { return self._wrapToken(.KwType) }

    return self._wrapToken(.Id)
  }

  fn _maybeNumber (mut self: ref Self) Token? {
    if !self.state.ch.isDigit {
      return nil
    }

    if self.state.ch == '0' {
      if self.reader.eof() {
        return self._wrapToken(.LitIntDec)
      }

      pos := self.reader.pos
      ch := self.reader.next()

      if Token_isIntDec(ch) {
        self.reader.walk(Token_isId)
        self._raise(errors.E0008(), self.state.pos)

        return self._wrapToken(.LitIntDec)
      } elif ch == 'B' || ch == 'b' {
        return self._wrapInt(.LitIntBin, errors.E0009("binary"), Token_isIntBin)
      } elif ch == 'X' || ch == 'x' {
        return self._wrapInt(.LitIntHex, errors.E0009("hexadecimal"), Token_isIntHex)
      } elif ch == 'O' || ch == 'o' {
        return self._wrapInt(.LitIntOct, errors.E0009("octal"), Token_isIntOct)
      }

      self.reader.seek(pos)
    } else {
      self.reader.walk(Token_isIntDec)
    }

    return self._wrapInt(.LitIntDec, errors.E0009("decimal"), Token_isIntDec)
  }

  fn _maybeOp (mut self: ref Self) Token? {
    if self.state.ch == '&' {
      if self.reader.lookahead('&') {
        if self.reader.lookahead('=') {
          return self._wrapToken(.OpAmpAmpEq)
        } else {
          return self._wrapToken(.OpAmpAmp)
        }
      } elif self.reader.lookahead('=') {
        return self._wrapToken(.OpAmpEq)
      } else {
        return self._wrapToken(.OpAmp)
      }
    } elif self.state.ch == '@' {
      return self._wrapToken(.OpAt)
    } elif self.state.ch == '`' {
      return self._wrapToken(.OpBacktick)
    } elif self.state.ch == '\\' {
      return self._wrapToken(.OpBackslash)
    } elif self.state.ch == '^' {
      if self.reader.lookahead('=') {
        return self._wrapToken(.OpCaretEq)
      } else {
        return self._wrapToken(.OpCaret)
      }
    } elif self.state.ch == ':' {
      if self.reader.lookahead('=') {
        return self._wrapToken(.OpColonEq)
      } else {
        return self._wrapToken(.OpColon)
      }
    } elif self.state.ch == ',' {
      return self._wrapToken(.OpComma)
    } elif self.state.ch == '.' {
      pos := self.reader.pos

      if self.reader.lookahead('.') && self.reader.lookahead('.') {
        return self._wrapToken(.OpEllipsis)
      }

      self.reader.seek(pos)
      return self._wrapToken(.OpDot)
    } elif self.state.ch == '$' {
      return self._wrapToken(.OpDollar)
    } elif self.state.ch == '=' {
      if self.reader.lookahead('=') {
        return self._wrapToken(.OpEqEq)
      } else {
        return self._wrapToken(.OpEq)
      }
    } elif self.state.ch == '!' {
      if self.reader.lookahead('=') {
        return self._wrapToken(.OpExclEq)
      } else {
        return self._wrapToken(.OpExcl)
      }
    } elif self.state.ch == '>' {
      if self.reader.lookahead('>') {
        if self.reader.lookahead('=') {
          return self._wrapToken(.OpRShiftEq)
        } else {
          return self._wrapToken(.OpRShift)
        }
      } elif self.reader.lookahead('=') {
        return self._wrapToken(.OpGtEq)
      } else {
        return self._wrapToken(.OpGt)
      }
    } elif self.state.ch == '#' {
      return self._wrapToken(.OpHash)
    } elif self.state.ch == '{' {
      return self._wrapToken(.OpLBrace)
    } elif self.state.ch == '[' {
      return self._wrapToken(.OpLBrack)
    } elif self.state.ch == '(' {
      return self._wrapToken(.OpLPar)
    } elif self.state.ch == '<' {
      if self.reader.lookahead('<') {
        if self.reader.lookahead('=') {
          return self._wrapToken(.OpLShiftEq)
        } else {
          return self._wrapToken(.OpLShift)
        }
      } elif self.reader.lookahead('=') {
        return self._wrapToken(.OpLtEq)
      } else {
        return self._wrapToken(.OpLt)
      }
    } elif self.state.ch == '-' {
      if self.reader.lookahead('-') {
        return self._wrapToken(.OpMinusMinus)
      } elif self.reader.lookahead('=') {
        return self._wrapToken(.OpMinusEq)
      } elif self.reader.lookahead('>') {
        return self._wrapToken(.OpArrow)
      } else {
        return self._wrapToken(.OpMinus)
      }
    } elif self.state.ch == '|' {
      if self.reader.lookahead('|') {
        if self.reader.lookahead('=') {
          return self._wrapToken(.OpPipePipeEq)
        } else {
          return self._wrapToken(.OpPipePipe)
        }
      } elif self.reader.lookahead('=') {
        return self._wrapToken(.OpPipeEq)
      } else {
        return self._wrapToken(.OpPipe)
      }
    } elif self.state.ch == '%' {
      if self.reader.lookahead('=') {
        return self._wrapToken(.OpPercentEq)
      } else {
        return self._wrapToken(.OpPercent)
      }
    } elif self.state.ch == '+' {
      if self.reader.lookahead('+') {
        return self._wrapToken(.OpPlusPlus)
      } elif self.reader.lookahead('=') {
        return self._wrapToken(.OpPlusEq)
      } else {
        return self._wrapToken(.OpPlus)
      }
    } elif self.state.ch == '?' {
      return self._wrapToken(.OpQn)
    } elif self.state.ch == '}' {
      return self._wrapToken(.OpRBrace)
    } elif self.state.ch == ']' {
      return self._wrapToken(.OpRBrack)
    } elif self.state.ch == ')' {
      return self._wrapToken(.OpRPar)
    } elif self.state.ch == ';' {
      return self._wrapToken(.OpSemi)
    } elif self.state.ch == '/' {
      if self.reader.lookahead('=') {
        return self._wrapToken(.OpSlashEq)
      } else {
        return self._wrapToken(.OpSlash)
      }
    } elif self.state.ch == '*' {
      if self.reader.lookahead('=') {
        return self._wrapToken(.OpStarEq)
      } else {
        return self._wrapToken(.OpStar)
      }
    } elif self.state.ch == '~' {
      return self._wrapToken(.OpTilde)
    }

    return nil
  }

  fn _maybeString (mut self: ref Self) Token? {
    if self.state.ch != '"' {
      return nil
    }

    loop {
      if self.reader.eof() {
        self._raise(errors.E0003(), self.state.pos)
        break
      }

      pos1 := self.reader.pos
      ch1 := self.reader.next()

      if ch1 == '"' {
        break
      } elif ch1 == '\\' {
        ch2 := self.reader.next()

        if !Token_isStrEsc(ch2) {
          self._raise(errors.E0006(), pos1)
        }
      }
    }

    return self._wrapToken(.LitStr)
  }

  fn _maybeWhitespace (mut self: ref Self) Token? {
    if !self.state.ch.isWhitespace {
      return nil
    }

    self.reader.walk(Token_isWhitespace)
    return self._wrapToken(.Whitespace)
  }

  fn _raise (mut self: ref Self, message: str, start: int) {
    if self.state.handled {
      return
    }

    startLoc := Reader_locate(self.reader, start)
    endLoc := Reader_locate(self.reader, self.reader.pos)
    lines := self.reader.content.lines()

    mut errorLines: str[]
    mut errorLinesNums: int[]

    if startLoc.line != 1 {
      errorLines.push(lines[startLoc.line - 2])
      errorLinesNums.push(startLoc.line - 1)
    }

    errorLines.push(lines[startLoc.line - 1])
    errorLinesNums.push(startLoc.line)

    if startLoc.line == endLoc.line && startLoc.col == endLoc.col {
      errorLines.push(' '.repeat(startLoc.col - 1) + "^")
    } elif startLoc.line == endLoc.line {
      errorLines.push(' '.repeat(startLoc.col - 1) + '~'.repeat(endLoc.col - startLoc.col))
    } else {
      errorLine := lines[startLoc.line - 1]
      errorLines.push(' '.repeat(startLoc.col - 1) + '~'.repeat(errorLine.len - startLoc.col))
    }

    errorLinesNums.push(startLoc.line)

    if startLoc.line != lines.len && !lines[startLoc.line].empty {
      errorLines.push(lines[startLoc.line])
      errorLinesNums.push(startLoc.line + 1)
    }

    gutterLen := errorLinesNums[-1].str().len + 1

    mut error := self.reader.path + ":" + startLoc.line.str() + ":" +
      startLoc.col.str() + ": SyntaxError: " + message + os_EOL

    mut prevLineNum := 0

    loop i := 0; i < errorLinesNums.len; i++ {
      errorLineNum := errorLinesNums[i]

      if prevLineNum == errorLineNum {
        error += ' '.repeat(gutterLen)
      } else {
        errorLineNumLen := errorLineNum.str().len
        error += errorLineNum.str() + ' '.repeat(gutterLen - errorLineNumLen)
      }

      error += "| " + errorLines[i] + os_EOL
      prevLineNum = errorLineNum
    }

    self.errors.push(error)
    self.state.handled = true
  }

  fn _wrapFloat (mut self: ref Self, t: TokenType, errorMessage: str) Token {
    if self.reader.eof() {
      return self._wrapToken(t)
    }

    pos1 := self.reader.pos
    ch1 := self.reader.next()

    if Token_isId(ch1) && ch1 != 'E' && ch1 != 'e' {
      self.reader.walk(Token_isId)
      self._raise(errorMessage, self.state.pos)

      return self._wrapToken(t)
    } elif ch1 != '.' && ch1 != 'E' && ch1 != 'e' {
      self.reader.seek(pos1)
      return self._wrapToken(t)
    }

    mut expStartPos := pos1

    if ch1 == '.' {
      if self.reader.eof() {
        self._raise(errors.E0010(), self.state.pos)
        return self._wrapToken(.LitFloat)
      }

      pos2 := self.reader.pos
      ch2 := self.reader.next()

      if ch2 == '.' {
        self.reader.seek(pos1)
        return self._wrapToken(t)
      } elif !Token_isIntDec(ch2) {
        self.reader.walk(Token_isId)
        self._raise(errors.E0010(), self.state.pos)

        return self._wrapToken(.LitFloat)
      }

      self.reader.walk(Token_isIntDec)

      if self.reader.eof() {
        return self._wrapTokenFloat(t)
      }

      pos3 := self.reader.pos
      ch3 := self.reader.next()

      if Token_isId(ch3) && ch3 != 'E' && ch3 != 'e' {
        self.reader.walk(Token_isId)
        self._raise(errors.E0010(), self.state.pos)

        return self._wrapToken(.LitFloat)
      } elif ch3 != 'E' && ch3 != 'e' {
        self.reader.seek(pos3)
        return self._wrapTokenFloat(t)
      }

      expStartPos = pos3
    }

    if self.reader.eof() {
      self._raise(errors.E0011(), expStartPos)
      return self._wrapToken(.LitFloat)
    }

    ch4 := self.reader.next()

    if !Token_isIntDec(ch4) && ch4 != '+' && ch4 != '-' {
      self.reader.walk(Token_isId)
      self._raise(errors.E0011(), expStartPos)

      return self._wrapToken(.LitFloat)
    }

    if ch4 == '+' || ch4 == '-' {
      if self.reader.eof() {
        self._raise(errors.E0011(), expStartPos)
        return self._wrapToken(.LitFloat)
      }

      ch5 := self.reader.next()

      if !Token_isIntDec(ch5) {
        self.reader.walk(Token_isId)
        self._raise(errors.E0011(), expStartPos)

        return self._wrapToken(.LitFloat)
      }
    }

    self.reader.walk(Token_isIntDec)
    return self._wrapTokenFloat(t)
  }

  fn _wrapInt (mut self: ref Self, t: TokenType, errorMessage: str, check: (char) -> bool) Token {
    if t != .LitIntDec {
      if self.reader.eof() {
        self._raise(errorMessage, self.state.pos)
        return self._wrapToken(t)
      }

      ch := self.reader.next()

      if t != .LitIntDec && !check(ch) {
        self.reader.walk(Token_isId)
        self._raise(errorMessage, self.state.pos)

        return self._wrapToken(t)
      }

      self.reader.walk(check)
    }

    return self._wrapFloat(t, errorMessage)
  }

  fn _wrapToken (mut self: ref Self, t: TokenType) Token {
    start := self.state.pos
    self.state.pos = self.reader.pos
    self.state.handled = true

    return Token{
      t: t,
      val: self.reader.slice(start, self.state.pos),
      start: start,
      end: self.state.pos
    }
  }

  fn _wrapTokenFloat (mut self: ref Self, t: TokenType) Token {
    if !self.reader.eof() {
      pos := self.reader.pos
      ch := self.reader.next()

      if Token_isId(ch) {
        self.reader.walk(Token_isId)
        self._raise(errors.E0010(), self.state.pos)

        return self._wrapToken(.LitFloat)
      }

      self.reader.seek(pos)
    }

    if t == .LitIntBin {
      self._raise(errors.E0012("binary"), self.state.pos)
    } elif t == .LitIntHex {
      self._raise(errors.E0012("hexadecimal"), self.state.pos)
    } elif t == .LitIntOct {
      self._raise(errors.E0012("octal"), self.state.pos)
    }

    return self._wrapToken(.LitFloat)
  }
}

export fn Tokenizer_init (mut reader: ref Reader) Tokenizer {
  return Tokenizer{reader: reader}
}
