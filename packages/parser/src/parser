/*!
 * Copyright (c) Aaron Delasy
 * Licensed under the MIT License
 */

import * as Expression from "./expression"
import * as Reader from "./reader"
import * as Token from "./token"
import * as Tokenizer from "./tokenizer"
import * as errors from "./errors"
import * as t from "./types"

fn emptyExpression () t.Expression {
  return t.EmptyExpression{}
}

fn emptyIdentifier () t.Identifier {
  return t.Identifier{}
}

fn emptyStatement () t.Statement {
  return t.EmptyStatement{}
}

fn emptyType () t.Type {
  return t.EmptyType{}
}

fn tokenTypeToIntegerLiteralType (tokenType: t.TokenType) t.IntegerLiteralType {
  if tokenType == .LitIntBin {
    return .Binary
  } elif tokenType == .LitIntDec {
    return .Decimal
  } elif tokenType == .LitIntHex {
    return .Hexadecimal
  } else {
    return .Octal
  }
}

export obj Parser {
  mut errors: str[]
  mut tokenizer: ref Tokenizer.Tokenizer

  fn next (mut self: ref Self, withBlockStatement := false) t.Statement {
    if self.tokenizer.lookahead(.Eof) {
      r: t.Statement = t.EofStatement{}
      return r
    }

    mut statement := self.nextStatement(withBlockStatement: withBlockStatement)

    if statement == nil {
      tk := self.tokenizer.next()
      self._raise(errors.E0104(tk.val))
      statement = emptyStatement()
    }

    return statement as t.Statement
  }

  fn nextExpression (mut self: ref Self, shouldWrap := true) t.Expression? {
    mut expression: t.Expression?

    if (
      (expression = self._maybeArrayExpression()) != nil ||
      (expression = self._maybeAwaitExpression()) != nil ||
      (expression = self._maybeClosureExpression()) != nil ||
      (expression = self._maybeMapExpression()) != nil ||
      (expression = self._maybeMemberAccessExpression()) != nil ||
      (expression = self._maybeParenthesizedExpression()) != nil ||
      (expression = self._maybeReferenceExpression()) != nil ||
      (expression = self._maybeUnaryExpression()) != nil ||
      (expression = self._maybeLiteral()) != nil ||
      (expression = self._maybeIdentifier()) != nil
    ) {
      return shouldWrap ? self._wrapExpression(expression) : expression
    }

    return nil
  }

  fn nextIdentifier (mut self: ref Self) t.Identifier? {
    startPos := self.tokenizer.pos()
    tk := self.tokenizer.next()

    if tk.t == .Id || tk.t.rawValue.slice(0, 2) == "Kw" {
      return t.Identifier{name: tk.val}
    }

    self.tokenizer.seek(startPos)
    return nil
  }

  fn nextStatement (mut self: ref Self, withBlockStatement := false) t.Statement? {
    mut statement: t.Statement?

    if (
      (withBlockStatement && (statement = self._maybeBlockStatement()) != nil) ||
      (statement = self._maybeBreakStatement()) != nil ||
      (statement = self._maybeContinueStatement()) != nil ||
      (statement = self._maybeEnumDeclaration()) != nil ||
      (statement = self._maybeIfStatement()) != nil ||
      (statement = self._maybeMainDeclaration()) != nil ||
      (statement = self._maybeVariableDeclaration()) != nil ||
      (statement = self._maybeExpressionStatement()) != nil
    ) {
      return self._wrapStatement(statement)
    } elif self.tokenizer.lookahead(.OpSemi) {
      return emptyStatement()
    }

    return nil
  }

  fn nextType (mut self: ref Self, withoutUnion := false) t.Type? {
    mut possibleType: t.Type?

    if (
      (possibleType = self._maybeFunctionOrParenthesizedType()) != nil ||
      (possibleType = self._maybeReferenceType()) != nil ||
      (possibleType = self._maybeIdentifierType()) != nil
    ) {
      return self._wrapType(possibleType, withoutUnion: withoutUnion)
    }

    return nil
  }

  fn _maybeArrayExpression (mut self: ref Self) t.Expression? {
    if !self.tokenizer.lookahead(.OpLBrack) {
      return nil
    }

    mut elements: t.Expression[]
    mut elementStartPos := -1

    loop !self.tokenizer.lookahead(.OpRBrack) {
      if self.tokenizer.lookahead(.Eof, true) || elementStartPos == self.tokenizer.pos() {
        self._raise(errors.E0116("array expression"))
        break
      }

      elementStartPos = self.tokenizer.pos()
      expression := self.nextExpression()

      if expression == nil {
        self._raise(errors.E0108("array expression"))
      } else {
        elements.push(expression)
      }

      if !self.tokenizer.lookahead(.OpComma) && !self.tokenizer.lookahead(.OpRBrack, true) {
        self._raise(errors.E0106("array expression element"))
      }
    }

    r: t.Expression = t.ArrayExpression{elements: elements}
    return r
  }

  fn _maybeAwaitExpression (mut self: ref Self) t.Expression? {
    if !self.tokenizer.lookahead(.KwAwait) {
      return nil
    }

    mut expression := self.nextExpression()

    if expression == nil {
      self._raise(errors.E0109("await"))
      expression = emptyExpression()
    }

    r: t.Expression = t.AwaitExpression{expression: expression as t.Expression}
    return r
  }

  fn _maybeBlockStatement (mut self: ref Self) t.Statement? {
    if !self.tokenizer.lookahead(.OpLBrace) {
      return nil
    }

    mut body: t.Statement[]

    loop !self.tokenizer.lookahead(.OpRBrace) {
      if self.tokenizer.lookahead(.Eof, true) {
        self._raise(errors.E0101())
        break
      }

      statement := self.next()
      body.push(statement)
    }

    r: t.Statement = t.BlockStatement{body: body}
    return r
  }

  fn _maybeBreakStatement (mut self: ref Self) t.Statement? {
    if !self.tokenizer.lookahead(.KwBreak) {
      return nil
    }

    r: t.Statement = t.BreakStatement{}
    return r
  }

  fn _maybeClosureExpression (mut self: ref Self) t.Expression? {
    if !self.tokenizer.lookahead(.KwAsync, true) && !self.tokenizer.lookahead(.OpLPar, true) {
      return nil
    }

    startPos := self.tokenizer.pos()
    asynchronous := self.tokenizer.lookahead(.KwAsync)

    if !self.tokenizer.lookahead(.OpLPar) {
      self.tokenizer.seek(startPos)
      return nil
    }

    mut parameters: t.FunctionParameter[]
    mut parameterStartPos := -1

    loop !self.tokenizer.lookahead(.OpRPar) {
      if self.tokenizer.lookahead(.Eof, true) || parameterStartPos == self.tokenizer.pos() {
        if !asynchronous && parameters.empty {
          self.tokenizer.seek(startPos)
          return nil
        }

        self._raise(errors.E0124())
        break
      }

      parameterStartPos = self.tokenizer.pos()
      parameterMutable := self.tokenizer.lookahead(.KwMut)
      canGoBack := !asynchronous && parameters.empty && !parameterMutable
      parameterName := self.nextIdentifier()

      if parameterName == nil {
        if canGoBack {
          self.tokenizer.seek(startPos)
          return nil
        }

        self._raise(errors.E0125())
      } else {
        mut parameterType: t.Type?
        mut parameterInitializer: t.Expression?
        mut parameterVariadic := false

        if self.tokenizer.lookahead(.OpColon) {
          parameterType = self.nextType()

          if parameterType == nil {
            self._raise(errors.E0127())
            parameterType = emptyType()
          }

          if self.tokenizer.lookahead(.OpEllipsis) {
            parameterVariadic = true
          }

          if self.tokenizer.lookahead(.OpEq) {
            parameterInitializer = self.nextExpression()

            if parameterInitializer == nil {
              self._raise(errors.E0128("equals sign"))
              parameterInitializer = emptyExpression()
            }
          }
        } elif self.tokenizer.lookahead(.OpColonEq) {
          parameterInitializer = self.nextExpression()

          if parameterInitializer == nil {
            self._raise(errors.E0128("colon equals sign"))
            parameterInitializer = emptyExpression()
          }
        } else {
          if canGoBack {
            self.tokenizer.seek(startPos)
            return nil
          }

          self._raise(errors.E0126())
          parameterType = emptyType()
        }

        parameters.push(t.FunctionParameter{
          name: parameterName,
          t: parameterType,
          initializer: parameterInitializer,
          mutable: parameterMutable,
          variadic: parameterVariadic
        })
      }

      if !self.tokenizer.lookahead(.OpComma) && !self.tokenizer.lookahead(.OpRPar, true) {
        self._raise(errors.E0106("closure expression parameter"))
      }
    }

    if !self.tokenizer.lookahead(.OpArrow) {
      self._raise(errors.E0129())
    }

    mut returnType := self.nextType()

    if returnType == nil {
      self._raise(errors.E0130())
      returnType = emptyType()
    }

    mut body := emptyStatement()

    if self.tokenizer.lookahead(.OpLBrace, true) {
      statement := self.nextStatement(withBlockStatement: true)

      if statement == nil {
        self._raise(errors.E0150())
      } else {
        body = statement
      }
    } else {
      self._raise(errors.E0102("expression closure return type"))
    }

    r: t.Expression = t.ClosureExpression{
      parameters: parameters,
      returnType: returnType as t.Type,
      body: body,
      asynchronous: asynchronous
    }

    return r
  }

  fn _maybeContinueStatement (mut self: ref Self) t.Statement? {
    if !self.tokenizer.lookahead(.KwContinue) {
      return nil
    }

    r: t.Statement = t.ContinueStatement{}
    return r
  }

  fn _maybeEnumDeclaration (mut self: ref Self) t.Statement? {
    if !self.tokenizer.lookahead(.KwEnum) {
      return nil
    }

    mut name := self.nextIdentifier()

    if name == nil {
      self._raise(errors.E0145())
      name = emptyIdentifier()
    }

    if !self.tokenizer.lookahead(.OpLBrace) {
      self._raise(errors.E0102("enumeration declaration name"))
    }

    mut members: t.EnumDeclarationMember[]
    mut memberStartPos := -1

    loop !self.tokenizer.lookahead(.OpRBrace) {
      if self.tokenizer.lookahead(.Eof, true) || memberStartPos == self.tokenizer.pos() {
        self._raise(errors.E0146("enumeration declaration members"))
        break
      }

      memberStartPos = self.tokenizer.pos()
      mut name := self.nextIdentifier()

      if name == nil {
        self._raise(errors.E0147())
        name = emptyIdentifier()
      }

      mut initializer: t.Expression?

      if self.tokenizer.lookahead(.OpEq) {
        initializer = self.nextExpression()

        if initializer == nil {
          self._raise(errors.E0148())
          initializer = emptyExpression()
        }
      }

      members.push(t.EnumDeclarationMember{name: name as t.Identifier, initializer: initializer})

      if !self.tokenizer.lookahead(.OpComma) && !self.tokenizer.lookahead(.OpRBrace, true) {
        self._raise(errors.E0106("enumeration declaration member"))
      }
    }

    r: t.Statement = t.EnumDeclaration{name: name as t.Identifier, members: members}
    return r
  }

  fn _maybeExpressionStatement (mut self: ref Self) t.Statement? {
    expression := self.nextExpression()

    if expression != nil {
      r: t.Statement = t.ExpressionStatement{expression: expression}
      return r
    }

    return nil
  }

  fn _maybeFunctionOrParenthesizedType (mut self: ref Self) t.Type? {
    if !self.tokenizer.lookahead(.KwAsync, true) && !self.tokenizer.lookahead(.OpLPar, true) {
      return nil
    }

    startPos := self.tokenizer.pos()
    asynchronous := self.tokenizer.lookahead(.KwAsync)

    if !self.tokenizer.lookahead(.OpLPar) {
      self.tokenizer.seek(startPos)
      return nil
    }

    mut parameters: t.FunctionTypeParameter[]
    mut parameterStartPos := -1

    loop !self.tokenizer.lookahead(.OpRPar) {
      if self.tokenizer.lookahead(.Eof, true) || parameterStartPos == self.tokenizer.pos() {
        if !asynchronous && parameters.empty {
          self.tokenizer.seek(startPos)
          return nil
        }

        self._raise(errors.E0139())
        break
      }

      parameterStartPos = self.tokenizer.pos()
      parameterMutable := self.tokenizer.lookahead(.KwMut)
      canGoBack := !asynchronous && parameters.empty && !parameterMutable
      beforeNamePos := self.tokenizer.pos()
      mut parameterName := self.nextIdentifier()
      parameterName2 := parameterName
      mut parameterType: t.Type?

      if parameterName2 == nil {
        parameterType = self.nextType()

        if parameterType == nil {
          if canGoBack {
            self.tokenizer.seek(startPos)
            return nil
          }

          self._raise(errors.E0140())
          parameterType = emptyType()
        }
      } else {
        if self.tokenizer.lookahead(.OpColon) {
          parameterType = self.nextType()

          if parameterType == nil {
            self._raise(errors.E0142())
            parameterType = emptyType()
          }
        } else {
          self.tokenizer.seek(beforeNamePos)
          parameterName = nil
          parameterType = self.nextType()

          if parameterType == nil {
            if canGoBack {
              self.tokenizer.seek(startPos)
              return nil
            }

            self._raise(errors.E0141())
            parameterType = emptyType()
          }
        }
      }

      parameterVariadic := self.tokenizer.lookahead(.OpEllipsis)

      parameters.push(t.FunctionTypeParameter{
        name: parameterName,
        t: parameterType as t.Type,
        mutable: parameterMutable,
        variadic: parameterVariadic
      })

      if !self.tokenizer.lookahead(.OpComma) && !self.tokenizer.lookahead(.OpRPar, true) {
        self._raise(errors.E0106("function type parameter"))
      }
    }

    if !self.tokenizer.lookahead(.OpArrow) {
      if !asynchronous && parameters.len == 1 {
        parameter := parameters[0]

        if parameter.name == nil && !parameter.mutable && !parameter.variadic {
          r: t.Type = t.ParenthesizedType{t: parameter.t}
          return r
        }
      }

      self._raise(errors.E0143())
    }

    mut returnType := self.nextType()

    if returnType == nil {
      self._raise(errors.E0144())
      returnType = emptyType()
    }

    r: t.Type = t.FunctionType{parameters: parameters, returnType: returnType as t.Type, asynchronous: asynchronous}
    return r
  }

  fn _maybeIdentifier (mut self: ref Self) t.Expression? {
    id := self.nextIdentifier()

    if id != nil {
      r: t.Expression = id
      return r
    }

    return nil
  }

  fn _maybeIdentifierType (mut self: ref Self) t.Type? {
    name := self.nextIdentifier()

    if name != nil {
      r: t.Type = t.IdentifierType{name: name}
      return r
    }

    return nil
  }

  fn _maybeIfStatement (mut self: ref Self) t.Statement? {
    if !self.tokenizer.lookahead(.KwElif) && !self.tokenizer.lookahead(.KwIf) {
      return nil
    }

    mut condition := self.nextExpression()

    if condition == nil {
      self._raise(errors.E0109("if"))
      condition = emptyExpression()
    }

    mut consequent := self.nextStatement(withBlockStatement: true)

    if consequent == nil && Expression.endsWithObjExpr(condition as t.Expression) {
      objectExpression := Expression.extractLastObjExpr(condition as t.Expression)
      condition = Expression.subtractLastObjExpr(condition as t.Expression)
      // self.tokenizer.seek(objectExpression.id.end)
      consequent := self.nextStatement(withBlockStatement: true)
    }

    if consequent == nil {
      self._raise(errors.E0151())
      consequent = emptyStatement()
    }

    mut alternate: t.Statement?

    if self.tokenizer.lookahead(.KwElif, true) || self.tokenizer.lookahead(.KwElse) {
      alternate = self.nextStatement(withBlockStatement: true)

      if alternate == nil {
        self._raise(errors.E0152())
        alternate = emptyStatement()
      }
    }

    r: t.Statement = t.IfStatement{
      condition: condition as t.Expression,
      consequent: consequent as t.Statement,
      alternate: alternate
    }

    return r
  }

  fn _maybeLiteral (mut self: ref Self) t.Expression? {
    if self.tokenizer.lookahead(.KwFalse, true) || self.tokenizer.lookahead(.KwTrue, true) {
      tk := self.tokenizer.next()
      r: t.Expression = t.BooleanLiteral{value: tk.val}
      return r
    } elif self.tokenizer.lookahead(.KwNil) {
      r: t.Expression = t.NilLiteral{}
      return r
    } elif self.tokenizer.lookahead(.LitChar, true) {
      tk := self.tokenizer.next()
      r: t.Expression = t.CharacterLiteral{raw: tk.val, value: tk.val.slice(1, -1)}
      return r
    } elif (
      self.tokenizer.lookahead(.LitIntBin, true) ||
      self.tokenizer.lookahead(.LitIntDec, true) ||
      self.tokenizer.lookahead(.LitIntHex, true) ||
      self.tokenizer.lookahead(.LitIntOct, true)
    ) {
      tk := self.tokenizer.next()
      r: t.Expression = t.IntegerLiteral{t: tokenTypeToIntegerLiteralType(tk.t), value: tk.val}
      return r
    } elif self.tokenizer.lookahead(.LitFloat, true) {
      tk := self.tokenizer.next()
      r: t.Expression = t.FloatingPointLiteral{value: tk.val}
      return r
    } elif self.tokenizer.lookahead(.LitStr, true) {
      tk := self.tokenizer.next()
      r: t.Expression = t.StringLiteral{raw: tk.val, value: tk.val.slice(1, -1)}
      return r
    }

    return nil
  }

  fn _maybeMainDeclaration (mut self: ref Self) t.Statement? {
    if !self.tokenizer.lookahead(.KwMain) {
      return nil
    }

    mut body: t.Statement?

    if self.tokenizer.lookahead(.OpLBrace, true) {
      body = self.nextStatement(withBlockStatement: true)

      if body == nil {
        self._raise(errors.E0153())
        body = emptyStatement()
      }
    } else {
      self._raise(errors.E0100("main"))
      body = emptyStatement()
    }

    r: t.Statement = t.MainDeclaration{body: body as t.Statement}
    return r
  }

  fn _maybeMapExpression (mut self: ref Self) t.Expression? {
    startPos := self.tokenizer.pos()

    if !self.tokenizer.lookahead(.OpLBrace) {
      return nil
    }

    mut elements: t.MapExpressionElement[]
    mut elementStartPos := -1

    loop !self.tokenizer.lookahead(.OpRBrace) {
      if self.tokenizer.lookahead(.Eof, true) || elementStartPos == self.tokenizer.pos() {
        if elements.empty {
          self.tokenizer.seek(startPos)
          return nil
        }

        self._raise(errors.E0117("map expression"))
        break
      }

      elementStartPos = self.tokenizer.pos()
      key := self.nextExpression(shouldWrap: false)

      if key == nil {
        if elements.empty {
          self.tokenizer.seek(startPos)
          return nil
        }

        self._raise(errors.E0118())
      } elif !self.tokenizer.lookahead(.OpColon) {
        if elements.empty {
          self.tokenizer.seek(startPos)
          return nil
        }

        self._raise(errors.E0113("map expression key"))
        elements.push(t.MapExpressionElement{key: key, value: emptyExpression()})
      } else {
        value := self.nextExpression()

        if value == nil {
          if elements.empty {
            self.tokenizer.seek(startPos)
            return nil
          }

          self._raise(errors.E0119())
          elements.push(t.MapExpressionElement{key: key, value: emptyExpression()})
        } else {
          elements.push(t.MapExpressionElement{key: key, value: value})
        }
      }

      if !self.tokenizer.lookahead(.OpComma) && !self.tokenizer.lookahead(.OpRBrace, true) {
        self._raise(errors.E0106("map expression element"))
      }
    }

    r: t.Expression = t.MapExpression{elements: elements}
    return r
  }

  fn _maybeMemberAccessExpression (mut self: ref Self) t.Expression? {
    if !self.tokenizer.lookahead(.OpDot) {
      return nil
    }

    mut name := self.nextIdentifier()

    if name == nil {
      self._raise(errors.E0107("dot"))
      name = emptyIdentifier()
    }

    r: t.Expression = t.MemberAccessExpression{name: name as t.Identifier}
    return r
  }

  fn _maybeParenthesizedExpression (mut self: ref Self) t.Expression? {
    if !self.tokenizer.lookahead(.OpLPar) {
      return nil
    }

    mut expression := self.nextExpression()

    if expression == nil {
      self._raise(errors.E0107("left parenthesis"))
      expression = emptyExpression()
    }

    if !self.tokenizer.lookahead(.OpRPar) {
      self._raise(errors.E0103("parenthesized expression"))
    }

    r: t.Expression = t.ParenthesizedExpression{expression: expression as t.Expression}
    return r
  }

  fn _maybeReferenceExpression (mut self: ref Self) t.Expression? {
    if !self.tokenizer.lookahead(.KwRef) {
      return nil
    }

    mut expression := self.nextExpression()

    if expression == nil {
      self._raise(errors.E0109("ref"))
      expression = emptyExpression()
    }

    r: t.Expression = t.ReferenceExpression{expression: expression as t.Expression}
    return r
  }

  fn _maybeReferenceType (mut self: ref Self) t.Type? {
    if !self.tokenizer.lookahead(.KwRef) {
      return nil
    }

    mut referencedType := self.nextType()

    if referencedType == nil {
      self._raise(errors.E0138("ref"))
      referencedType = emptyType()
    }

    r: t.Type = t.ReferenceType{t: referencedType as t.Type}
    return r
  }

  fn _maybeUnaryExpression (mut self: ref Self) t.Expression? {
    if (
      !self.tokenizer.lookahead(.OpExcl, true) &&
      !self.tokenizer.lookahead(.OpMinus, true) &&
      !self.tokenizer.lookahead(.OpMinusMinus, true) &&
      !self.tokenizer.lookahead(.OpPlus, true) &&
      !self.tokenizer.lookahead(.OpPlusPlus, true) &&
      !self.tokenizer.lookahead(.OpTilde, true)
    ) {
      return nil
    }

    tk := self.tokenizer.next()
    operator := tk.val
    mut operand := self.nextExpression(shouldWrap: false)

    if operand == nil {
      self._raise(errors.E0122())
      operand = emptyExpression()
    }

    r: t.Expression = t.UnaryExpression{operand: operand as t.Expression, operator: operator, prefix: true}
    return r
  }

  fn _maybeVariableDeclaration (mut self: ref Self) t.Statement? {
    startPos := self.tokenizer.pos()

    if (
      !self.tokenizer.lookahead(.KwConst, true) &&
      !self.tokenizer.lookahead(.KwMut, true) &&
      !self.tokenizer.lookahead(.Id, true)
    ) {
      return nil
    }

    mut name := emptyIdentifier()
    mut constant := false
    mut mutable := false

    if self.tokenizer.lookahead(.KwConst) {
      constant = true
      possibleName := self.nextIdentifier()

      if possibleName == nil {
        self._raise(errors.E0131("const"))
      } else {
        name = possibleName
      }
    } elif self.tokenizer.lookahead(.KwMut) {
      mutable = true
      possibleName := self.nextIdentifier()

      if possibleName == nil {
        self._raise(errors.E0131("mut"))
      } else {
        name = possibleName
      }
    } else {
      possibleName := self.nextIdentifier()
      name = possibleName as t.Identifier

      if !self.tokenizer.lookahead(.OpColon, true) && !self.tokenizer.lookahead(.OpColonEq, true) {
        self.tokenizer.seek(startPos)
        return nil
      }
    }

    mut variableType: t.Type?
    mut initializer: t.Expression?

    if self.tokenizer.lookahead(.OpColon) {
      variableType = self.nextType()

      if variableType == nil {
        self._raise(errors.E0133())
        variableType = emptyType()
      }

      if self.tokenizer.lookahead(.OpEq) {
        initializer = self.nextExpression()

        if initializer == nil {
          self._raise(errors.E0134("equals sign"))
          initializer = emptyExpression()
        }
      }
    } elif self.tokenizer.lookahead(.OpColonEq) {
      initializer = self.nextExpression()

      if initializer == nil {
        self._raise(errors.E0134("colon equals sign"))
        initializer = emptyExpression()
      }
    } else {
      self._raise(errors.E0132())
    }

    r: t.Statement = t.VariableDeclaration{
      name: name,
      t: variableType,
      initializer: initializer,
      mutable: mutable,
      constant: constant
    }

    return r
  }

  fn _maybeWrapArrayOrMapType (mut self: ref Self, typeToWrap: t.Type) t.Type? {
    if !self.tokenizer.lookahead(.OpLBrack) {
      return nil
    }

    if self.tokenizer.lookahead(.OpRBrack) {
      r: t.Type = t.ArrayType{elementType: typeToWrap}
      return r
    }

    mut valueType := self.nextType()

    if valueType == nil {
      self._raise(errors.E0136())
      valueType = emptyType()
    }

    if !self.tokenizer.lookahead(.OpRBrack) {
      self._raise(errors.E0115("map type value type"))
    }

    r: t.Type = t.MapType{keyType: typeToWrap, valueType: valueType as t.Type}
    return r
  }

  fn _maybeWrapAsExpression (mut self: ref Self, expression: t.Expression) t.Expression? {
    if !self.tokenizer.lookahead(.KwAs) {
      return nil
    }

    mut asType := self.nextType()

    if asType == nil {
      self._raise(errors.E0123("as"))
      asType = emptyType()
    }

    r: t.Expression = t.AsExpression{expression: expression, t: asType as t.Type}
    return r
  }

  fn _maybeWrapAssignmentExpression (mut self: ref Self, expression: t.Expression) t.Expression? {
    if (
      !self.tokenizer.lookahead(.OpAmpEq, true) &&
      !self.tokenizer.lookahead(.OpAmpAmpEq, true) &&
      !self.tokenizer.lookahead(.OpCaretEq, true) &&
      !self.tokenizer.lookahead(.OpEq, true) &&
      !self.tokenizer.lookahead(.OpLShiftEq, true) &&
      !self.tokenizer.lookahead(.OpMinusEq, true) &&
      !self.tokenizer.lookahead(.OpPercentEq, true) &&
      !self.tokenizer.lookahead(.OpPipeEq, true) &&
      !self.tokenizer.lookahead(.OpPipePipeEq, true) &&
      !self.tokenizer.lookahead(.OpPlusEq, true) &&
      !self.tokenizer.lookahead(.OpRShiftEq, true) &&
      !self.tokenizer.lookahead(.OpSlashEq, true) &&
      !self.tokenizer.lookahead(.OpStarEq, true)
    ) {
      return nil
    }

    tk := self.tokenizer.next()
    operator := tk.val
    mut right := self.nextExpression()

    if right == nil {
      self._raise(errors.E0111(operator))
      right = emptyExpression()
    }

    r: t.Expression = t.AssignmentExpression{left: expression, operator: operator, right: right as t.Expression}
    return r
  }

  fn _maybeWrapBinaryExpression (mut self: ref Self, expression: t.Expression) t.Expression? {
    if (
      !self.tokenizer.lookahead(.OpAmp, true) &&
      !self.tokenizer.lookahead(.OpAmpAmp, true) &&
      !self.tokenizer.lookahead(.OpCaret, true) &&
      !self.tokenizer.lookahead(.OpEqEq, true) &&
      !self.tokenizer.lookahead(.OpExclEq, true) &&
      !self.tokenizer.lookahead(.OpGt, true) &&
      !self.tokenizer.lookahead(.OpGtEq, true) &&
      !self.tokenizer.lookahead(.OpLShift, true) &&
      !self.tokenizer.lookahead(.OpLt, true) &&
      !self.tokenizer.lookahead(.OpLtEq, true) &&
      !self.tokenizer.lookahead(.OpMinus, true) &&
      !self.tokenizer.lookahead(.OpPercent, true) &&
      !self.tokenizer.lookahead(.OpPipe, true) &&
      !self.tokenizer.lookahead(.OpPipePipe, true) &&
      !self.tokenizer.lookahead(.OpPlus, true) &&
      !self.tokenizer.lookahead(.OpRShift, true) &&
      !self.tokenizer.lookahead(.OpSlash, true) &&
      !self.tokenizer.lookahead(.OpStar, true)
    ) {
      return nil
    }

    tk := self.tokenizer.next()
    operator := tk.val
    mut right := self.nextExpression()

    if right == nil {
      self._raise(errors.E0111(operator))
      right = emptyExpression()
    }

    r: t.Expression = t.BinaryExpression{left: expression, operator: operator, right: right as t.Expression}
    return r
  }

  fn _maybeWrapCallExpression (mut self: ref Self, expression: t.Expression) t.Expression? {
    if !self.tokenizer.lookahead(.OpLPar) {
      return nil
    }

    mut arguments: t.CallExpressionArgument[]
    mut argumentStartPos := -1

    loop !self.tokenizer.lookahead(.OpRPar) {
      if self.tokenizer.lookahead(.Eof, true) || argumentStartPos == self.tokenizer.pos() {
        self._raise(errors.E0103("call expression openning brace"))
        break
      }

      argumentStartPos = self.tokenizer.pos()
      name := self.nextIdentifier()

      if name == nil {
        expression := self.nextExpression()

        if expression == nil {
          self._raise(errors.E0105())
        } else {
          arguments.push(t.CallExpressionArgument{expression: expression})
        }
      } else {
        if self.tokenizer.lookahead(.OpColon) {
          expression := self.nextExpression()

          if expression == nil {
            self._raise(errors.E0107("call expression named argument"))
            arguments.push(t.CallExpressionArgument{name: name, expression: emptyExpression()})
          } else {
            arguments.push(t.CallExpressionArgument{name: name, expression: expression})
          }
        } else {
          self.tokenizer.seek(argumentStartPos)
          expression := self.nextExpression()

          if expression == nil {
            self._raise(errors.E0105())
          } else {
            arguments.push(t.CallExpressionArgument{expression: expression})
          }
        }
      }

      if !self.tokenizer.lookahead(.OpComma) && !self.tokenizer.lookahead(.OpRPar, true) {
        self._raise(errors.E0106("call expression argument"))
      }
    }

    r: t.Expression = t.CallExpression{callee: expression, arguments: arguments}
    return r
  }

  fn _maybeWrapConditionalExpression (mut self: ref Self, expression: t.Expression) t.Expression? {
    if !self.tokenizer.lookahead(.OpQn) {
      return nil
    }

    mut consequent := self.nextExpression()

    if consequent == nil {
      self._raise(errors.E0112())
      consequent = emptyExpression()
    }

    if !self.tokenizer.lookahead(.OpColon) {
      self._raise(errors.E0113("conditional expression consequent"))
    }

    mut alternate := self.nextExpression()

    if alternate == nil {
      self._raise(errors.E0110())
      alternate = emptyExpression()
    }

    r: t.Expression = t.ConditionalExpression{
      condition: expression,
      consequent: consequent as t.Expression,
      alternate: alternate as t.Expression
    }

    return r
  }

  fn _maybeWrapElementAccessExpression (mut self: ref Self, expression: t.Expression) t.Expression? {
    if !self.tokenizer.lookahead(.OpLBrack) {
      return nil
    }

    mut argument := self.nextExpression()

    if argument == nil {
      self._raise(errors.E0114())
      argument = emptyExpression()
    }

    if !self.tokenizer.lookahead(.OpRBrack) {
      self._raise(errors.E0115("element access expression argument"))
    }

    r: t.Expression = t.ElementAccessExpression{expression: expression, argument: argument as t.Expression}
    return r
  }

  fn _maybeWrapIsExpression (mut self: ref Self, expression: t.Expression) t.Expression? {
    if !self.tokenizer.lookahead(.KwIs) {
      return nil
    }

    mut isType := self.nextType()

    if isType == nil {
      self._raise(errors.E0123("is"))
      isType = emptyType()
    }

    r: t.Expression = t.IsExpression{expression: expression, t: isType as t.Type}
    return r
  }

  fn _maybeWrapMemberType (mut self: ref Self, typeToWrap: t.Type) t.Type? {
    if !self.tokenizer.lookahead(.OpDot) {
      return nil
    }

    mut name := self.nextIdentifier()

    if name == nil {
      self._raise(errors.E0135())
      name = emptyIdentifier()
    }

    r: t.Type = t.MemberType{t: typeToWrap, name: name as t.Identifier}
    return r
  }

  fn _maybeWrapObjectExpression (mut self: ref Self, expression: t.Expression) t.Expression? {
    startPos := self.tokenizer.pos()

    if !self.tokenizer.lookahead(.OpLBrace) {
      return nil
    }

    mut properties: t.ObjectExpressionProperty[]
    mut propertyStartPos := -1

    loop !self.tokenizer.lookahead(.OpRBrace) {
      if self.tokenizer.lookahead(.Eof, true) || propertyStartPos == self.tokenizer.pos() {
        if properties.empty {
          self.tokenizer.seek(startPos)
          return nil
        }

        self._raise(errors.E0117("object expression"))
        break
      }

      propertyStartPos = self.tokenizer.next()
      name := self.nextIdentifier()

      if name == nil {
        if properties.empty {
          self.tokenizer.seek(startPos)
          return nil
        }

        self._raise(errors.E0120())
      } else {
        if !self.tokenizer.lookahead(.OpColon) {
          if properties.empty {
            self.tokenizer.seek(startPos)
            return nil
          }

          self._raise(errors.E0113("object expression property name"))
          properties.push(t.ObjectExpressionProperty{name: name, value: emptyExpression()})
        } else {
          value := self.nextExpression()

          if value == nil {
            if properties.empty {
              self.tokenizer.seek(startPos)
              return nil
            }

            self._raise(errors.E0121())
            properties.push(t.ObjectExpressionProperty{name: name, value: emptyExpression()})
          } else {
            properties.push(t.ObjectExpressionProperty{name: name, value: value})
          }
        }
      }

      if !self.tokenizer.lookahead(.OpComma) && !self.tokenizer.lookahead(.OpRBrace, true) {
        self._raise(errors.E0106("object expression property value"))
      }
    }

    r: t.Expression = t.ObjectExpression{id: expression, properties: properties}
    return r
  }

  fn _maybeWrapOptionalType (mut self: ref Self, typeToWrap: t.Type) t.Type? {
    if !self.tokenizer.lookahead(.OpQn) {
      return nil
    }

    r: t.Type = t.OptionalType{t: typeToWrap}
    return r
  }

  fn _maybeWrapPropertyAccessExpression (mut self: ref Self, expression: t.Expression) t.Expression? {
    if !self.tokenizer.lookahead(.OpDot) {
      return nil
    }

    mut name := self.nextIdentifier()

    if name == nil {
      self._raise(errors.E0107("dot"))
      name = emptyIdentifier()
    }

    r: t.Expression = t.PropertyAccessExpression{expression: expression, name: name as t.Identifier}
    return r
  }

  fn _maybeWrapUnaryExpression (mut self: ref Self, expression: t.Expression) t.Expression? {
    if !self.tokenizer.lookahead(.OpMinusMinus, true) && !self.tokenizer.lookahead(.OpPlusPlus, true) {
      return nil
    }

    tk := self.tokenizer.next()
    operator := tk.val
    r: t.Expression = t.UnaryExpression{operand: expression, operator: operator, prefix: false}
    return r
  }

  fn _maybeWrapUnionType (mut self: ref Self, typeToWrap: t.Type) t.Type? {
    if !self.tokenizer.lookahead(.OpPipe, true) {
      return nil
    }

    mut types := [typeToWrap]

    loop self.tokenizer.lookahead(.OpPipe) {
      mut subType := self.nextType(withoutUnion: true)

      if subType == nil {
        self._raise(errors.E0137())
        subType = emptyType()
      }

      types.push(subType as t.Type)
    }

    r: t.Type = t.UnionType{types: types}
    return r
  }

  fn _raise (mut self: ref Self, message: str) {
    self.errors.push(message)
  }

  fn _wrapExpression (mut self: ref Self, expression: t.Expression) t.Expression {
    mut result: t.Expression?

    if (
      (result = self._maybeWrapAsExpression(expression)) != nil ||
      (result = self._maybeWrapAssignmentExpression(expression)) != nil ||
      (result = self._maybeWrapBinaryExpression(expression)) != nil ||
      (result = self._maybeWrapCallExpression(expression)) != nil ||
      (result = self._maybeWrapConditionalExpression(expression)) != nil ||
      (result = self._maybeWrapElementAccessExpression(expression)) != nil ||
      (result = self._maybeWrapIsExpression(expression)) != nil ||
      (result = self._maybeWrapObjectExpression(expression)) != nil ||
      (result = self._maybeWrapPropertyAccessExpression(expression)) != nil ||
      (result = self._maybeWrapUnaryExpression(expression)) != nil
    ) {
      return self._wrapExpression(result)
    }

    // todo precedence and associativity
    return expression
  }

  fn _wrapStatement (mut self: ref Self, mut statement: t.Statement) t.Statement {
    if self.tokenizer.lookahead(.OpSemi) {
      // todo update end
      return statement
    }

    return statement
  }

  fn _wrapType (mut self: ref Self, typeToWrap: t.Type, withoutUnion: bool) t.Type {
    mut result: t.Type?

    if (
      (result = self._maybeWrapArrayOrMapType(typeToWrap)) != nil ||
      (result = self._maybeWrapMemberType(typeToWrap)) != nil ||
      (result = self._maybeWrapOptionalType(typeToWrap)) != nil ||
      (!withoutUnion && (result = self._maybeWrapUnionType(typeToWrap)) != nil)
    ) {
      return self._wrapType(result, withoutUnion)
    }

    // todo precedence and associativity
    return typeToWrap
  }
}

export fn init (mut tokenizer: ref Tokenizer) Parser {
  return Parser{tokenizer: tokenizer}
}

export fn parse (path: str) t.File {
  mut reader := Reader.init(path)
  mut tokenizer := Tokenizer.init(ref reader)
  mut parser := init(ref tokenizer)
  mut result: t.Statement[]

  loop {
    statement := parser.next()

    if statement is t.EofStatement {
      break
    }

    print(statement)
    result.push(statement)
  }

  if !parser.tokenizer.errors.empty {
    parser.errors = parser.tokenizer.errors.merge(parser.errors)
  }

  return t.File{
    path: reader.path,
    errors: parser.errors,
    hasErrors: !parser.errors.empty,
    program: t.Program{
      body: result
    }
  }
}

export fn report (file: ref t.File) {
  if !file.hasErrors {
    return
  }

  loop i := 0; i < file.errors.len; i++ {
    print((i == 0 ? "" : os_EOL) + (file.errors[i] as str), to: "stderr")
  }
}
