/*!
 * Copyright (c) Aaron Delasy
 * Licensed under the MIT License
 */

enum TokenAssociativity {
  None,
  Left,
  Right,
}

enum TokenType {
  Unknown,
  Eof,
  Id,
  Whitespace,

  CommentBlock,
  CommentLine,

  LitChar,
  LitFloat,
  LitIntBin,
  LitIntDec,
  LitIntHex,
  LitIntDec,
  LitStr,

  KwAsync,
  KwAwait,
  KwBreak,
  KwCatch,
  KwConst,
  KwContinue,
  KwElif,
  KwElse,
  KwEnum,
  KwExport,
  KwFalse,
  KwFn,
  KwFrom,
  KwIf,
  KwImport,
  KwIs,
  KwLoop,
  KwMain,
  KwMut,
  KwNil,
  KwObj,
  KwRef,
  KwReturn,
  KwThrow,
  KwTrue,
  KwTry,
  KwType,

  OpAmp,
  OpAmpEq,
  OpAmpAmp,
  OpAmpAmpEq,
  OpArrow,
  OpAt,
  OpBacktick,
  OpBackSlash,
  OpCaret,
  OpCaretEq,
  OpColon,
  OpColonEq,
  OpComma,
  OpDot,
  OpDollar,
  OpEllipsis,
  OpEq,
  OpEqEq,
  OpExcl,
  OpExclEq,
  OpGt,
  OpGtEq,
  OpHash,
  OpLBrace,
  OpLBrack,
  OpLPar,
  OpLShift,
  OpLShiftEq,
  OpLt,
  OpLtEq,
  OpMinus,
  OpMinusEq,
  OpMinusMinus,
  OpPipe,
  OpPipeEq,
  OpPipePipe,
  OpPipePipeEq,
  OpPercent,
  OpPercentEq,
  OpPlus,
  OpPlusEq,
  OpPlusPlus,
  OpQn,
  OpRBrace,
  OpRBrack,
  OpRPar,
  OpRShift,
  OpRShiftEq,
  OpSemi,
  OpSlash,
  OpSlashEq,
  OpStar,
  OpStarEq,
  OpTilde,
}

obj Token {
  t: int
  val: str
  start: int
  end: int

  fn toStr (self: Self) str {
    val := self._valEscaped()
    loc := "(" + self.start.str() + "-" + self.end.str() + ")"

    return self.t.rawValue.slice(3) + loc + (val == "" ? "" : ": " + val)
  }

  fn toXML (self: Self) str {
    return
      "<Token" +
      " type=\"" + self.t.rawValue.slice(3) + "\"" +
      " val=\"" + self._valEscaped(true) + "\"" +
      " start=\"" + self.start.str() + "\"" +
      " end=\"" + self.end.str() + "\"" +
      " />"
  }

  fn _valEscaped (self: Self, xml := false) str {
    mut result := ""

    loop i := 0; i < self.val.len; i++ {
      ch := self.val[i]

      if ch == '\f' {
        result += "\\f"
      } elif ch == '\n' {
        result += "\\n"
      } elif ch == '\r' {
        result += "\\r"
      } elif ch == '\t' {
        result += "\\t"
      } elif ch == '\v' {
        result += "\\v"
      } elif ch == '"' && xml {
        result += "\\\""
      } else {
        result += ch.str()
      }
    }

    return result
  }
}

fn Token_isCharEsc (ch: char) bool {
  return
    ch == '0' ||
    ch == 'b' ||
    ch == 'f' ||
    ch == 'n' ||
    ch == 'r' ||
    ch == 't' ||
    ch == 'v' ||
    ch == '"' ||
    ch == '\'' ||
    ch == '\\'
}

fn Token_isId (ch: char) bool {
  return ch.isAlphaNum() || ch == '_'
}

fn Token_isIdStart (ch: char) bool {
  return ch.isAlpha() || ch == '_'
}

fn Token_isIntBin (ch: char) bool {
  return ch == '0' || ch == '1'
}

fn Token_isIntDec (ch: char) bool {
  return ch.isDigit()
}

fn Token_isIntHex (ch: char) bool {
  return
    ch.isDigit() ||
    ch == 'A' || ch == 'a' ||
    ch == 'B' || ch == 'b' ||
    ch == 'C' || ch == 'c' ||
    ch == 'D' || ch == 'd' ||
    ch == 'E' || ch == 'e' ||
    ch == 'F' || ch == 'f'
}

fn Token_isIntOct (ch: char) bool {
  return
    ch == '0' ||
    ch == '1' ||
    ch == '2' ||
    ch == '3' ||
    ch == '4' ||
    ch == '5' ||
    ch == '6' ||
    ch == '7'
}

fn Token_isNotNewLine (ch: char) bool {
  return ch != '\n'
}

fn Token_isStrEsc (ch: char) bool {
  return Token_isCharEsc(ch) || ch == '{'
}

fn Token_isWhitespace (ch: char) bool {
  return
    ch == ' ' ||
    ch == '\f' ||
    ch == '\n' ||
    ch == '\r' ||
    ch == '\t' ||
    ch == '\v'
}
