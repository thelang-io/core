/*!
 * Copyright (c) 2018 Aaron Delasy
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const IGNORED_DIRECTORIES := [process_cwd() + "/build"]

fn arrUnique (arr: str[]) str[] {
  mut result: str[]
  arrLen := arr.len

  loop i := 0; i < arrLen; i++ {
    it := arr[i]
    if !result.contains(it) {
      result.push(it)
    }
  }

  return result
}

fn sortStrAsc (a: str, b: str) int {
  if a.len == 0 && b.len == 0 {
    return 0
  } elif a.len == 0 || b.len == 0 {
    return a.len == 0 ? -1 : 1
  }

  len := a.len > b.len ? b.len : a.len

  loop i := 0; i < len; i++ {
    if a[i] != b[i] {
      return a[i].byte > b[i].byte ? 1 : -1
    }
  }

  return a.len == b.len ? 0 : a.len > b.len ? 1 : -1
}

fn isWordChar (ch: char) bool {
  return ch.isLetter || ch == '_' || ch == '$' || ch == ':'
}

fn traverseDirectory (dir := process_cwd()) str[] {
  if IGNORED_DIRECTORIES.contains(dir) {
    return []
  }

  mut files: str[]
  entities := fs_scandirSync(dir)
  entitiesLen := entities.len

  loop i := 0; i < entitiesLen; i++ {
    entity := entities[i]
    entityPath := dir + path_SEP + entity
    stat := fs_statSync(entityPath)

    if entity.slice(-4) == ".cpp" || entity.slice(-4) == ".hpp" {
      files.push(entityPath)
    } elif fs_isDirectorySync(entityPath) {
      files.merge(traverseDirectory(entityPath))
    }
  }

  return files
}

fn processFile (file: str) str[] {
  content := fs_readFileSync(file).str()
  contentLen := content.len
  mut matches: str[]

  loop i := 0; i < contentLen - 6; i++ {
    matchStart := i

    if (
      content[i] == 's' &&
      content[i + 1] == 't' &&
      content[i + 2] == 'd' &&
      content[i + 3] == ':' &&
      content[i + 4] == ':' &&
      isWordChar(content[i + 5])
    ) {
      i += 5
      loop i + 1 < contentLen && isWordChar(content[i + 1]) { i++ }
      matches.push(content.slice(matchStart, i + 1))
    }
  }

  return matches
}

main {
  files := traverseDirectory()
  filesLen := files.len
  mut stdEntitiesRaw: str[]

  loop i := 0; i < filesLen; i++ {
    stdEntitiesRaw.merge(processFile(files[i]))
  }

  stdEntitiesUnique := arrUnique(stdEntitiesRaw)
  stdEntities := stdEntitiesUnique.sort(sortStrAsc)
  stdEntitiesLen := stdEntities.len

  loop i := 0; i < stdEntitiesLen; i++ {
    stdEntity: str = stdEntities[i]
    print(stdEntity)
  }
}
