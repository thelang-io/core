/*!
 * Copyright (c) Aaron Delasy
 *
 * Unauthorized copying of this file, via any medium is strictly prohibited
 * Proprietary and confidential
 */

import Error, NewError from "error"
import * as fs from "fs"
import * as os from "os"

export obj Reader {
  path: str
  content: str
  pos: int
}

export fn Reader_init (p: str) Reader {
  path := fs.realpathSync(p)

  if !fs.isFileSync(path) {
    throw NewError("Path \"" + path + "\" is not a file")
  }

  content := fs.readFileSync(path, "utf8")
  return Reader{path: path, content: content, pos: 0}
}

export fn Reader_eof (this: ref Reader) bool {
  return this.pos >= this.content.len
}

export fn Reader_lookahead (mut this: ref Reader, check: char) bool {
  if this.pos + 1 >= this.content.len {
    return false
  }

  ch := this.content[this.pos + 1]

  if (
    os.type() == "Windows" &&
    ch == '\r' &&
    this.pos + 2 < this.content.len &&
    this.content[this.pos + 2] == '\n'
  ) {
    if check == '\n' {
      this.pos += 2
      return true
    }
  } elif check == ch {
    this.pos++
    return true
  }

  return false
}

export fn Reader_next (mut this: ref Reader) char {
  if Reader_eof(this) {
    throw NewError("Tried to read on eof")
  }

  ch1 := this.content[this.pos]
  this.pos++

  if os.type() == "Windows" && ch1 == '\r' && !Reader_eof(this) {
    ch2 := this.content[this.pos]

    if ch2 == '\n' {
      this.pos++
      return ch2
    }
  }

  return ch1
}

export fn Reader_seek (mut this: ref Reader, pos: int) {
  this.pos = pos
}

export fn Reader_slice (this: ref Reader, start: int?, end: int?) str {
  return this.content.slice(start, end)
}

export fn Reader_walk (mut this: ref Reader, match: fn (char) bool) {
  loop !Reader_eof(this) {
    pos := this.pos
    ch := Reader_next(this)

    if !match(ch) {
      Reader_seek(this, pos)
      break
    }
  }
}
