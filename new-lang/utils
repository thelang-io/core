/*!
 * Copyright (c) Aaron Delasy
 *
 * Unauthorized copying of this file, via any medium is strictly prohibited
 * Proprietary and confidential
 */

export fn char_isAlpha (this: ref char) bool {
  return
    this == 'A' || this == 'a' ||
    this == 'B' || this == 'b' ||
    this == 'C' || this == 'c' ||
    this == 'D' || this == 'd' ||
    this == 'E' || this == 'e' ||
    this == 'F' || this == 'f' ||
    this == 'G' || this == 'g' ||
    this == 'H' || this == 'h' ||
    this == 'I' || this == 'i' ||
    this == 'J' || this == 'j' ||
    this == 'K' || this == 'k' ||
    this == 'L' || this == 'l' ||
    this == 'M' || this == 'm' ||
    this == 'N' || this == 'n' ||
    this == 'O' || this == 'o' ||
    this == 'P' || this == 'p' ||
    this == 'Q' || this == 'q' ||
    this == 'R' || this == 'r' ||
    this == 'S' || this == 's' ||
    this == 'T' || this == 't' ||
    this == 'U' || this == 'u' ||
    this == 'V' || this == 'v' ||
    this == 'W' || this == 'w' ||
    this == 'X' || this == 'x' ||
    this == 'Y' || this == 'y' ||
    this == 'Z' || this == 'z'
}

export fn char_isAlphaNum (this: ref char) bool {
  return char_isAlpha(this) || char_isDigit(this)
}

export fn char_isDigit (this: ref char) bool {
  return
    this == '0' || this == '1' || this == '2' || this == '3' || this == '4' ||
    this == '5' || this == '6' || this == '7' || this == '8' || this == '9'
}

export fn char_isSpace (this: ref char) bool {
  return
    this == ' ' || this == '\t' || this == '\n' || this == '\v' ||
    this == '\f' || this == '\r'
}

export fn char_repeat (this: ref char, times: int) str {
  mut result: str

  loop i < times {
    result += this.str()
  }

  return result
}

export fn str_lines (this: ref str) str[] {
  mut result: str[]
  mut pushNext := true

  loop i := 0; i < this.len; i++ {
    ch := this[i]

    if pushNext {
      result.push(ch.str())
      pushNext = false
    } else {
      result[result.len - 1] += ch.str()
    }

    if ch == '\r' {
      if i != this.len - 1 && this[i + 1] == '\n' {
        result[result.len - 1] += this[++i].str()
      }

      pushNext = true
    } elif ch == '\n' {
      pushNext = true
    }
  }

  return result
}

export fn str_toUpper (this: ref str) str {
}

export fn str_toUpperFirst (this: ref str) str {
}
