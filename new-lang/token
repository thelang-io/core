/*!
 * Copyright (c) Aaron Delasy
 *
 * Unauthorized copying of this file, via any medium is strictly prohibited
 * Proprietary and confidential
 */

export obj Token {
  type: TokenType
  val: str
  start: int
  end: int
}

export enum TokenAssociativity {
  TK_ASSOC_NONE,
  TK_ASSOC_LEFT,
  TK_ASSOC_RIGHT
}

export enum TokenType {
  TK_UNKNOWN,
  TK_EOF,
  TK_WHITESPACE,

  TK_COMMENT_BLOCK,
  TK_COMMENT_LINE,

  TK_ID,

  TK_KW_BREAK,
  TK_KW_CATCH,
  TK_KW_CONTINUE,
  TK_KW_ELIF,
  TK_KW_ELSE,
  TK_KW_ENUM,
  TK_KW_EXPORT,
  TK_KW_FALSE,
  TK_KW_FN,
  TK_KW_IF,
  TK_KW_IMPORT,
  TK_KW_IS,
  TK_KW_LOOP,
  TK_KW_MAIN,
  TK_KW_MUT,
  TK_KW_NIL,
  TK_KW_OBJ,
  TK_KW_RETURN,
  TK_KW_THROW,
  TK_KW_TRUE,
  TK_KW_TRY,
  TK_KW_UNION,

  TK_LIT_CHAR,
  TK_LIT_FLOAT,
  TK_LIT_INT_BIN,
  TK_LIT_INT_DEC,
  TK_LIT_INT_HEX,
  TK_LIT_INT_OCT,
  TK_LIT_STR,

  TK_OP_AMP,
  TK_OP_AMP_EQ,
  TK_OP_AMP_AMP,
  TK_OP_AMP_AMP_EQ,
  TK_OP_AT,
  TK_OP_BACKTICK,
  TK_OP_BACKSLASH,
  TK_OP_CARET,
  TK_OP_CARET_EQ,
  TK_OP_COLON,
  TK_OP_COLON_EQ,
  TK_OP_COMMA,
  TK_OP_DOT,
  TK_OP_DOLLAR,
  TK_OP_ELLIPSIS,
  TK_OP_EQ,
  TK_OP_EQ_EQ,
  TK_OP_EXCL,
  TK_OP_EXCL_EQ,
  TK_OP_GT,
  TK_OP_GT_EQ,
  TK_OP_HASH,
  TK_OP_LBRACE,
  TK_OP_LBRACK,
  TK_OP_LPAR,
  TK_OP_LSHIFT,
  TK_OP_LSHIFT_EQ,
  TK_OP_LT,
  TK_OP_LT_EQ,
  TK_OP_MINUS,
  TK_OP_MINUS_EQ,
  TK_OP_MINUS_MINUS,
  TK_OP_PIPE,
  TK_OP_PIPE_EQ,
  TK_OP_PIPE_PIPE,
  TK_OP_PIPE_PIPE_EQ,
  TK_OP_PERCENT,
  TK_OP_PERCENT_EQ,
  TK_OP_PLUS,
  TK_OP_PLUS_EQ,
  TK_OP_PLUS_PLUS,
  TK_OP_QN,
  TK_OP_RBRACE,
  TK_OP_RBRACK,
  TK_OP_RPAR,
  TK_OP_RSHIFT,
  TK_OP_RSHIFT_EQ,
  TK_OP_SEMI,
  TK_OP_SLASH,
  TK_OP_SLASH_EQ,
  TK_OP_STAR,
  TK_OP_STAR_EQ,
  TK_OP_TILDE
}

export fn Token_isCharEsc (ch: char) bool {
  return
    ch == '0' ||
    ch == 'b' ||
    ch == 'f' ||
    ch == 'n' ||
    ch == 'r' ||
    ch == 't' ||
    ch == 'v' ||
    ch == '"' ||
    ch == '\'' ||
    ch == '\\'
}

export fn Token_isId (ch: char) bool {
  return ch.isAlphaNum() || ch == '_'
}

export fn Token_isIdStart (ch: char) bool {
  return ch.isAlpha() || ch == '_'
}

export fn Token_isIntBin (ch: char) bool {
  return ch == '0' || ch == '1'
}

export fn Token_isIntDec (ch: char) bool {
  return ch.isDigit()
}

export fn Token_isIntHex (ch: char) bool {
  return
    ch.isDigit() ||
    ch == 'A' || ch == 'a' ||
    ch == 'B' || ch == 'b' ||
    ch == 'C' || ch == 'c' ||
    ch == 'D' || ch == 'd' ||
    ch == 'E' || ch == 'e' ||
    ch == 'F' || ch == 'f'
}

export fn Token_isIntOct (ch: char) bool {
  return
    ch == '0' ||
    ch == '1' ||
    ch == '2' ||
    ch == '3' ||
    ch == '4' ||
    ch == '5' ||
    ch == '6' ||
    ch == '7'
}

export fn Token_isNotNewLine (ch: char) bool {
  return ch != '\n'
}

export fn Token_isStrEsc (ch: char) bool {
  return Token_isCharEsc(ch)
}

export fn Token_str (this: Token) str {
  val := _Token_valEscaped(this)

  return
    this.type.str().slice(3) +
    "(" + this.start.str() + "-" + this.end.str() + ")" +
    (val == "" ? "" : ": " + val)
}

export fn Token_xml (this: Token) str {
  return
    "<Token" +
    " type=\"" + this.type.str().slice(3) + "\"" +
    " val=\"" + _Token_valEscaped(this, true) + "\"" +
    " start=\"" + this.start.str() + "\"" +
    " end=\"" + this.end.str() + "\"" +
    " />"
}

fn _Token_valEscaped (this: Token, xml := false) str {
  mut result := ""

  loop i := 0; i < this.val.len; i++ {
    ch := this.val[i]

    if ch == '\f' {
      result += "\\f"
    } elif ch == '\n' {
      result += "\\n"
    } elif ch == '\r' {
      result += "\\r"
    } elif ch == '\t' {
      result += "\\t"
    } elif ch == '\v' {
      result += "\\v"
    } elif ch == '"' && xml {
      result += "\\\""
    } else {
      result += ch
    }
  }

  return result
}
