======= stdin =======
async fn job1 (mut a: ref int) ref int {
  a += 1
  return a
}

async fn job2 (mut a: ref int) int {
  return a
}

async fn job3 (
  mut a: ref int,
  fn1: async (mut a: ref int) -> ref int,
  fn2: async (mut a: ref int) -> int,
  fn3: ref (async (mut a: ref int) -> ref int),
  fn4: ref (async (mut a: ref int) -> int)
) {
  v1 := await fn1(a) + await fn2(a)
  v2 := await fn3(a) > await fn4(a)
  v3 := await fn1(a) & await fn3(a)
  v4 := await fn2(a) - await fn4(a)
  v5 := await fn1(a) == await fn4(a)
  v6 := await fn2(a) << await fn3(a)
}

main {
  mut a := 0
  refA := ref a
  refJob1 := ref job1
  refJob2 := ref job2

  v01 := await job1(ref a)
  v02 := await job1(refA)
  v03 := await job2(ref a)
  v04 := await job2(refA)
  v05 := await (ref job1)(ref a)
  v06 := await (ref job1)(refA)
  v07 := await (ref job2)(ref a)
  v08 := await (ref job2)(refA)
  v09 := await refJob1(ref a)
  v10 := await refJob1(refA)
  v11 := await refJob2(ref a)
  v12 := await refJob2(refA)
  await job3(ref a, job1, job2, ref job1, ref job2)
  await job3(ref a, ref job1, ref job2, ref job1, ref job2)
  await job3(refA, job1, job2, refJob1, refJob2)
  await job3(refA, refJob1, refJob2, refJob1, refJob2)

  async fn jobLocal1 () {
    v21 := await job1(ref a) + await job2(ref a)
    v22 := await refJob1(refA) > await refJob2(refA)
    v23 := await job1(refA) & await refJob1(refA)
    v24 := await refJob2(ref a) - await job2(ref a)
    v26 := await (ref job1)(refA) > await (ref job2)(refA)
    v27 := await job1(ref a) & await (ref job1)(ref a)
    v28 := await (ref job2)(refA) - await job2(refA)
  }

  await jobLocal1()
}
======= code =======
#if defined(WIN32) || defined(_WIN32) || defined(__WIN32) || defined(__WIN32__)
  #define THE_OS_WINDOWS
  #define THE_EOL "\r\n"
  #define THE_PATH_SEP "\\"
#else
  #if defined(__APPLE__)
    #define THE_OS_MACOS
  #elif defined(__linux__)
    #define THE_OS_LINUX
  #endif
  #define THE_EOL "\n"
  #define THE_PATH_SEP "/"
#endif

#include <setjmp.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#ifndef THE_OS_WINDOWS
  #include <pthread.h>
#endif

struct threadpool;
struct threadpool_job;
struct threadpool_thread;

typedef struct {
  const char *file;
  const char *name;
  int line;
  int col;
} err_stack_t;
typedef struct {
  int id;
  void *ctx;
  jmp_buf buf[10];
  int buf_idx;
  err_stack_t stack[10];
  int stack_idx;
  void (*_free) (void *);
} err_state_t;
typedef struct threadpool {
  bool active;
  pthread_cond_t cond1;
  pthread_cond_t cond2;
  struct threadpool_job *jobs;
  pthread_mutex_t lock;
  struct threadpool_thread *threads;
  int working_threads;
} threadpool_t;
typedef int (*threadpool_func_t) (struct threadpool *, struct threadpool_job *, void *, void *, void *, int);
typedef struct threadpool_job {
  struct threadpool_job *parent;
  int (*func) (struct threadpool *, struct threadpool_job *, void *, void *, void *, int);
  void *ctx;
  void *params;
  void *ret;
  int step;
  bool referenced;
  struct threadpool_job *next;
} threadpool_job_t;
typedef struct threadpool_thread {
  pthread_t id;
  struct threadpool_thread *next;
} threadpool_thread_t;

struct __THE_1_fn$1000;
struct __THE_1_fn$1000P;
struct __THE_1_job1_0X;
struct __THE_1_fn$1001;
struct __THE_1_fn$1001P;
struct __THE_1_job2_0X;
struct __THE_1_fn$1002;
struct __THE_1_fn$1002P;
struct __THE_1_job3_0X;
struct __THE_1_fn$1003;
struct __THE_1_async_mainX;
struct __THE_1_mainSDjobLocal1_0X;

struct __THE_1_fn$1000 {
  int (*f) (threadpool_t *, threadpool_job_t *, void *, void *, void *, int);
  void *x;
  size_t l;
};
struct __THE_1_fn$1000P {
  int32_t *n0;
};
struct __THE_1_job1_0X {
  unsigned char r;
};
struct __THE_1_fn$1001 {
  int (*f) (threadpool_t *, threadpool_job_t *, void *, void *, void *, int);
  void *x;
  size_t l;
};
struct __THE_1_fn$1001P {
  int32_t *n0;
};
struct __THE_1_job2_0X {
  unsigned char r;
};
struct __THE_1_fn$1002 {
  int (*f) (threadpool_t *, threadpool_job_t *, void *, void *, void *, int);
  void *x;
  size_t l;
};
struct __THE_1_fn$1002P {
  int32_t *n0;
  struct __THE_1_fn$1000 n1;
  struct __THE_1_fn$1001 n2;
  struct __THE_1_fn$1000 *n3;
  struct __THE_1_fn$1001 *n4;
};
struct __THE_1_job3_0X {
  int32_t __THE_0_v1_0;
  bool __THE_0_v2_0;
  int32_t __THE_0_v3_0;
  int32_t __THE_0_v4_0;
  bool __THE_0_v5_0;
  int32_t __THE_0_v6_0;
  int32_t *t1;
  int32_t t2;
  int32_t *t3;
  int32_t t4;
  int32_t *t5;
  int32_t *t6;
  int32_t t7;
  int32_t t8;
  int32_t *t9;
  int32_t t10;
  int32_t t11;
  int32_t *t12;
};
struct __THE_1_fn$1003 {
  int (*f) (threadpool_t *, threadpool_job_t *, void *, void *, void *, int);
  void *x;
  size_t l;
};
struct __THE_1_async_mainX {
  const struct __THE_1_fn$1002 *__THE_0_job3_0;
  const struct __THE_1_fn$1001 *__THE_0_job2_0;
  const struct __THE_1_fn$1000 *__THE_0_job1_0;
  int32_t __THE_0_a_0;
  int32_t *__THE_0_refA_0;
  struct __THE_1_fn$1000 *__THE_0_refJob1_0;
  struct __THE_1_fn$1001 *__THE_0_refJob2_0;
  int32_t *__THE_0_v01_0;
  int32_t *__THE_0_v02_0;
  int32_t __THE_0_v03_0;
  int32_t __THE_0_v04_0;
  int32_t *__THE_0_v05_0;
  int32_t *__THE_0_v06_0;
  int32_t __THE_0_v07_0;
  int32_t __THE_0_v08_0;
  int32_t *__THE_0_v09_0;
  int32_t *__THE_0_v10_0;
  int32_t __THE_0_v11_0;
  int32_t __THE_0_v12_0;
  struct __THE_1_fn$1003 __THE_0_mainSDjobLocal1_0;
  int32_t *t1;
  int32_t *t2;
  int32_t t3;
  int32_t t4;
  int32_t *t5;
  int32_t *t6;
  int32_t t7;
  int32_t t8;
  int32_t *t9;
  int32_t *t10;
  int32_t t11;
  int32_t t12;
};
struct __THE_1_mainSDjobLocal1_0X {
  const struct __THE_1_fn$1001 **__THE_0_refJob2_0;
  const struct __THE_1_fn$1000 **__THE_0_refJob1_0;
  const int32_t **__THE_0_refA_0;
  int32_t *__THE_0_a_0;
  const struct __THE_1_fn$1001 *__THE_0_job2_0;
  const struct __THE_1_fn$1000 *__THE_0_job1_0;
  int32_t __THE_0_v21_0;
  bool __THE_0_v22_0;
  int32_t __THE_0_v23_0;
  int32_t __THE_0_v24_0;
  bool __THE_0_v26_0;
  int32_t __THE_0_v27_0;
  int32_t __THE_0_v28_0;
  int32_t *t1;
  int32_t t2;
  int32_t *t3;
  int32_t t4;
  int32_t *t5;
  int32_t *t6;
  int32_t t7;
  int32_t t8;
  int32_t *t9;
  int32_t t10;
  int32_t *t11;
  int32_t *t12;
  int32_t t13;
  int32_t t14;
};

err_state_t err_state = {-1, (void *) 0, {}, 0, {}, 0, (void *) 0};

void *alloc (size_t);
void error_alloc (err_state_t *, size_t);
void threadpool_add (threadpool_t *, threadpool_func_t, void *, void *, void *, threadpool_job_t *);
void threadpool_deinit (threadpool_t *);
threadpool_t *threadpool_init (int);
void threadpool_insert (threadpool_t *, threadpool_job_t *);
void threadpool_job_deinit (threadpool_job_t *);
threadpool_job_t *threadpool_job_ref (threadpool_job_t *);
void threadpool_thread_deinit (threadpool_thread_t *);
threadpool_thread_t *threadpool_thread_init (threadpool_t *, threadpool_thread_t *);
void threadpool_wait (threadpool_t *);
void *threadpool_worker (void *);
void *xalloc (void *, size_t);
struct __THE_1_fn$1000 __THE_1_fn$1000_copy (const struct __THE_1_fn$1000);
void __THE_1_fn$1000_free (struct __THE_1_fn$1000);
int __THE_1_job1_0 (threadpool_t *, threadpool_job_t *, void *, void *, void *, int);
void __THE_1_job1_0_alloc (struct __THE_1_fn$1000 *, struct __THE_1_job1_0X);
struct __THE_1_fn$1001 __THE_1_fn$1001_copy (const struct __THE_1_fn$1001);
void __THE_1_fn$1001_free (struct __THE_1_fn$1001);
int __THE_1_job2_0 (threadpool_t *, threadpool_job_t *, void *, void *, void *, int);
void __THE_1_job2_0_alloc (struct __THE_1_fn$1001 *, struct __THE_1_job2_0X);
void __THE_1_fn$1002_free (struct __THE_1_fn$1002);
int __THE_1_job3_0 (threadpool_t *, threadpool_job_t *, void *, void *, void *, int);
void __THE_1_job3_0_alloc (struct __THE_1_fn$1002 *, struct __THE_1_job3_0X);
void __THE_1_fn$1003_free (struct __THE_1_fn$1003);
int __THE_1_async_main (threadpool_t *, threadpool_job_t *, void *, void *, void *, int);
int __THE_1_mainSDjobLocal1_0 (threadpool_t *, threadpool_job_t *, void *, void *, void *, int);
void __THE_1_mainSDjobLocal1_0_alloc (struct __THE_1_fn$1003 *, struct __THE_1_mainSDjobLocal1_0X);
void __THE_1_async_main_alloc (struct __THE_1_fn$1003 *, struct __THE_1_async_mainX);

void *alloc (size_t n1) {
  void *r = malloc(n1);
  if (r == NULL) error_alloc(&err_state, n1);
  return r;
}
void error_alloc (err_state_t *state, size_t n1) {
  char d[4096];
  size_t l = 0;
  for (int i = state->stack_idx - 1; i >= 0; i--) {
    err_stack_t it = state->stack[i];
    const char *fmt = THE_EOL "  at %s (%s)";
    size_t z = snprintf(NULL, 0, fmt, it.name, it.file);
    if (l + z >= 4096) {
      break;
    }
    sprintf(&d[l], fmt, it.name, it.file);
    l += z;
  }
  fprintf(stderr, "Allocation Error: failed to allocate %zu bytes%s" THE_EOL, n1, d);
  exit(EXIT_FAILURE);
}
void threadpool_add (threadpool_t *self, threadpool_func_t func, void *ctx, void *params, void *ret, threadpool_job_t *parent) {
  threadpool_job_t *job = alloc(sizeof(threadpool_job_t));
  job->parent = parent;
  job->func = func;
  job->ctx = ctx;
  job->params = params;
  job->ret = ret;
  job->step = 0;
  job->referenced = false;
  job->next = NULL;
  threadpool_insert(self, job);
}
void threadpool_deinit (threadpool_t *self) {
  pthread_mutex_lock(&self->lock);
  threadpool_job_t *it1 = self->jobs;
  while (it1 != NULL) {
    threadpool_job_t *tmp = it1->next;
    threadpool_job_deinit(it1);
    it1 = tmp;
  }
  self->active = false;
  pthread_cond_broadcast(&self->cond1);
  pthread_mutex_unlock(&self->lock);
  threadpool_wait(self);
  threadpool_thread_t *it2 = self->threads;
  while (it2 != NULL) {
    threadpool_thread_t *tmp = it2->next;
    threadpool_thread_deinit(it2);
    it2 = tmp;
  }
  pthread_cond_destroy(&self->cond1);
  pthread_cond_destroy(&self->cond2);
  pthread_mutex_destroy(&self->lock);
  free(self);
}
threadpool_t *threadpool_init (int count) {
  threadpool_t *self = alloc(sizeof(threadpool_t));
  self->active = true;
  pthread_cond_init(&self->cond1, NULL);
  pthread_cond_init(&self->cond2, NULL);
  self->jobs = NULL;
  pthread_mutex_init(&self->lock, NULL);
  self->threads = NULL;
  self->working_threads = 0;
  for (int i = 0; i < count; i++) self->threads = threadpool_thread_init(self, self->threads);
  return self;
}
void threadpool_insert (threadpool_t *self, threadpool_job_t *job) {
  pthread_mutex_lock(&self->lock);
  if (self->jobs == NULL) {
    self->jobs = job;
  } else {
    threadpool_job_t *tail = self->jobs;
    while (tail->next != NULL) tail = tail->next;
    tail->next = job;
  }
  pthread_cond_broadcast(&self->cond1);
  pthread_mutex_unlock(&self->lock);
}
void threadpool_job_deinit (threadpool_job_t *self) {
  free(self);
}
threadpool_job_t *threadpool_job_ref (threadpool_job_t *self) {
  self->referenced = true;
  return self;
}
void threadpool_thread_deinit (threadpool_thread_t *self) {
  free(self);
}
threadpool_thread_t *threadpool_thread_init (threadpool_t *tp, threadpool_thread_t *next) {
  threadpool_thread_t *self = alloc(sizeof(threadpool_thread_t));
  pthread_create(&self->id, NULL, threadpool_worker, tp);
  pthread_detach(self->id);
  self->next = next;
  return self;
}
void threadpool_wait (threadpool_t *self) {
  pthread_mutex_lock(&self->lock);
  while (self->working_threads != 0 || self->jobs != NULL) pthread_cond_wait(&self->cond2, &self->lock);
  pthread_mutex_unlock(&self->lock);
}
void *threadpool_worker (void *n) {
  threadpool_t *self = n;
  while (1) {
    pthread_mutex_lock(&self->lock);
    while (self->active && self->jobs == NULL) pthread_cond_wait(&self->cond1, &self->lock);
    if (!self->active) {
      pthread_cond_signal(&self->cond2);
      pthread_mutex_unlock(&self->lock);
      pthread_exit(NULL);
    }
    threadpool_job_t *job = self->jobs;
    self->jobs = self->jobs->next;
    job->next = NULL;
    self->working_threads++;
    pthread_mutex_unlock(&self->lock);
    if (job != NULL) {
      job->referenced = false;
      int step = job->func(self, job, job->ctx, job->params, job->ret, job->step);
      if (step == -1) {
        if (job->parent != NULL && !job->referenced) threadpool_insert(self, job->parent);
        threadpool_job_deinit(job);
      } else {
        job->step = step;
        if (!job->referenced) threadpool_insert(self, job);
      }
    }
    pthread_mutex_lock(&self->lock);
    self->working_threads--;
    if (self->active && self->jobs == NULL) pthread_cond_signal(&self->cond2);
    pthread_mutex_unlock(&self->lock);
  }
}
void *xalloc (void *n1, size_t n2) {
  void *r = malloc(n2);
  if (r == NULL) error_alloc(&err_state, n2);
  memcpy(r, n1, n2);
  return r;
}
struct __THE_1_fn$1000 __THE_1_fn$1000_copy (const struct __THE_1_fn$1000 n) {
  if (n.x == NULL) return n;
  void *x = alloc(n.l);
  memcpy(x, n.x, n.l);
  return (struct __THE_1_fn$1000) {n.f, x, n.l};
}
void __THE_1_fn$1000_free (struct __THE_1_fn$1000 n) {
  if (n.x != NULL) free(n.x);
}
int __THE_1_job1_0 (threadpool_t *tp, threadpool_job_t *job, void *px, void *pp, void *pv, int step) {
  int32_t **v = pv;
  struct __THE_1_fn$1000P *p = pp;
  struct __THE_1_job1_0X *x = px;
  unsigned char *r = &x->r;
  int32_t *__THE_0_a_0 = p->n0;
  switch (step) {
    case 0: {
      *__THE_0_a_0 += 1;
      *r = 1;
      *v = __THE_0_a_0;
    }
  }
  return -1;
}
void __THE_1_job1_0_alloc (struct __THE_1_fn$1000 *n, struct __THE_1_job1_0X x) {
  size_t l = sizeof(struct __THE_1_job1_0X);
  struct __THE_1_job1_0X *r = alloc(l);
  memcpy(r, &x, l);
  n->f = &__THE_1_job1_0;
  n->x = r;
  n->l = l;
}
struct __THE_1_fn$1001 __THE_1_fn$1001_copy (const struct __THE_1_fn$1001 n) {
  if (n.x == NULL) return n;
  void *x = alloc(n.l);
  memcpy(x, n.x, n.l);
  return (struct __THE_1_fn$1001) {n.f, x, n.l};
}
void __THE_1_fn$1001_free (struct __THE_1_fn$1001 n) {
  if (n.x != NULL) free(n.x);
}
int __THE_1_job2_0 (threadpool_t *tp, threadpool_job_t *job, void *px, void *pp, void *pv, int step) {
  int32_t *v = pv;
  struct __THE_1_fn$1001P *p = pp;
  struct __THE_1_job2_0X *x = px;
  unsigned char *r = &x->r;
  int32_t *__THE_0_a_0 = p->n0;
  switch (step) {
    case 0: {
      *r = 1;
      *v = *__THE_0_a_0;
    }
  }
  return -1;
}
void __THE_1_job2_0_alloc (struct __THE_1_fn$1001 *n, struct __THE_1_job2_0X x) {
  size_t l = sizeof(struct __THE_1_job2_0X);
  struct __THE_1_job2_0X *r = alloc(l);
  memcpy(r, &x, l);
  n->f = &__THE_1_job2_0;
  n->x = r;
  n->l = l;
}
void __THE_1_fn$1002_free (struct __THE_1_fn$1002 n) {
  if (n.x != NULL) free(n.x);
}
int __THE_1_job3_0 (threadpool_t *tp, threadpool_job_t *job, void *px, void *pp, void *pv, int step) {
  struct __THE_1_fn$1002P *p = pp;
  struct __THE_1_job3_0X *x = px;
  int32_t *__THE_0_v1_0 = &x->__THE_0_v1_0;
  bool *__THE_0_v2_0 = &x->__THE_0_v2_0;
  int32_t *__THE_0_v3_0 = &x->__THE_0_v3_0;
  int32_t *__THE_0_v4_0 = &x->__THE_0_v4_0;
  bool *__THE_0_v5_0 = &x->__THE_0_v5_0;
  int32_t *__THE_0_v6_0 = &x->__THE_0_v6_0;
  int32_t **t1 = &x->t1;
  int32_t *t2 = &x->t2;
  int32_t **t3 = &x->t3;
  int32_t *t4 = &x->t4;
  int32_t **t5 = &x->t5;
  int32_t **t6 = &x->t6;
  int32_t *t7 = &x->t7;
  int32_t *t8 = &x->t8;
  int32_t **t9 = &x->t9;
  int32_t *t10 = &x->t10;
  int32_t *t11 = &x->t11;
  int32_t **t12 = &x->t12;
  int32_t *__THE_0_a_0 = p->n0;
  const struct __THE_1_fn$1000 __THE_0_fn1_0 = p->n1;
  const struct __THE_1_fn$1001 __THE_0_fn2_0 = p->n2;
  const struct __THE_1_fn$1000 *__THE_0_fn3_0 = p->n3;
  const struct __THE_1_fn$1001 *__THE_0_fn4_0 = p->n4;
  switch (step) {
    case 0: {
      threadpool_add(tp, __THE_0_fn1_0.f, xalloc(__THE_0_fn1_0.x, __THE_0_fn1_0.l), xalloc(&(struct __THE_1_fn$1000P) {__THE_0_a_0}, sizeof(struct __THE_1_fn$1000P)), t1, threadpool_job_ref(job));
      return 1;
    }
    case 1: {
      threadpool_add(tp, __THE_0_fn2_0.f, xalloc(__THE_0_fn2_0.x, __THE_0_fn2_0.l), xalloc(&(struct __THE_1_fn$1001P) {__THE_0_a_0}, sizeof(struct __THE_1_fn$1001P)), t2, threadpool_job_ref(job));
      return 2;
    }
    case 2: {
      *__THE_0_v1_0 = **t1 + *t2;
      threadpool_add(tp, (*__THE_0_fn3_0).f, xalloc((*__THE_0_fn3_0).x, (*__THE_0_fn3_0).l), xalloc(&(struct __THE_1_fn$1000P) {__THE_0_a_0}, sizeof(struct __THE_1_fn$1000P)), t3, threadpool_job_ref(job));
      return 3;
    }
    case 3: {
      threadpool_add(tp, (*__THE_0_fn4_0).f, xalloc((*__THE_0_fn4_0).x, (*__THE_0_fn4_0).l), xalloc(&(struct __THE_1_fn$1001P) {__THE_0_a_0}, sizeof(struct __THE_1_fn$1001P)), t4, threadpool_job_ref(job));
      return 4;
    }
    case 4: {
      *__THE_0_v2_0 = **t3 > *t4;
      threadpool_add(tp, __THE_0_fn1_0.f, xalloc(__THE_0_fn1_0.x, __THE_0_fn1_0.l), xalloc(&(struct __THE_1_fn$1000P) {__THE_0_a_0}, sizeof(struct __THE_1_fn$1000P)), t5, threadpool_job_ref(job));
      return 5;
    }
    case 5: {
      threadpool_add(tp, (*__THE_0_fn3_0).f, xalloc((*__THE_0_fn3_0).x, (*__THE_0_fn3_0).l), xalloc(&(struct __THE_1_fn$1000P) {__THE_0_a_0}, sizeof(struct __THE_1_fn$1000P)), t6, threadpool_job_ref(job));
      return 6;
    }
    case 6: {
      *__THE_0_v3_0 = **t5 & **t6;
      threadpool_add(tp, __THE_0_fn2_0.f, xalloc(__THE_0_fn2_0.x, __THE_0_fn2_0.l), xalloc(&(struct __THE_1_fn$1001P) {__THE_0_a_0}, sizeof(struct __THE_1_fn$1001P)), t7, threadpool_job_ref(job));
      return 7;
    }
    case 7: {
      threadpool_add(tp, (*__THE_0_fn4_0).f, xalloc((*__THE_0_fn4_0).x, (*__THE_0_fn4_0).l), xalloc(&(struct __THE_1_fn$1001P) {__THE_0_a_0}, sizeof(struct __THE_1_fn$1001P)), t8, threadpool_job_ref(job));
      return 8;
    }
    case 8: {
      *__THE_0_v4_0 = *t7 - *t8;
      threadpool_add(tp, __THE_0_fn1_0.f, xalloc(__THE_0_fn1_0.x, __THE_0_fn1_0.l), xalloc(&(struct __THE_1_fn$1000P) {__THE_0_a_0}, sizeof(struct __THE_1_fn$1000P)), t9, threadpool_job_ref(job));
      return 9;
    }
    case 9: {
      threadpool_add(tp, (*__THE_0_fn4_0).f, xalloc((*__THE_0_fn4_0).x, (*__THE_0_fn4_0).l), xalloc(&(struct __THE_1_fn$1001P) {__THE_0_a_0}, sizeof(struct __THE_1_fn$1001P)), t10, threadpool_job_ref(job));
      return 10;
    }
    case 10: {
      *__THE_0_v5_0 = **t9 == *t10;
      threadpool_add(tp, __THE_0_fn2_0.f, xalloc(__THE_0_fn2_0.x, __THE_0_fn2_0.l), xalloc(&(struct __THE_1_fn$1001P) {__THE_0_a_0}, sizeof(struct __THE_1_fn$1001P)), t11, threadpool_job_ref(job));
      return 11;
    }
    case 11: {
      threadpool_add(tp, (*__THE_0_fn3_0).f, xalloc((*__THE_0_fn3_0).x, (*__THE_0_fn3_0).l), xalloc(&(struct __THE_1_fn$1000P) {__THE_0_a_0}, sizeof(struct __THE_1_fn$1000P)), t12, threadpool_job_ref(job));
      return 12;
    }
    case 12: {
      *__THE_0_v6_0 = *t11 << **t12;
      __THE_1_fn$1001_free((struct __THE_1_fn$1001) __THE_0_fn2_0);
      __THE_1_fn$1000_free((struct __THE_1_fn$1000) __THE_0_fn1_0);
    }
  }
  return -1;
}
void __THE_1_job3_0_alloc (struct __THE_1_fn$1002 *n, struct __THE_1_job3_0X x) {
  size_t l = sizeof(struct __THE_1_job3_0X);
  struct __THE_1_job3_0X *r = alloc(l);
  memcpy(r, &x, l);
  n->f = &__THE_1_job3_0;
  n->x = r;
  n->l = l;
}
void __THE_1_fn$1003_free (struct __THE_1_fn$1003 n) {
  if (n.x != NULL) free(n.x);
}
int __THE_1_async_main (threadpool_t *tp, threadpool_job_t *job, void *px, void *pp, void *pv, int step) {
  struct __THE_1_async_mainX *x = px;
  const struct __THE_1_fn$1002 *__THE_0_job3_0 = x->__THE_0_job3_0;
  const struct __THE_1_fn$1001 *__THE_0_job2_0 = x->__THE_0_job2_0;
  const struct __THE_1_fn$1000 *__THE_0_job1_0 = x->__THE_0_job1_0;
  int32_t *__THE_0_a_0 = &x->__THE_0_a_0;
  int32_t **__THE_0_refA_0 = &x->__THE_0_refA_0;
  struct __THE_1_fn$1000 **__THE_0_refJob1_0 = &x->__THE_0_refJob1_0;
  struct __THE_1_fn$1001 **__THE_0_refJob2_0 = &x->__THE_0_refJob2_0;
  int32_t **__THE_0_v01_0 = &x->__THE_0_v01_0;
  int32_t **__THE_0_v02_0 = &x->__THE_0_v02_0;
  int32_t *__THE_0_v03_0 = &x->__THE_0_v03_0;
  int32_t *__THE_0_v04_0 = &x->__THE_0_v04_0;
  int32_t **__THE_0_v05_0 = &x->__THE_0_v05_0;
  int32_t **__THE_0_v06_0 = &x->__THE_0_v06_0;
  int32_t *__THE_0_v07_0 = &x->__THE_0_v07_0;
  int32_t *__THE_0_v08_0 = &x->__THE_0_v08_0;
  int32_t **__THE_0_v09_0 = &x->__THE_0_v09_0;
  int32_t **__THE_0_v10_0 = &x->__THE_0_v10_0;
  int32_t *__THE_0_v11_0 = &x->__THE_0_v11_0;
  int32_t *__THE_0_v12_0 = &x->__THE_0_v12_0;
  struct __THE_1_fn$1003 *__THE_0_mainSDjobLocal1_0 = &x->__THE_0_mainSDjobLocal1_0;
  int32_t **t1 = &x->t1;
  int32_t **t2 = &x->t2;
  int32_t *t3 = &x->t3;
  int32_t *t4 = &x->t4;
  int32_t **t5 = &x->t5;
  int32_t **t6 = &x->t6;
  int32_t *t7 = &x->t7;
  int32_t *t8 = &x->t8;
  int32_t **t9 = &x->t9;
  int32_t **t10 = &x->t10;
  int32_t *t11 = &x->t11;
  int32_t *t12 = &x->t12;
  switch (step) {
    case 0: {
      *__THE_0_a_0 = 0;
      *__THE_0_refA_0 = __THE_0_a_0;
      *__THE_0_refJob1_0 = __THE_0_job1_0;
      *__THE_0_refJob2_0 = __THE_0_job2_0;
      threadpool_add(tp, (*__THE_0_job1_0).f, xalloc((*__THE_0_job1_0).x, (*__THE_0_job1_0).l), xalloc(&(struct __THE_1_fn$1000P) {__THE_0_a_0}, sizeof(struct __THE_1_fn$1000P)), t1, threadpool_job_ref(job));
      return 1;
    }
    case 1: {
      *__THE_0_v01_0 = *t1;
      threadpool_add(tp, (*__THE_0_job1_0).f, xalloc((*__THE_0_job1_0).x, (*__THE_0_job1_0).l), xalloc(&(struct __THE_1_fn$1000P) {*__THE_0_refA_0}, sizeof(struct __THE_1_fn$1000P)), t2, threadpool_job_ref(job));
      return 2;
    }
    case 2: {
      *__THE_0_v02_0 = *t2;
      threadpool_add(tp, (*__THE_0_job2_0).f, xalloc((*__THE_0_job2_0).x, (*__THE_0_job2_0).l), xalloc(&(struct __THE_1_fn$1001P) {__THE_0_a_0}, sizeof(struct __THE_1_fn$1001P)), t3, threadpool_job_ref(job));
      return 3;
    }
    case 3: {
      *__THE_0_v03_0 = *t3;
      threadpool_add(tp, (*__THE_0_job2_0).f, xalloc((*__THE_0_job2_0).x, (*__THE_0_job2_0).l), xalloc(&(struct __THE_1_fn$1001P) {*__THE_0_refA_0}, sizeof(struct __THE_1_fn$1001P)), t4, threadpool_job_ref(job));
      return 4;
    }
    case 4: {
      *__THE_0_v04_0 = *t4;
      threadpool_add(tp, (__THE_1_fn$1000_copy(*__THE_0_job1_0)).f, xalloc((__THE_1_fn$1000_copy(*__THE_0_job1_0)).x, (__THE_1_fn$1000_copy(*__THE_0_job1_0)).l), xalloc(&(struct __THE_1_fn$1000P) {__THE_0_a_0}, sizeof(struct __THE_1_fn$1000P)), t5, threadpool_job_ref(job));
      return 5;
    }
    case 5: {
      *__THE_0_v05_0 = *t5;
      threadpool_add(tp, (__THE_1_fn$1000_copy(*__THE_0_job1_0)).f, xalloc((__THE_1_fn$1000_copy(*__THE_0_job1_0)).x, (__THE_1_fn$1000_copy(*__THE_0_job1_0)).l), xalloc(&(struct __THE_1_fn$1000P) {*__THE_0_refA_0}, sizeof(struct __THE_1_fn$1000P)), t6, threadpool_job_ref(job));
      return 6;
    }
    case 6: {
      *__THE_0_v06_0 = *t6;
      threadpool_add(tp, (__THE_1_fn$1001_copy(*__THE_0_job2_0)).f, xalloc((__THE_1_fn$1001_copy(*__THE_0_job2_0)).x, (__THE_1_fn$1001_copy(*__THE_0_job2_0)).l), xalloc(&(struct __THE_1_fn$1001P) {__THE_0_a_0}, sizeof(struct __THE_1_fn$1001P)), t7, threadpool_job_ref(job));
      return 7;
    }
    case 7: {
      *__THE_0_v07_0 = *t7;
      threadpool_add(tp, (__THE_1_fn$1001_copy(*__THE_0_job2_0)).f, xalloc((__THE_1_fn$1001_copy(*__THE_0_job2_0)).x, (__THE_1_fn$1001_copy(*__THE_0_job2_0)).l), xalloc(&(struct __THE_1_fn$1001P) {*__THE_0_refA_0}, sizeof(struct __THE_1_fn$1001P)), t8, threadpool_job_ref(job));
      return 8;
    }
    case 8: {
      *__THE_0_v08_0 = *t8;
      threadpool_add(tp, (**__THE_0_refJob1_0).f, xalloc((**__THE_0_refJob1_0).x, (**__THE_0_refJob1_0).l), xalloc(&(struct __THE_1_fn$1000P) {__THE_0_a_0}, sizeof(struct __THE_1_fn$1000P)), t9, threadpool_job_ref(job));
      return 9;
    }
    case 9: {
      *__THE_0_v09_0 = *t9;
      threadpool_add(tp, (**__THE_0_refJob1_0).f, xalloc((**__THE_0_refJob1_0).x, (**__THE_0_refJob1_0).l), xalloc(&(struct __THE_1_fn$1000P) {*__THE_0_refA_0}, sizeof(struct __THE_1_fn$1000P)), t10, threadpool_job_ref(job));
      return 10;
    }
    case 10: {
      *__THE_0_v10_0 = *t10;
      threadpool_add(tp, (**__THE_0_refJob2_0).f, xalloc((**__THE_0_refJob2_0).x, (**__THE_0_refJob2_0).l), xalloc(&(struct __THE_1_fn$1001P) {__THE_0_a_0}, sizeof(struct __THE_1_fn$1001P)), t11, threadpool_job_ref(job));
      return 11;
    }
    case 11: {
      *__THE_0_v11_0 = *t11;
      threadpool_add(tp, (**__THE_0_refJob2_0).f, xalloc((**__THE_0_refJob2_0).x, (**__THE_0_refJob2_0).l), xalloc(&(struct __THE_1_fn$1001P) {*__THE_0_refA_0}, sizeof(struct __THE_1_fn$1001P)), t12, threadpool_job_ref(job));
      return 12;
    }
    case 12: {
      *__THE_0_v12_0 = *t12;
      threadpool_add(tp, (*__THE_0_job3_0).f, xalloc((*__THE_0_job3_0).x, (*__THE_0_job3_0).l), xalloc(&(struct __THE_1_fn$1002P) {__THE_0_a_0, __THE_1_fn$1000_copy(*__THE_0_job1_0), __THE_1_fn$1001_copy(*__THE_0_job2_0), __THE_0_job1_0, __THE_0_job2_0}, sizeof(struct __THE_1_fn$1002P)), NULL, threadpool_job_ref(job));
      return 13;
    }
    case 13: {
      threadpool_add(tp, (*__THE_0_job3_0).f, xalloc((*__THE_0_job3_0).x, (*__THE_0_job3_0).l), xalloc(&(struct __THE_1_fn$1002P) {__THE_0_a_0, __THE_1_fn$1000_copy(*__THE_0_job1_0), __THE_1_fn$1001_copy(*__THE_0_job2_0), __THE_0_job1_0, __THE_0_job2_0}, sizeof(struct __THE_1_fn$1002P)), NULL, threadpool_job_ref(job));
      return 14;
    }
    case 14: {
      threadpool_add(tp, (*__THE_0_job3_0).f, xalloc((*__THE_0_job3_0).x, (*__THE_0_job3_0).l), xalloc(&(struct __THE_1_fn$1002P) {*__THE_0_refA_0, __THE_1_fn$1000_copy(*__THE_0_job1_0), __THE_1_fn$1001_copy(*__THE_0_job2_0), *__THE_0_refJob1_0, *__THE_0_refJob2_0}, sizeof(struct __THE_1_fn$1002P)), NULL, threadpool_job_ref(job));
      return 15;
    }
    case 15: {
      threadpool_add(tp, (*__THE_0_job3_0).f, xalloc((*__THE_0_job3_0).x, (*__THE_0_job3_0).l), xalloc(&(struct __THE_1_fn$1002P) {*__THE_0_refA_0, __THE_1_fn$1000_copy(**__THE_0_refJob1_0), __THE_1_fn$1001_copy(**__THE_0_refJob2_0), *__THE_0_refJob1_0, *__THE_0_refJob2_0}, sizeof(struct __THE_1_fn$1002P)), NULL, threadpool_job_ref(job));
      return 16;
    }
    case 16: {
      __THE_1_mainSDjobLocal1_0_alloc((struct __THE_1_fn$1003 *) __THE_0_mainSDjobLocal1_0, (struct __THE_1_mainSDjobLocal1_0X) {__THE_0_refJob2_0, __THE_0_refJob1_0, __THE_0_refA_0, __THE_0_a_0, __THE_0_job2_0, __THE_0_job1_0});
      threadpool_add(tp, (*__THE_0_mainSDjobLocal1_0).f, xalloc((*__THE_0_mainSDjobLocal1_0).x, (*__THE_0_mainSDjobLocal1_0).l), NULL, NULL, threadpool_job_ref(job));
      return 17;
    }
    case 17: {
      __THE_1_fn$1003_free((struct __THE_1_fn$1003) *__THE_0_mainSDjobLocal1_0);
    }
  }
  return -1;
}
int __THE_1_mainSDjobLocal1_0 (threadpool_t *tp, threadpool_job_t *job, void *px, void *pp, void *pv, int step) {
  struct __THE_1_mainSDjobLocal1_0X *x = px;
  const struct __THE_1_fn$1001 **__THE_0_refJob2_0 = x->__THE_0_refJob2_0;
  const struct __THE_1_fn$1000 **__THE_0_refJob1_0 = x->__THE_0_refJob1_0;
  const int32_t **__THE_0_refA_0 = x->__THE_0_refA_0;
  int32_t *__THE_0_a_0 = x->__THE_0_a_0;
  const struct __THE_1_fn$1001 *__THE_0_job2_0 = x->__THE_0_job2_0;
  const struct __THE_1_fn$1000 *__THE_0_job1_0 = x->__THE_0_job1_0;
  int32_t *__THE_0_v21_0 = &x->__THE_0_v21_0;
  bool *__THE_0_v22_0 = &x->__THE_0_v22_0;
  int32_t *__THE_0_v23_0 = &x->__THE_0_v23_0;
  int32_t *__THE_0_v24_0 = &x->__THE_0_v24_0;
  bool *__THE_0_v26_0 = &x->__THE_0_v26_0;
  int32_t *__THE_0_v27_0 = &x->__THE_0_v27_0;
  int32_t *__THE_0_v28_0 = &x->__THE_0_v28_0;
  int32_t **t1 = &x->t1;
  int32_t *t2 = &x->t2;
  int32_t **t3 = &x->t3;
  int32_t *t4 = &x->t4;
  int32_t **t5 = &x->t5;
  int32_t **t6 = &x->t6;
  int32_t *t7 = &x->t7;
  int32_t *t8 = &x->t8;
  int32_t **t9 = &x->t9;
  int32_t *t10 = &x->t10;
  int32_t **t11 = &x->t11;
  int32_t **t12 = &x->t12;
  int32_t *t13 = &x->t13;
  int32_t *t14 = &x->t14;
  switch (step) {
    case 0: {
      threadpool_add(tp, (*__THE_0_job1_0).f, xalloc((*__THE_0_job1_0).x, (*__THE_0_job1_0).l), xalloc(&(struct __THE_1_fn$1000P) {__THE_0_a_0}, sizeof(struct __THE_1_fn$1000P)), t1, threadpool_job_ref(job));
      return 1;
    }
    case 1: {
      threadpool_add(tp, (*__THE_0_job2_0).f, xalloc((*__THE_0_job2_0).x, (*__THE_0_job2_0).l), xalloc(&(struct __THE_1_fn$1001P) {__THE_0_a_0}, sizeof(struct __THE_1_fn$1001P)), t2, threadpool_job_ref(job));
      return 2;
    }
    case 2: {
      *__THE_0_v21_0 = **t1 + *t2;
      threadpool_add(tp, (**__THE_0_refJob1_0).f, xalloc((**__THE_0_refJob1_0).x, (**__THE_0_refJob1_0).l), xalloc(&(struct __THE_1_fn$1000P) {*__THE_0_refA_0}, sizeof(struct __THE_1_fn$1000P)), t3, threadpool_job_ref(job));
      return 3;
    }
    case 3: {
      threadpool_add(tp, (**__THE_0_refJob2_0).f, xalloc((**__THE_0_refJob2_0).x, (**__THE_0_refJob2_0).l), xalloc(&(struct __THE_1_fn$1001P) {*__THE_0_refA_0}, sizeof(struct __THE_1_fn$1001P)), t4, threadpool_job_ref(job));
      return 4;
    }
    case 4: {
      *__THE_0_v22_0 = **t3 > *t4;
      threadpool_add(tp, (*__THE_0_job1_0).f, xalloc((*__THE_0_job1_0).x, (*__THE_0_job1_0).l), xalloc(&(struct __THE_1_fn$1000P) {*__THE_0_refA_0}, sizeof(struct __THE_1_fn$1000P)), t5, threadpool_job_ref(job));
      return 5;
    }
    case 5: {
      threadpool_add(tp, (**__THE_0_refJob1_0).f, xalloc((**__THE_0_refJob1_0).x, (**__THE_0_refJob1_0).l), xalloc(&(struct __THE_1_fn$1000P) {*__THE_0_refA_0}, sizeof(struct __THE_1_fn$1000P)), t6, threadpool_job_ref(job));
      return 6;
    }
    case 6: {
      *__THE_0_v23_0 = **t5 & **t6;
      threadpool_add(tp, (**__THE_0_refJob2_0).f, xalloc((**__THE_0_refJob2_0).x, (**__THE_0_refJob2_0).l), xalloc(&(struct __THE_1_fn$1001P) {__THE_0_a_0}, sizeof(struct __THE_1_fn$1001P)), t7, threadpool_job_ref(job));
      return 7;
    }
    case 7: {
      threadpool_add(tp, (*__THE_0_job2_0).f, xalloc((*__THE_0_job2_0).x, (*__THE_0_job2_0).l), xalloc(&(struct __THE_1_fn$1001P) {__THE_0_a_0}, sizeof(struct __THE_1_fn$1001P)), t8, threadpool_job_ref(job));
      return 8;
    }
    case 8: {
      *__THE_0_v24_0 = *t7 - *t8;
      threadpool_add(tp, (__THE_1_fn$1000_copy(*__THE_0_job1_0)).f, xalloc((__THE_1_fn$1000_copy(*__THE_0_job1_0)).x, (__THE_1_fn$1000_copy(*__THE_0_job1_0)).l), xalloc(&(struct __THE_1_fn$1000P) {*__THE_0_refA_0}, sizeof(struct __THE_1_fn$1000P)), t9, threadpool_job_ref(job));
      return 9;
    }
    case 9: {
      threadpool_add(tp, (__THE_1_fn$1001_copy(*__THE_0_job2_0)).f, xalloc((__THE_1_fn$1001_copy(*__THE_0_job2_0)).x, (__THE_1_fn$1001_copy(*__THE_0_job2_0)).l), xalloc(&(struct __THE_1_fn$1001P) {*__THE_0_refA_0}, sizeof(struct __THE_1_fn$1001P)), t10, threadpool_job_ref(job));
      return 10;
    }
    case 10: {
      *__THE_0_v26_0 = **t9 > *t10;
      threadpool_add(tp, (*__THE_0_job1_0).f, xalloc((*__THE_0_job1_0).x, (*__THE_0_job1_0).l), xalloc(&(struct __THE_1_fn$1000P) {__THE_0_a_0}, sizeof(struct __THE_1_fn$1000P)), t11, threadpool_job_ref(job));
      return 11;
    }
    case 11: {
      threadpool_add(tp, (__THE_1_fn$1000_copy(*__THE_0_job1_0)).f, xalloc((__THE_1_fn$1000_copy(*__THE_0_job1_0)).x, (__THE_1_fn$1000_copy(*__THE_0_job1_0)).l), xalloc(&(struct __THE_1_fn$1000P) {__THE_0_a_0}, sizeof(struct __THE_1_fn$1000P)), t12, threadpool_job_ref(job));
      return 12;
    }
    case 12: {
      *__THE_0_v27_0 = **t11 & **t12;
      threadpool_add(tp, (__THE_1_fn$1001_copy(*__THE_0_job2_0)).f, xalloc((__THE_1_fn$1001_copy(*__THE_0_job2_0)).x, (__THE_1_fn$1001_copy(*__THE_0_job2_0)).l), xalloc(&(struct __THE_1_fn$1001P) {*__THE_0_refA_0}, sizeof(struct __THE_1_fn$1001P)), t13, threadpool_job_ref(job));
      return 13;
    }
    case 13: {
      threadpool_add(tp, (*__THE_0_job2_0).f, xalloc((*__THE_0_job2_0).x, (*__THE_0_job2_0).l), xalloc(&(struct __THE_1_fn$1001P) {*__THE_0_refA_0}, sizeof(struct __THE_1_fn$1001P)), t14, threadpool_job_ref(job));
      return 14;
    }
    case 14: {
      *__THE_0_v28_0 = *t13 - *t14;
    }
  }
  return -1;
}
void __THE_1_mainSDjobLocal1_0_alloc (struct __THE_1_fn$1003 *n, struct __THE_1_mainSDjobLocal1_0X x) {
  size_t l = sizeof(struct __THE_1_mainSDjobLocal1_0X);
  struct __THE_1_mainSDjobLocal1_0X *r = alloc(l);
  memcpy(r, &x, l);
  n->f = &__THE_1_mainSDjobLocal1_0;
  n->x = r;
  n->l = l;
}
void __THE_1_async_main_alloc (struct __THE_1_fn$1003 *n, struct __THE_1_async_mainX x) {
  size_t l = sizeof(struct __THE_1_async_mainX);
  struct __THE_1_async_mainX *r = alloc(l);
  memcpy(r, &x, l);
  n->f = &__THE_1_async_main;
  n->x = r;
  n->l = l;
}

int main () {
  threadpool_t *tp = threadpool_init(5);
  const struct __THE_1_fn$1000 __THE_0_job1_0;
  const struct __THE_1_fn$1001 __THE_0_job2_0;
  const struct __THE_1_fn$1002 __THE_0_job3_0;
  __THE_1_job1_0_alloc((struct __THE_1_fn$1000 *) &__THE_0_job1_0, (struct __THE_1_job1_0X) {});
  __THE_1_job2_0_alloc((struct __THE_1_fn$1001 *) &__THE_0_job2_0, (struct __THE_1_job2_0X) {});
  __THE_1_job3_0_alloc((struct __THE_1_fn$1002 *) &__THE_0_job3_0, (struct __THE_1_job3_0X) {});
  const struct __THE_1_fn$1003 async_main;
  __THE_1_async_main_alloc((struct __THE_1_fn$1003 *) &async_main, (struct __THE_1_async_mainX) {&__THE_0_job3_0, &__THE_0_job2_0, &__THE_0_job1_0});
  threadpool_add(tp, async_main.f, async_main.x, NULL, NULL, NULL);
  threadpool_wait(tp);
  threadpool_deinit(tp);
  __THE_1_fn$1003_free((struct __THE_1_fn$1003) async_main);
  __THE_1_fn$1002_free((struct __THE_1_fn$1002) __THE_0_job3_0);
  __THE_1_fn$1001_free((struct __THE_1_fn$1001) __THE_0_job2_0);
  __THE_1_fn$1000_free((struct __THE_1_fn$1000) __THE_0_job1_0);
}
======= flags =======
======= stdout =======
