======= stdin =======
async fn a () {}

async fn test1 () {
  v1 := "test1"

  loop i := 0; i < 10; i++ {
    v2 := "test2"
    await a()
    v3 := "test3"
    print("1 start", i)
    await a()
    v4 := "test4"
    if i == 5 {
      v5 := "test5"
      return
    }
    v6 := "test6"
    await a()
    print("1 end", i)
    v7 := "test7"
    await a()
  }
}

async fn test2 () {
  v1 := "test1"

  loop i := 0; i < 10; i++ {
    await a()
    print("2 start", i)
    if i == 5 {
      v2 := "test1"
      return
    }
    print("2 end", i)
  }
}

async fn test3 () {
  v1 := "test1"

  loop i := 0; i < 10; i++ {
    v2 := "test1"
    print("3 start", i)
    if i == 5 { return }
    print("3 end", i)
    await a()
  }
}

async fn test4 () {
  v1 := "test1"

  loop i := 0; i < 10; i++ {
    print("4 start", i)
    if i == 5 { return }
    print("4 end", i)
    await a()
  }
}

async fn test5 () {
  loop i := 0; i < 10; i++ {
    v2 := "test2"
    await a()
    v3 := "test3"
    print("1 start", i)
    await a()
    v4 := "test4"
    if i == 5 {
      v5 := "test5"
      return
    }
    v6 := "test6"
    await a()
    print("1 end", i)
    v7 := "test7"
    await a()
  }
}

async fn test6 () {
  loop i := 0; i < 10; i++ {
    await a()
    print("2 start", i)
    if i == 5 {
      v2 := "test1"
      return
    }
    print("2 end", i)
  }
}

async fn test7 () {
  loop i := 0; i < 10; i++ {
    v2 := "test1"
    print("3 start", i)
    if i == 5 { return }
    print("3 end", i)
    await a()
  }
}

async fn test8 () {
  loop i := 0; i < 10; i++ {
    print("4 start", i)
    if i == 5 { return }
    print("4 end", i)
    await a()
  }
}

async fn test9 () {
  v1 := "test1"

  loop i := "1"; i != "1111111111"; i += "1" {
    v2 := "test2"
    await a()
    v3 := "test3"
    print("1 start", i)
    await a()
    v4 := "test4"
    if i == "11111" {
      v5 := "test5"
      return
    }
    v6 := "test6"
    await a()
    print("1 end", i)
    v7 := "test7"
    await a()
  }
}

async fn test10 () {
  v1 := "test1"

  loop i := "1"; i != "1111111111"; i += "1" {
    await a()
    print("2 start", i)
    if i == "11111" {
      v2 := "test1"
      return
    }
    print("2 end", i)
  }
}

async fn test11 () {
  v1 := "test1"

  loop i := "1"; i != "1111111111"; i += "1" {
    v2 := "test1"
    print("3 start", i)
    if i == "11111" { return }
    print("3 end", i)
    await a()
  }
}

async fn test12 () {
  v1 := "test1"

  loop i := "1"; i != "1111111111"; i += "1" {
    print("4 start", i)
    if i == "11111" { return }
    print("4 end", i)
    await a()
  }
}

async fn test13 () {
  loop i := "1"; i != "1111111111"; i += "1" {
    v2 := "test2"
    await a()
    v3 := "test3"
    print("1 start", i)
    await a()
    v4 := "test4"
    if i == "11111" {
      v5 := "test5"
      return
    }
    v6 := "test6"
    await a()
    print("1 end", i)
    v7 := "test7"
    await a()
  }
}

async fn test14 () {
  loop i := "1"; i != "1111111111"; i += "1" {
    await a()
    print("2 start", i)
    if i == "11111" {
      v2 := "test1"
      return
    }
    print("2 end", i)
  }
}

async fn test15 () {
  loop i := "1"; i != "1111111111"; i += "1" {
    v2 := "test1"
    print("3 start", i)
    if i == "11111" { return }
    print("3 end", i)
    await a()
  }
}

async fn test16 () {
  loop i := "1"; i != "1111111111"; i += "1" {
    print("4 start", i)
    if i == "11111" { return }
    print("4 end", i)
    await a()
  }
}

main {
  await test1()
  await test2()
  await test3()
  await test4()
  await test5()
  await test6()
  await test7()
  await test8()
  await test9()
  await test10()
  await test11()
  await test12()
  await test13()
  await test14()
  await test15()
  await test16()
}
======= code =======
#if defined(WIN32) || defined(_WIN32) || defined(__WIN32) || defined(__WIN32__)
  #define THE_OS_WINDOWS
  #define THE_EOL "\r\n"
  #define THE_PATH_SEP "\\"
#else
  #if defined(__APPLE__)
    #define THE_OS_MACOS
  #elif defined(__linux__)
    #define THE_OS_LINUX
  #endif
  #define THE_EOL "\n"
  #define THE_PATH_SEP "/"
#endif

#include <inttypes.h>
#include <setjmp.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#ifndef THE_OS_WINDOWS
  #include <pthread.h>
#endif

struct threadpool;
struct threadpool_job;
struct threadpool_thread;

typedef struct {
  const char *file;
  const char *name;
  int line;
  int col;
} err_stack_t;
typedef struct {
  int id;
  void *ctx;
  jmp_buf buf[10];
  int buf_idx;
  err_stack_t stack[10];
  int stack_idx;
  void (*_free) (void *);
} err_state_t;
struct str {
  char *d;
  size_t l;
};
typedef struct threadpool {
  bool active;
  pthread_cond_t cond1;
  pthread_cond_t cond2;
  struct threadpool_job *jobs;
  struct threadpool_job *jobs_tail;
  pthread_mutex_t lock1;
  pthread_mutex_t lock2;
  pthread_mutex_t lock3;
  struct threadpool_thread *threads;
  int working_threads;
  int alive_threads;
} threadpool_t;
typedef void (*threadpool_func_t) (struct threadpool *, struct threadpool_job *, void *, void *, void *, int);
typedef struct threadpool_job {
  struct threadpool_job *parent;
  threadpool_func_t func;
  void *ctx;
  void *params;
  void *ret;
  int step;
  struct threadpool_job *next;
} threadpool_job_t;
typedef struct threadpool_thread {
  pthread_t id;
  struct threadpool *tp;
  struct threadpool_thread *next;
} threadpool_thread_t;

struct __THE_1_fn$1000;
struct __THE_1_test1_0X;
struct __THE_1_test2_0X;
struct __THE_1_test3_0X;
struct __THE_1_test4_0X;
struct __THE_1_test5_0X;
struct __THE_1_test6_0X;
struct __THE_1_test7_0X;
struct __THE_1_test8_0X;
struct __THE_1_test9_0X;
struct __THE_1_test10_0X;
struct __THE_1_test11_0X;
struct __THE_1_test12_0X;
struct __THE_1_test13_0X;
struct __THE_1_test14_0X;
struct __THE_1_test15_0X;
struct __THE_1_test16_0X;
struct __THE_1_async_mainX;

struct __THE_1_fn$1000 {
  void (*f) (threadpool_t *, threadpool_job_t *, void *, void *, void *, int);
  void *x;
  size_t l;
};
struct __THE_1_test1_0X {
  const struct __THE_1_fn$1000 *__THE_0_a_0;
  struct str __THE_0_v1_0;
  int32_t __THE_0_i_0;
  struct str __THE_0_v2_0;
  struct str __THE_0_v3_0;
  struct str __THE_0_v4_0;
  struct str __THE_0_v5_0;
  struct str __THE_0_v6_0;
  struct str __THE_0_v7_0;
  unsigned char r;
};
struct __THE_1_test2_0X {
  const struct __THE_1_fn$1000 *__THE_0_a_0;
  struct str __THE_0_v1_0;
  int32_t __THE_0_i_0;
  struct str __THE_0_v2_0;
  unsigned char r;
};
struct __THE_1_test3_0X {
  const struct __THE_1_fn$1000 *__THE_0_a_0;
  struct str __THE_0_v1_0;
  int32_t __THE_0_i_0;
  struct str __THE_0_v2_0;
  unsigned char r;
};
struct __THE_1_test4_0X {
  const struct __THE_1_fn$1000 *__THE_0_a_0;
  struct str __THE_0_v1_0;
  int32_t __THE_0_i_0;
  unsigned char r;
};
struct __THE_1_test5_0X {
  const struct __THE_1_fn$1000 *__THE_0_a_0;
  int32_t __THE_0_i_0;
  struct str __THE_0_v2_0;
  struct str __THE_0_v3_0;
  struct str __THE_0_v4_0;
  struct str __THE_0_v5_0;
  struct str __THE_0_v6_0;
  struct str __THE_0_v7_0;
  unsigned char r;
};
struct __THE_1_test6_0X {
  const struct __THE_1_fn$1000 *__THE_0_a_0;
  int32_t __THE_0_i_0;
  struct str __THE_0_v2_0;
  unsigned char r;
};
struct __THE_1_test7_0X {
  const struct __THE_1_fn$1000 *__THE_0_a_0;
  int32_t __THE_0_i_0;
  struct str __THE_0_v2_0;
  unsigned char r;
};
struct __THE_1_test8_0X {
  const struct __THE_1_fn$1000 *__THE_0_a_0;
  int32_t __THE_0_i_0;
  unsigned char r;
};
struct __THE_1_test9_0X {
  const struct __THE_1_fn$1000 *__THE_0_a_0;
  struct str __THE_0_v1_0;
  struct str __THE_0_i_0;
  struct str __THE_0_v2_0;
  struct str __THE_0_v3_0;
  struct str __THE_0_v4_0;
  struct str __THE_0_v5_0;
  struct str __THE_0_v6_0;
  struct str __THE_0_v7_0;
  unsigned char r;
};
struct __THE_1_test10_0X {
  const struct __THE_1_fn$1000 *__THE_0_a_0;
  struct str __THE_0_v1_0;
  struct str __THE_0_i_0;
  struct str __THE_0_v2_0;
  unsigned char r;
};
struct __THE_1_test11_0X {
  const struct __THE_1_fn$1000 *__THE_0_a_0;
  struct str __THE_0_v1_0;
  struct str __THE_0_i_0;
  struct str __THE_0_v2_0;
  unsigned char r;
};
struct __THE_1_test12_0X {
  const struct __THE_1_fn$1000 *__THE_0_a_0;
  struct str __THE_0_v1_0;
  struct str __THE_0_i_0;
  unsigned char r;
};
struct __THE_1_test13_0X {
  const struct __THE_1_fn$1000 *__THE_0_a_0;
  struct str __THE_0_i_0;
  struct str __THE_0_v2_0;
  struct str __THE_0_v3_0;
  struct str __THE_0_v4_0;
  struct str __THE_0_v5_0;
  struct str __THE_0_v6_0;
  struct str __THE_0_v7_0;
  unsigned char r;
};
struct __THE_1_test14_0X {
  const struct __THE_1_fn$1000 *__THE_0_a_0;
  struct str __THE_0_i_0;
  struct str __THE_0_v2_0;
  unsigned char r;
};
struct __THE_1_test15_0X {
  const struct __THE_1_fn$1000 *__THE_0_a_0;
  struct str __THE_0_i_0;
  struct str __THE_0_v2_0;
  unsigned char r;
};
struct __THE_1_test16_0X {
  const struct __THE_1_fn$1000 *__THE_0_a_0;
  struct str __THE_0_i_0;
  unsigned char r;
};
struct __THE_1_async_mainX {
  const struct __THE_1_fn$1000 *__THE_0_test16_0;
  const struct __THE_1_fn$1000 *__THE_0_test15_0;
  const struct __THE_1_fn$1000 *__THE_0_test14_0;
  const struct __THE_1_fn$1000 *__THE_0_test13_0;
  const struct __THE_1_fn$1000 *__THE_0_test12_0;
  const struct __THE_1_fn$1000 *__THE_0_test11_0;
  const struct __THE_1_fn$1000 *__THE_0_test10_0;
  const struct __THE_1_fn$1000 *__THE_0_test9_0;
  const struct __THE_1_fn$1000 *__THE_0_test8_0;
  const struct __THE_1_fn$1000 *__THE_0_test7_0;
  const struct __THE_1_fn$1000 *__THE_0_test6_0;
  const struct __THE_1_fn$1000 *__THE_0_test5_0;
  const struct __THE_1_fn$1000 *__THE_0_test4_0;
  const struct __THE_1_fn$1000 *__THE_0_test3_0;
  const struct __THE_1_fn$1000 *__THE_0_test2_0;
  const struct __THE_1_fn$1000 *__THE_0_test1_0;
};

err_state_t err_state = {-1, NULL, {}, 0, {}, 0, NULL};

void *alloc (size_t);
void error_alloc (err_state_t *, size_t);
void print (FILE *, const char *, ...);
void *re_alloc (void *, size_t);
struct str str_alloc (const char *);
struct str str_concat_cstr (struct str, const char *);
struct str str_copy (const struct str);
bool str_eq_cstr (struct str, const char *);
void str_free (struct str);
bool str_ne_cstr (struct str, const char *);
struct str str_realloc (struct str, struct str);
void threadpool_add (threadpool_t *, threadpool_func_t, void *, void *, void *, threadpool_job_t *);
void threadpool_deinit (threadpool_t *);
threadpool_job_t *threadpool_get (threadpool_t *);
threadpool_t *threadpool_init (int);
void threadpool_insert (threadpool_t *, threadpool_job_t *);
void threadpool_job_deinit (threadpool_job_t *);
threadpool_job_t *threadpool_job_step (threadpool_job_t *, int);
void threadpool_thread_deinit (threadpool_thread_t *);
threadpool_thread_t *threadpool_thread_init (threadpool_t *, threadpool_thread_t *);
void threadpool_wait (threadpool_t *);
void *threadpool_worker (void *);
void *xalloc (void *, size_t);
void __THE_1_fn$1000_free (struct __THE_1_fn$1000);
void __THE_1_a_0 (threadpool_t *, threadpool_job_t *, void *, void *, void *, int);
void __THE_1_test1_0 (threadpool_t *, threadpool_job_t *, void *, void *, void *, int);
void __THE_1_test1_0_alloc (struct __THE_1_fn$1000 *, struct __THE_1_test1_0X);
void __THE_1_test2_0 (threadpool_t *, threadpool_job_t *, void *, void *, void *, int);
void __THE_1_test2_0_alloc (struct __THE_1_fn$1000 *, struct __THE_1_test2_0X);
void __THE_1_test3_0 (threadpool_t *, threadpool_job_t *, void *, void *, void *, int);
void __THE_1_test3_0_alloc (struct __THE_1_fn$1000 *, struct __THE_1_test3_0X);
void __THE_1_test4_0 (threadpool_t *, threadpool_job_t *, void *, void *, void *, int);
void __THE_1_test4_0_alloc (struct __THE_1_fn$1000 *, struct __THE_1_test4_0X);
void __THE_1_test5_0 (threadpool_t *, threadpool_job_t *, void *, void *, void *, int);
void __THE_1_test5_0_alloc (struct __THE_1_fn$1000 *, struct __THE_1_test5_0X);
void __THE_1_test6_0 (threadpool_t *, threadpool_job_t *, void *, void *, void *, int);
void __THE_1_test6_0_alloc (struct __THE_1_fn$1000 *, struct __THE_1_test6_0X);
void __THE_1_test7_0 (threadpool_t *, threadpool_job_t *, void *, void *, void *, int);
void __THE_1_test7_0_alloc (struct __THE_1_fn$1000 *, struct __THE_1_test7_0X);
void __THE_1_test8_0 (threadpool_t *, threadpool_job_t *, void *, void *, void *, int);
void __THE_1_test8_0_alloc (struct __THE_1_fn$1000 *, struct __THE_1_test8_0X);
void __THE_1_test9_0 (threadpool_t *, threadpool_job_t *, void *, void *, void *, int);
void __THE_1_test9_0_alloc (struct __THE_1_fn$1000 *, struct __THE_1_test9_0X);
void __THE_1_test10_0 (threadpool_t *, threadpool_job_t *, void *, void *, void *, int);
void __THE_1_test10_0_alloc (struct __THE_1_fn$1000 *, struct __THE_1_test10_0X);
void __THE_1_test11_0 (threadpool_t *, threadpool_job_t *, void *, void *, void *, int);
void __THE_1_test11_0_alloc (struct __THE_1_fn$1000 *, struct __THE_1_test11_0X);
void __THE_1_test12_0 (threadpool_t *, threadpool_job_t *, void *, void *, void *, int);
void __THE_1_test12_0_alloc (struct __THE_1_fn$1000 *, struct __THE_1_test12_0X);
void __THE_1_test13_0 (threadpool_t *, threadpool_job_t *, void *, void *, void *, int);
void __THE_1_test13_0_alloc (struct __THE_1_fn$1000 *, struct __THE_1_test13_0X);
void __THE_1_test14_0 (threadpool_t *, threadpool_job_t *, void *, void *, void *, int);
void __THE_1_test14_0_alloc (struct __THE_1_fn$1000 *, struct __THE_1_test14_0X);
void __THE_1_test15_0 (threadpool_t *, threadpool_job_t *, void *, void *, void *, int);
void __THE_1_test15_0_alloc (struct __THE_1_fn$1000 *, struct __THE_1_test15_0X);
void __THE_1_test16_0 (threadpool_t *, threadpool_job_t *, void *, void *, void *, int);
void __THE_1_test16_0_alloc (struct __THE_1_fn$1000 *, struct __THE_1_test16_0X);
void __THE_1_async_main (threadpool_t *, threadpool_job_t *, void *, void *, void *, int);
void __THE_1_async_main_alloc (struct __THE_1_fn$1000 *, struct __THE_1_async_mainX);

void *alloc (size_t n1) {
  void *r = malloc(n1);
  if (r == NULL) error_alloc(&err_state, n1);
  return r;
}
void error_alloc (err_state_t *fn_err_state, size_t n1) {
  char d[4096];
  size_t l = 0;
  for (int i = fn_err_state->stack_idx - 1; i >= 0; i--) {
    err_stack_t it = fn_err_state->stack[i];
    const char *fmt = THE_EOL "  at %s (%s)";
    size_t z = snprintf(NULL, 0, fmt, it.name, it.file);
    if (l + z >= 4096) {
      break;
    }
    sprintf(&d[l], fmt, it.name, it.file);
    l += z;
  }
  fprintf(stderr, "Allocation Error: failed to allocate %zu bytes%s" THE_EOL, n1, d);
  exit(EXIT_FAILURE);
}
void print (FILE *stream, const char *fmt, ...) {
  char *d = alloc(1024);
  size_t cap = 1024;
  size_t len = 0;
  size_t y;
  va_list args;
  va_start(args, fmt);
  while (*fmt) {
    switch (*fmt++) {
      case 't': {
        int a = va_arg(args, int);
        y = a == 0 ? 5 : 4;
        if (len + y >= cap) d = re_alloc(d, cap += (y / 1024 + 1) * 1024);
        memcpy(&d[len], a == 0 ? "false" : "true", y);
        break;
      }
      case 'b': {
        unsigned int a = va_arg(args, unsigned int);
        y = snprintf(NULL, 0, "%u", a);
        if (len + y >= cap) d = re_alloc(d, cap += (y / 1024 + 1) * 1024);
        sprintf(&d[len], "%u", a);
        break;
      }
      case 'c': {
        char a = va_arg(args, int);
        y = snprintf(NULL, 0, "%c", a);
        if (len + y >= cap) d = re_alloc(d, cap += (y / 1024 + 1) * 1024);
        sprintf(&d[len], "%c", a);
        break;
      }
      case 'e':
      case 'f':
      case 'g': {
        double a = va_arg(args, double);
        y = snprintf(NULL, 0, "%f", a);
        if (len + y >= cap) d = re_alloc(d, cap += (y / 1024 + 1) * 1024);
        sprintf(&d[len], "%f", a);
        break;
      }
      case 'h':
      case 'j':
      case 'v':
      case 'w': {
        int a = va_arg(args, int);
        y = snprintf(NULL, 0, "%d", a);
        if (len + y >= cap) d = re_alloc(d, cap += (y / 1024 + 1) * 1024);
        sprintf(&d[len], "%d", a);
        break;
      }
      case 'i':
      case 'k': {
        int32_t a = va_arg(args, int32_t);
        y = snprintf(NULL, 0, "%" PRId32, a);
        if (len + y >= cap) d = re_alloc(d, cap += (y / 1024 + 1) * 1024);
        sprintf(&d[len], "%" PRId32, a);
        break;
      }
      case 'l': {
        int64_t a = va_arg(args, int64_t);
        y = snprintf(NULL, 0, "%" PRId64, a);
        if (len + y >= cap) d = re_alloc(d, cap += (y / 1024 + 1) * 1024);
        sprintf(&d[len], "%" PRId64, a);
        break;
      }
      case 'p': {
        void *a = va_arg(args, void *);
        y = snprintf(NULL, 0, "%p", a);
        if (len + y >= cap) d = re_alloc(d, cap += (y / 1024 + 1) * 1024);
        sprintf(&d[len], "%p", a);
        break;
      }
      case 's': {
        struct str a = va_arg(args, struct str);
        y = a.l;
        if (len + y >= cap) d = re_alloc(d, cap += (y / 1024 + 1) * 1024);
        memcpy(&d[len], a.d, y);
        free(a.d);
        break;
      }
      case 'u': {
        uint32_t a = va_arg(args, uint32_t);
        y = snprintf(NULL, 0, "%" PRIu32, a);
        if (len + y >= cap) d = re_alloc(d, cap += (y / 1024 + 1) * 1024);
        sprintf(&d[len], "%" PRIu32, a);
        break;
      }
      case 'y': {
        uint64_t a = va_arg(args, uint64_t);
        y = snprintf(NULL, 0, "%" PRIu64, a);
        if (len + y >= cap) d = re_alloc(d, cap += (y / 1024 + 1) * 1024);
        sprintf(&d[len], "%" PRIu64, a);
        break;
      }
      case 'z': {
        char *a = va_arg(args, char *);
        y = strlen(a);
        if (len + y >= cap) d = re_alloc(d, cap += (y / 1024 + 1) * 1024);
        memcpy(&d[len], a, y);
        break;
      }
    }
    len += y;
  }
  va_end(args);
  d[len] = '\0';
  fputs(d, stream);
  fflush(stream);
  free(d);
}
void *re_alloc (void *n1, size_t n2) {
  void *r = realloc(n1, n2);
  if (r == NULL) error_alloc(&err_state, n2);
  return r;
}
struct str str_alloc (const char *r) {
  size_t l = strlen(r);
  char *d = alloc(l);
  memcpy(d, r, l);
  return (struct str) {d, l};
}
struct str str_concat_cstr (struct str s, const char *r) {
  size_t l = s.l + strlen(r);
  char *d = alloc(l);
  memcpy(d, s.d, s.l);
  memcpy(&d[s.l], r, l - s.l);
  free(s.d);
  return (struct str) {d, l};
}
struct str str_copy (const struct str s) {
  char *d = alloc(s.l);
  memcpy(d, s.d, s.l);
  return (struct str) {d, s.l};
}
bool str_eq_cstr (struct str s, const char *r) {
  bool d = s.l == strlen(r) && memcmp(s.d, r, s.l) == 0;
  free(s.d);
  return d;
}
void str_free (struct str s) {
  free(s.d);
}
bool str_ne_cstr (struct str s, const char *c) {
  bool r = s.l != strlen(c) || memcmp(s.d, c, s.l) != 0;
  free(s.d);
  return r;
}
struct str str_realloc (struct str s1, struct str s2) {
  free(s1.d);
  return s2;
}
void threadpool_add (threadpool_t *self, threadpool_func_t func, void *ctx, void *params, void *ret, threadpool_job_t *parent) {
  threadpool_job_t *job = alloc(sizeof(threadpool_job_t));
  job->parent = parent;
  job->func = func;
  job->ctx = ctx;
  job->params = params;
  job->ret = ret;
  job->step = 0;
  job->next = NULL;
  threadpool_insert(self, job);
}
void threadpool_deinit (threadpool_t *self) {
  self->active = false;
  pthread_mutex_lock(&self->lock1);
  while (self->alive_threads != 0) {
    pthread_mutex_lock(&self->lock3);
    pthread_cond_signal(&self->cond2);
    pthread_mutex_unlock(&self->lock3);
    pthread_cond_wait(&self->cond1, &self->lock1);
  }
  pthread_mutex_unlock(&self->lock1);
  while (self->jobs != NULL) {
    threadpool_job_t *next = self->jobs->next;
    threadpool_job_deinit(self->jobs);
    self->jobs = next;
  }
  while (self->threads != NULL) {
    threadpool_thread_t *next = self->threads->next;
    threadpool_thread_deinit(self->threads);
    self->threads = next;
  }
  pthread_cond_destroy(&self->cond1);
  pthread_cond_destroy(&self->cond2);
  pthread_mutex_destroy(&self->lock1);
  pthread_mutex_destroy(&self->lock2);
  pthread_mutex_destroy(&self->lock3);
  free(self);
}
threadpool_job_t *threadpool_get (threadpool_t *self) {
  pthread_mutex_lock(&self->lock2);
  threadpool_job_t *job = self->jobs;
  if (job != NULL) {
    self->jobs = self->jobs->next;
    job->next = NULL;
    if (self->jobs == NULL) {
      self->jobs_tail = NULL;
    } else {
      pthread_mutex_lock(&self->lock3);
      pthread_cond_signal(&self->cond2);
      pthread_mutex_unlock(&self->lock3);
    }
  }
  pthread_mutex_unlock(&self->lock2);
  return job;
}
threadpool_t *threadpool_init (int count) {
  threadpool_t *self = alloc(sizeof(threadpool_t));
  self->active = true;
  self->jobs = NULL;
  self->jobs_tail = NULL;
  self->working_threads = 0;
  self->alive_threads = 0;
  pthread_cond_init(&self->cond1, NULL);
  pthread_cond_init(&self->cond2, NULL);
  pthread_mutex_init(&self->lock1, NULL);
  pthread_mutex_init(&self->lock2, NULL);
  pthread_mutex_init(&self->lock3, NULL);
  self->threads = NULL;
  for (int i = 0; i < count; i++) self->threads = threadpool_thread_init(self, self->threads);
  pthread_mutex_lock(&self->lock1);
  while (self->alive_threads != count) pthread_cond_wait(&self->cond1, &self->lock1);
  pthread_mutex_unlock(&self->lock1);
  return self;
}
void threadpool_insert (threadpool_t *self, threadpool_job_t *job) {
  pthread_mutex_lock(&self->lock2);
  if (self->jobs == NULL) {
    self->jobs = job;
    self->jobs_tail = job;
  } else {
    self->jobs_tail->next = job;
    self->jobs_tail = self->jobs_tail->next;
  }
  pthread_mutex_lock(&self->lock3);
  pthread_cond_signal(&self->cond2);
  pthread_mutex_unlock(&self->lock3);
  pthread_mutex_unlock(&self->lock2);
}
void threadpool_job_deinit (threadpool_job_t *self) {
  if (self->ctx != NULL) free(self->ctx);
  free(self);
}
threadpool_job_t *threadpool_job_step (threadpool_job_t *self, int step) {
  self->step = step;
  return self;
}
void threadpool_thread_deinit (threadpool_thread_t *self) {
  free(self);
}
threadpool_thread_t *threadpool_thread_init (threadpool_t *tp, threadpool_thread_t *next) {
  threadpool_thread_t *self = alloc(sizeof(threadpool_thread_t));
  self->tp = tp;
  pthread_create(&self->id, NULL, threadpool_worker, self);
  pthread_detach(self->id);
  self->next = next;
  return self;
}
void threadpool_wait (threadpool_t *self) {
  pthread_mutex_lock(&self->lock1);
  while ((self->working_threads != 0 || self->jobs != NULL) && err_state.id == -1) pthread_cond_wait(&self->cond1, &self->lock1);
  pthread_mutex_unlock(&self->lock1);
}
void *threadpool_worker (void *n) {
  threadpool_thread_t *thread = n;
  threadpool_t *self = thread->tp;
  pthread_mutex_lock(&self->lock1);
  self->alive_threads++;
  pthread_cond_signal(&self->cond1);
  pthread_mutex_unlock(&self->lock1);
  while (self->active) {
    pthread_mutex_lock(&self->lock3);
    while (self->active && self->jobs == NULL) pthread_cond_wait(&self->cond2, &self->lock3);
    pthread_mutex_unlock(&self->lock3);
    if (!self->active) break;
    pthread_mutex_lock(&self->lock1);
    self->working_threads++;
    pthread_mutex_unlock(&self->lock1);
    threadpool_job_t *job = threadpool_get(self);
    if (job != NULL) job->func(self, job, job->ctx, job->params, job->ret, job->step);
    pthread_mutex_lock(&self->lock1);
    self->working_threads--;
    if ((self->working_threads == 0 && self->jobs == NULL) || err_state.id != -1) pthread_cond_signal(&self->cond1);
    pthread_mutex_unlock(&self->lock1);
  }
  pthread_mutex_lock(&self->lock1);
  self->alive_threads--;
  pthread_cond_signal(&self->cond1);
  pthread_mutex_unlock(&self->lock1);
  return NULL;
}
void *xalloc (void *n1, size_t n2) {
  void *r = malloc(n2);
  if (r == NULL) error_alloc(&err_state, n2);
  memcpy(r, n1, n2);
  return r;
}
void __THE_1_fn$1000_free (struct __THE_1_fn$1000 n) {
  if (n.x != NULL) free(n.x);
}
void __THE_1_a_0 (threadpool_t *tp, threadpool_job_t *job, void *px, void *pp, void *pv, int step) {
  if (job->parent != NULL) threadpool_insert(tp, job->parent);
  threadpool_job_deinit(job);
}
void __THE_1_test1_0 (threadpool_t *tp, threadpool_job_t *job, void *px, void *pp, void *pv, int step) {
  struct __THE_1_test1_0X *x = px;
  const struct __THE_1_fn$1000 *__THE_0_a_0 = x->__THE_0_a_0;
  struct str *__THE_0_v1_0 = &x->__THE_0_v1_0;
  int32_t *__THE_0_i_0 = &x->__THE_0_i_0;
  struct str *__THE_0_v2_0 = &x->__THE_0_v2_0;
  struct str *__THE_0_v3_0 = &x->__THE_0_v3_0;
  struct str *__THE_0_v4_0 = &x->__THE_0_v4_0;
  struct str *__THE_0_v5_0 = &x->__THE_0_v5_0;
  struct str *__THE_0_v6_0 = &x->__THE_0_v6_0;
  struct str *__THE_0_v7_0 = &x->__THE_0_v7_0;
  unsigned char *r = &x->r;
  switch (step) {
    case 0: {
      *__THE_0_v1_0 = str_alloc("test1");
      *__THE_0_i_0 = 0;
    }
    case 1: {
      if (!(*__THE_0_i_0 < 10)) return threadpool_insert(tp, threadpool_job_step(job, 10));
      *__THE_0_v2_0 = str_alloc("test2");
      job->step = 2;
      return threadpool_add(tp, (*__THE_0_a_0).f, xalloc((*__THE_0_a_0).x, (*__THE_0_a_0).l), NULL, NULL, job);
    }
    case 2: {
      *__THE_0_v3_0 = str_alloc("test3");
      print(stdout, "zziz", "1 start", " ", *__THE_0_i_0, THE_EOL);
      job->step = 3;
      return threadpool_add(tp, (*__THE_0_a_0).f, xalloc((*__THE_0_a_0).x, (*__THE_0_a_0).l), NULL, NULL, job);
    }
    case 3: {
      *__THE_0_v4_0 = str_alloc("test4");
      if (!(*__THE_0_i_0 == 5)) return threadpool_insert(tp, threadpool_job_step(job, 5));
      *__THE_0_v5_0 = str_alloc("test5");
      *r = 1;
      return threadpool_insert(tp, threadpool_job_step(job, 4));
    }
    case 4: {
      str_free((struct str) *__THE_0_v5_0);
      if (*r == 1) return threadpool_insert(tp, threadpool_job_step(job, 8));
    }
    case 5: {
      *__THE_0_v6_0 = str_alloc("test6");
      job->step = 6;
      return threadpool_add(tp, (*__THE_0_a_0).f, xalloc((*__THE_0_a_0).x, (*__THE_0_a_0).l), NULL, NULL, job);
    }
    case 6: {
      print(stdout, "zziz", "1 end", " ", *__THE_0_i_0, THE_EOL);
      *__THE_0_v7_0 = str_alloc("test7");
      job->step = 7;
      return threadpool_add(tp, (*__THE_0_a_0).f, xalloc((*__THE_0_a_0).x, (*__THE_0_a_0).l), NULL, NULL, job);
    }
    case 7: {
      str_free((struct str) *__THE_0_v7_0);
      str_free((struct str) *__THE_0_v6_0);
    }
    case 8: {
      str_free((struct str) *__THE_0_v4_0);
      str_free((struct str) *__THE_0_v3_0);
      str_free((struct str) *__THE_0_v2_0);
      if (*r == 1) return threadpool_insert(tp, threadpool_job_step(job, 10));
    }
    case 9: {
      (*__THE_0_i_0)++;
      return threadpool_insert(tp, threadpool_job_step(job, 1));
    }
    case 10: {
      str_free((struct str) *__THE_0_v1_0);
    }
  }
  if (job->parent != NULL) threadpool_insert(tp, job->parent);
  threadpool_job_deinit(job);
}
void __THE_1_test1_0_alloc (struct __THE_1_fn$1000 *n, struct __THE_1_test1_0X x) {
  size_t l = sizeof(struct __THE_1_test1_0X);
  struct __THE_1_test1_0X *r = alloc(l);
  memcpy(r, &x, l);
  n->f = &__THE_1_test1_0;
  n->x = r;
  n->l = l;
}
void __THE_1_test2_0 (threadpool_t *tp, threadpool_job_t *job, void *px, void *pp, void *pv, int step) {
  struct __THE_1_test2_0X *x = px;
  const struct __THE_1_fn$1000 *__THE_0_a_0 = x->__THE_0_a_0;
  struct str *__THE_0_v1_0 = &x->__THE_0_v1_0;
  int32_t *__THE_0_i_0 = &x->__THE_0_i_0;
  struct str *__THE_0_v2_0 = &x->__THE_0_v2_0;
  unsigned char *r = &x->r;
  switch (step) {
    case 0: {
      *__THE_0_v1_0 = str_alloc("test1");
      *__THE_0_i_0 = 0;
    }
    case 1: {
      if (!(*__THE_0_i_0 < 10)) return threadpool_insert(tp, threadpool_job_step(job, 6));
      job->step = 2;
      return threadpool_add(tp, (*__THE_0_a_0).f, xalloc((*__THE_0_a_0).x, (*__THE_0_a_0).l), NULL, NULL, job);
    }
    case 2: {
      print(stdout, "zziz", "2 start", " ", *__THE_0_i_0, THE_EOL);
      if (!(*__THE_0_i_0 == 5)) return threadpool_insert(tp, threadpool_job_step(job, 4));
      *__THE_0_v2_0 = str_alloc("test1");
      *r = 1;
      return threadpool_insert(tp, threadpool_job_step(job, 3));
    }
    case 3: {
      str_free((struct str) *__THE_0_v2_0);
      if (*r == 1) return threadpool_insert(tp, threadpool_job_step(job, 6));
    }
    case 4: {
      print(stdout, "zziz", "2 end", " ", *__THE_0_i_0, THE_EOL);
    }
    case 5: {
      (*__THE_0_i_0)++;
      return threadpool_insert(tp, threadpool_job_step(job, 1));
    }
    case 6: {
      str_free((struct str) *__THE_0_v1_0);
    }
  }
  if (job->parent != NULL) threadpool_insert(tp, job->parent);
  threadpool_job_deinit(job);
}
void __THE_1_test2_0_alloc (struct __THE_1_fn$1000 *n, struct __THE_1_test2_0X x) {
  size_t l = sizeof(struct __THE_1_test2_0X);
  struct __THE_1_test2_0X *r = alloc(l);
  memcpy(r, &x, l);
  n->f = &__THE_1_test2_0;
  n->x = r;
  n->l = l;
}
void __THE_1_test3_0 (threadpool_t *tp, threadpool_job_t *job, void *px, void *pp, void *pv, int step) {
  struct __THE_1_test3_0X *x = px;
  const struct __THE_1_fn$1000 *__THE_0_a_0 = x->__THE_0_a_0;
  struct str *__THE_0_v1_0 = &x->__THE_0_v1_0;
  int32_t *__THE_0_i_0 = &x->__THE_0_i_0;
  struct str *__THE_0_v2_0 = &x->__THE_0_v2_0;
  unsigned char *r = &x->r;
  switch (step) {
    case 0: {
      *__THE_0_v1_0 = str_alloc("test1");
      *__THE_0_i_0 = 0;
    }
    case 1: {
      if (!(*__THE_0_i_0 < 10)) return threadpool_insert(tp, threadpool_job_step(job, 5));
      *__THE_0_v2_0 = str_alloc("test1");
      print(stdout, "zziz", "3 start", " ", *__THE_0_i_0, THE_EOL);
      if (!(*__THE_0_i_0 == 5)) return threadpool_insert(tp, threadpool_job_step(job, 2));
      *r = 1;
      return threadpool_insert(tp, threadpool_job_step(job, 3));
    }
    case 2: {
      print(stdout, "zziz", "3 end", " ", *__THE_0_i_0, THE_EOL);
      job->step = 3;
      return threadpool_add(tp, (*__THE_0_a_0).f, xalloc((*__THE_0_a_0).x, (*__THE_0_a_0).l), NULL, NULL, job);
    }
    case 3: {
      str_free((struct str) *__THE_0_v2_0);
      if (*r == 1) return threadpool_insert(tp, threadpool_job_step(job, 5));
    }
    case 4: {
      (*__THE_0_i_0)++;
      return threadpool_insert(tp, threadpool_job_step(job, 1));
    }
    case 5: {
      str_free((struct str) *__THE_0_v1_0);
    }
  }
  if (job->parent != NULL) threadpool_insert(tp, job->parent);
  threadpool_job_deinit(job);
}
void __THE_1_test3_0_alloc (struct __THE_1_fn$1000 *n, struct __THE_1_test3_0X x) {
  size_t l = sizeof(struct __THE_1_test3_0X);
  struct __THE_1_test3_0X *r = alloc(l);
  memcpy(r, &x, l);
  n->f = &__THE_1_test3_0;
  n->x = r;
  n->l = l;
}
void __THE_1_test4_0 (threadpool_t *tp, threadpool_job_t *job, void *px, void *pp, void *pv, int step) {
  struct __THE_1_test4_0X *x = px;
  const struct __THE_1_fn$1000 *__THE_0_a_0 = x->__THE_0_a_0;
  struct str *__THE_0_v1_0 = &x->__THE_0_v1_0;
  int32_t *__THE_0_i_0 = &x->__THE_0_i_0;
  unsigned char *r = &x->r;
  switch (step) {
    case 0: {
      *__THE_0_v1_0 = str_alloc("test1");
      *__THE_0_i_0 = 0;
    }
    case 1: {
      if (!(*__THE_0_i_0 < 10)) return threadpool_insert(tp, threadpool_job_step(job, 4));
      print(stdout, "zziz", "4 start", " ", *__THE_0_i_0, THE_EOL);
      if (!(*__THE_0_i_0 == 5)) return threadpool_insert(tp, threadpool_job_step(job, 2));
      *r = 1;
      return threadpool_insert(tp, threadpool_job_step(job, 4));
    }
    case 2: {
      print(stdout, "zziz", "4 end", " ", *__THE_0_i_0, THE_EOL);
      job->step = 3;
      return threadpool_add(tp, (*__THE_0_a_0).f, xalloc((*__THE_0_a_0).x, (*__THE_0_a_0).l), NULL, NULL, job);
    }
    case 3: {
      (*__THE_0_i_0)++;
      return threadpool_insert(tp, threadpool_job_step(job, 1));
    }
    case 4: {
      str_free((struct str) *__THE_0_v1_0);
    }
  }
  if (job->parent != NULL) threadpool_insert(tp, job->parent);
  threadpool_job_deinit(job);
}
void __THE_1_test4_0_alloc (struct __THE_1_fn$1000 *n, struct __THE_1_test4_0X x) {
  size_t l = sizeof(struct __THE_1_test4_0X);
  struct __THE_1_test4_0X *r = alloc(l);
  memcpy(r, &x, l);
  n->f = &__THE_1_test4_0;
  n->x = r;
  n->l = l;
}
void __THE_1_test5_0 (threadpool_t *tp, threadpool_job_t *job, void *px, void *pp, void *pv, int step) {
  struct __THE_1_test5_0X *x = px;
  const struct __THE_1_fn$1000 *__THE_0_a_0 = x->__THE_0_a_0;
  int32_t *__THE_0_i_0 = &x->__THE_0_i_0;
  struct str *__THE_0_v2_0 = &x->__THE_0_v2_0;
  struct str *__THE_0_v3_0 = &x->__THE_0_v3_0;
  struct str *__THE_0_v4_0 = &x->__THE_0_v4_0;
  struct str *__THE_0_v5_0 = &x->__THE_0_v5_0;
  struct str *__THE_0_v6_0 = &x->__THE_0_v6_0;
  struct str *__THE_0_v7_0 = &x->__THE_0_v7_0;
  unsigned char *r = &x->r;
  switch (step) {
    case 0: {
      *__THE_0_i_0 = 0;
    }
    case 1: {
      if (!(*__THE_0_i_0 < 10)) return threadpool_insert(tp, threadpool_job_step(job, 10));
      *__THE_0_v2_0 = str_alloc("test2");
      job->step = 2;
      return threadpool_add(tp, (*__THE_0_a_0).f, xalloc((*__THE_0_a_0).x, (*__THE_0_a_0).l), NULL, NULL, job);
    }
    case 2: {
      *__THE_0_v3_0 = str_alloc("test3");
      print(stdout, "zziz", "1 start", " ", *__THE_0_i_0, THE_EOL);
      job->step = 3;
      return threadpool_add(tp, (*__THE_0_a_0).f, xalloc((*__THE_0_a_0).x, (*__THE_0_a_0).l), NULL, NULL, job);
    }
    case 3: {
      *__THE_0_v4_0 = str_alloc("test4");
      if (!(*__THE_0_i_0 == 5)) return threadpool_insert(tp, threadpool_job_step(job, 5));
      *__THE_0_v5_0 = str_alloc("test5");
      *r = 1;
      return threadpool_insert(tp, threadpool_job_step(job, 4));
    }
    case 4: {
      str_free((struct str) *__THE_0_v5_0);
      if (*r == 1) return threadpool_insert(tp, threadpool_job_step(job, 8));
    }
    case 5: {
      *__THE_0_v6_0 = str_alloc("test6");
      job->step = 6;
      return threadpool_add(tp, (*__THE_0_a_0).f, xalloc((*__THE_0_a_0).x, (*__THE_0_a_0).l), NULL, NULL, job);
    }
    case 6: {
      print(stdout, "zziz", "1 end", " ", *__THE_0_i_0, THE_EOL);
      *__THE_0_v7_0 = str_alloc("test7");
      job->step = 7;
      return threadpool_add(tp, (*__THE_0_a_0).f, xalloc((*__THE_0_a_0).x, (*__THE_0_a_0).l), NULL, NULL, job);
    }
    case 7: {
      str_free((struct str) *__THE_0_v7_0);
      str_free((struct str) *__THE_0_v6_0);
    }
    case 8: {
      str_free((struct str) *__THE_0_v4_0);
      str_free((struct str) *__THE_0_v3_0);
      str_free((struct str) *__THE_0_v2_0);
      if (*r == 1) break;
    }
    case 9: {
      (*__THE_0_i_0)++;
      return threadpool_insert(tp, threadpool_job_step(job, 1));
    }
    case 10: {
    }
  }
  if (job->parent != NULL) threadpool_insert(tp, job->parent);
  threadpool_job_deinit(job);
}
void __THE_1_test5_0_alloc (struct __THE_1_fn$1000 *n, struct __THE_1_test5_0X x) {
  size_t l = sizeof(struct __THE_1_test5_0X);
  struct __THE_1_test5_0X *r = alloc(l);
  memcpy(r, &x, l);
  n->f = &__THE_1_test5_0;
  n->x = r;
  n->l = l;
}
void __THE_1_test6_0 (threadpool_t *tp, threadpool_job_t *job, void *px, void *pp, void *pv, int step) {
  struct __THE_1_test6_0X *x = px;
  const struct __THE_1_fn$1000 *__THE_0_a_0 = x->__THE_0_a_0;
  int32_t *__THE_0_i_0 = &x->__THE_0_i_0;
  struct str *__THE_0_v2_0 = &x->__THE_0_v2_0;
  unsigned char *r = &x->r;
  switch (step) {
    case 0: {
      *__THE_0_i_0 = 0;
    }
    case 1: {
      if (!(*__THE_0_i_0 < 10)) return threadpool_insert(tp, threadpool_job_step(job, 6));
      job->step = 2;
      return threadpool_add(tp, (*__THE_0_a_0).f, xalloc((*__THE_0_a_0).x, (*__THE_0_a_0).l), NULL, NULL, job);
    }
    case 2: {
      print(stdout, "zziz", "2 start", " ", *__THE_0_i_0, THE_EOL);
      if (!(*__THE_0_i_0 == 5)) return threadpool_insert(tp, threadpool_job_step(job, 4));
      *__THE_0_v2_0 = str_alloc("test1");
      *r = 1;
      return threadpool_insert(tp, threadpool_job_step(job, 3));
    }
    case 3: {
      str_free((struct str) *__THE_0_v2_0);
      if (*r == 1) break;
    }
    case 4: {
      print(stdout, "zziz", "2 end", " ", *__THE_0_i_0, THE_EOL);
    }
    case 5: {
      (*__THE_0_i_0)++;
      return threadpool_insert(tp, threadpool_job_step(job, 1));
    }
    case 6: {
    }
  }
  if (job->parent != NULL) threadpool_insert(tp, job->parent);
  threadpool_job_deinit(job);
}
void __THE_1_test6_0_alloc (struct __THE_1_fn$1000 *n, struct __THE_1_test6_0X x) {
  size_t l = sizeof(struct __THE_1_test6_0X);
  struct __THE_1_test6_0X *r = alloc(l);
  memcpy(r, &x, l);
  n->f = &__THE_1_test6_0;
  n->x = r;
  n->l = l;
}
void __THE_1_test7_0 (threadpool_t *tp, threadpool_job_t *job, void *px, void *pp, void *pv, int step) {
  struct __THE_1_test7_0X *x = px;
  const struct __THE_1_fn$1000 *__THE_0_a_0 = x->__THE_0_a_0;
  int32_t *__THE_0_i_0 = &x->__THE_0_i_0;
  struct str *__THE_0_v2_0 = &x->__THE_0_v2_0;
  unsigned char *r = &x->r;
  switch (step) {
    case 0: {
      *__THE_0_i_0 = 0;
    }
    case 1: {
      if (!(*__THE_0_i_0 < 10)) return threadpool_insert(tp, threadpool_job_step(job, 5));
      *__THE_0_v2_0 = str_alloc("test1");
      print(stdout, "zziz", "3 start", " ", *__THE_0_i_0, THE_EOL);
      if (!(*__THE_0_i_0 == 5)) return threadpool_insert(tp, threadpool_job_step(job, 2));
      *r = 1;
      return threadpool_insert(tp, threadpool_job_step(job, 3));
    }
    case 2: {
      print(stdout, "zziz", "3 end", " ", *__THE_0_i_0, THE_EOL);
      job->step = 3;
      return threadpool_add(tp, (*__THE_0_a_0).f, xalloc((*__THE_0_a_0).x, (*__THE_0_a_0).l), NULL, NULL, job);
    }
    case 3: {
      str_free((struct str) *__THE_0_v2_0);
      if (*r == 1) break;
    }
    case 4: {
      (*__THE_0_i_0)++;
      return threadpool_insert(tp, threadpool_job_step(job, 1));
    }
    case 5: {
    }
  }
  if (job->parent != NULL) threadpool_insert(tp, job->parent);
  threadpool_job_deinit(job);
}
void __THE_1_test7_0_alloc (struct __THE_1_fn$1000 *n, struct __THE_1_test7_0X x) {
  size_t l = sizeof(struct __THE_1_test7_0X);
  struct __THE_1_test7_0X *r = alloc(l);
  memcpy(r, &x, l);
  n->f = &__THE_1_test7_0;
  n->x = r;
  n->l = l;
}
void __THE_1_test8_0 (threadpool_t *tp, threadpool_job_t *job, void *px, void *pp, void *pv, int step) {
  struct __THE_1_test8_0X *x = px;
  const struct __THE_1_fn$1000 *__THE_0_a_0 = x->__THE_0_a_0;
  int32_t *__THE_0_i_0 = &x->__THE_0_i_0;
  unsigned char *r = &x->r;
  switch (step) {
    case 0: {
      *__THE_0_i_0 = 0;
    }
    case 1: {
      if (!(*__THE_0_i_0 < 10)) return threadpool_insert(tp, threadpool_job_step(job, 4));
      print(stdout, "zziz", "4 start", " ", *__THE_0_i_0, THE_EOL);
      if (!(*__THE_0_i_0 == 5)) return threadpool_insert(tp, threadpool_job_step(job, 2));
      *r = 1;
      break;
    }
    case 2: {
      print(stdout, "zziz", "4 end", " ", *__THE_0_i_0, THE_EOL);
      job->step = 3;
      return threadpool_add(tp, (*__THE_0_a_0).f, xalloc((*__THE_0_a_0).x, (*__THE_0_a_0).l), NULL, NULL, job);
    }
    case 3: {
      (*__THE_0_i_0)++;
      return threadpool_insert(tp, threadpool_job_step(job, 1));
    }
    case 4: {
    }
  }
  if (job->parent != NULL) threadpool_insert(tp, job->parent);
  threadpool_job_deinit(job);
}
void __THE_1_test8_0_alloc (struct __THE_1_fn$1000 *n, struct __THE_1_test8_0X x) {
  size_t l = sizeof(struct __THE_1_test8_0X);
  struct __THE_1_test8_0X *r = alloc(l);
  memcpy(r, &x, l);
  n->f = &__THE_1_test8_0;
  n->x = r;
  n->l = l;
}
void __THE_1_test9_0 (threadpool_t *tp, threadpool_job_t *job, void *px, void *pp, void *pv, int step) {
  struct __THE_1_test9_0X *x = px;
  const struct __THE_1_fn$1000 *__THE_0_a_0 = x->__THE_0_a_0;
  struct str *__THE_0_v1_0 = &x->__THE_0_v1_0;
  struct str *__THE_0_i_0 = &x->__THE_0_i_0;
  struct str *__THE_0_v2_0 = &x->__THE_0_v2_0;
  struct str *__THE_0_v3_0 = &x->__THE_0_v3_0;
  struct str *__THE_0_v4_0 = &x->__THE_0_v4_0;
  struct str *__THE_0_v5_0 = &x->__THE_0_v5_0;
  struct str *__THE_0_v6_0 = &x->__THE_0_v6_0;
  struct str *__THE_0_v7_0 = &x->__THE_0_v7_0;
  unsigned char *r = &x->r;
  switch (step) {
    case 0: {
      *__THE_0_v1_0 = str_alloc("test1");
      *__THE_0_i_0 = str_alloc("1");
    }
    case 1: {
      if (!(str_ne_cstr(str_copy(*__THE_0_i_0), "1111111111"))) return threadpool_insert(tp, threadpool_job_step(job, 10));
      *__THE_0_v2_0 = str_alloc("test2");
      job->step = 2;
      return threadpool_add(tp, (*__THE_0_a_0).f, xalloc((*__THE_0_a_0).x, (*__THE_0_a_0).l), NULL, NULL, job);
    }
    case 2: {
      *__THE_0_v3_0 = str_alloc("test3");
      print(stdout, "zzsz", "1 start", " ", str_copy(*__THE_0_i_0), THE_EOL);
      job->step = 3;
      return threadpool_add(tp, (*__THE_0_a_0).f, xalloc((*__THE_0_a_0).x, (*__THE_0_a_0).l), NULL, NULL, job);
    }
    case 3: {
      *__THE_0_v4_0 = str_alloc("test4");
      if (!(str_eq_cstr(str_copy(*__THE_0_i_0), "11111"))) return threadpool_insert(tp, threadpool_job_step(job, 5));
      *__THE_0_v5_0 = str_alloc("test5");
      *r = 1;
      return threadpool_insert(tp, threadpool_job_step(job, 4));
    }
    case 4: {
      str_free((struct str) *__THE_0_v5_0);
      if (*r == 1) return threadpool_insert(tp, threadpool_job_step(job, 8));
    }
    case 5: {
      *__THE_0_v6_0 = str_alloc("test6");
      job->step = 6;
      return threadpool_add(tp, (*__THE_0_a_0).f, xalloc((*__THE_0_a_0).x, (*__THE_0_a_0).l), NULL, NULL, job);
    }
    case 6: {
      print(stdout, "zzsz", "1 end", " ", str_copy(*__THE_0_i_0), THE_EOL);
      *__THE_0_v7_0 = str_alloc("test7");
      job->step = 7;
      return threadpool_add(tp, (*__THE_0_a_0).f, xalloc((*__THE_0_a_0).x, (*__THE_0_a_0).l), NULL, NULL, job);
    }
    case 7: {
      str_free((struct str) *__THE_0_v7_0);
      str_free((struct str) *__THE_0_v6_0);
    }
    case 8: {
      str_free((struct str) *__THE_0_v4_0);
      str_free((struct str) *__THE_0_v3_0);
      str_free((struct str) *__THE_0_v2_0);
      if (*r == 1) return threadpool_insert(tp, threadpool_job_step(job, 10));
    }
    case 9: {
      *__THE_0_i_0 = str_realloc(*__THE_0_i_0, str_concat_cstr(str_copy(*__THE_0_i_0), "1"));
      return threadpool_insert(tp, threadpool_job_step(job, 1));
    }
    case 10: {
      str_free((struct str) *__THE_0_i_0);
      if (*r == 1) return threadpool_insert(tp, threadpool_job_step(job, 11));
    }
    case 11: {
      str_free((struct str) *__THE_0_v1_0);
    }
  }
  if (job->parent != NULL) threadpool_insert(tp, job->parent);
  threadpool_job_deinit(job);
}
void __THE_1_test9_0_alloc (struct __THE_1_fn$1000 *n, struct __THE_1_test9_0X x) {
  size_t l = sizeof(struct __THE_1_test9_0X);
  struct __THE_1_test9_0X *r = alloc(l);
  memcpy(r, &x, l);
  n->f = &__THE_1_test9_0;
  n->x = r;
  n->l = l;
}
void __THE_1_test10_0 (threadpool_t *tp, threadpool_job_t *job, void *px, void *pp, void *pv, int step) {
  struct __THE_1_test10_0X *x = px;
  const struct __THE_1_fn$1000 *__THE_0_a_0 = x->__THE_0_a_0;
  struct str *__THE_0_v1_0 = &x->__THE_0_v1_0;
  struct str *__THE_0_i_0 = &x->__THE_0_i_0;
  struct str *__THE_0_v2_0 = &x->__THE_0_v2_0;
  unsigned char *r = &x->r;
  switch (step) {
    case 0: {
      *__THE_0_v1_0 = str_alloc("test1");
      *__THE_0_i_0 = str_alloc("1");
    }
    case 1: {
      if (!(str_ne_cstr(str_copy(*__THE_0_i_0), "1111111111"))) return threadpool_insert(tp, threadpool_job_step(job, 6));
      job->step = 2;
      return threadpool_add(tp, (*__THE_0_a_0).f, xalloc((*__THE_0_a_0).x, (*__THE_0_a_0).l), NULL, NULL, job);
    }
    case 2: {
      print(stdout, "zzsz", "2 start", " ", str_copy(*__THE_0_i_0), THE_EOL);
      if (!(str_eq_cstr(str_copy(*__THE_0_i_0), "11111"))) return threadpool_insert(tp, threadpool_job_step(job, 4));
      *__THE_0_v2_0 = str_alloc("test1");
      *r = 1;
      return threadpool_insert(tp, threadpool_job_step(job, 3));
    }
    case 3: {
      str_free((struct str) *__THE_0_v2_0);
      if (*r == 1) return threadpool_insert(tp, threadpool_job_step(job, 6));
    }
    case 4: {
      print(stdout, "zzsz", "2 end", " ", str_copy(*__THE_0_i_0), THE_EOL);
    }
    case 5: {
      *__THE_0_i_0 = str_realloc(*__THE_0_i_0, str_concat_cstr(str_copy(*__THE_0_i_0), "1"));
      return threadpool_insert(tp, threadpool_job_step(job, 1));
    }
    case 6: {
      str_free((struct str) *__THE_0_i_0);
      if (*r == 1) return threadpool_insert(tp, threadpool_job_step(job, 7));
    }
    case 7: {
      str_free((struct str) *__THE_0_v1_0);
    }
  }
  if (job->parent != NULL) threadpool_insert(tp, job->parent);
  threadpool_job_deinit(job);
}
void __THE_1_test10_0_alloc (struct __THE_1_fn$1000 *n, struct __THE_1_test10_0X x) {
  size_t l = sizeof(struct __THE_1_test10_0X);
  struct __THE_1_test10_0X *r = alloc(l);
  memcpy(r, &x, l);
  n->f = &__THE_1_test10_0;
  n->x = r;
  n->l = l;
}
void __THE_1_test11_0 (threadpool_t *tp, threadpool_job_t *job, void *px, void *pp, void *pv, int step) {
  struct __THE_1_test11_0X *x = px;
  const struct __THE_1_fn$1000 *__THE_0_a_0 = x->__THE_0_a_0;
  struct str *__THE_0_v1_0 = &x->__THE_0_v1_0;
  struct str *__THE_0_i_0 = &x->__THE_0_i_0;
  struct str *__THE_0_v2_0 = &x->__THE_0_v2_0;
  unsigned char *r = &x->r;
  switch (step) {
    case 0: {
      *__THE_0_v1_0 = str_alloc("test1");
      *__THE_0_i_0 = str_alloc("1");
    }
    case 1: {
      if (!(str_ne_cstr(str_copy(*__THE_0_i_0), "1111111111"))) return threadpool_insert(tp, threadpool_job_step(job, 5));
      *__THE_0_v2_0 = str_alloc("test1");
      print(stdout, "zzsz", "3 start", " ", str_copy(*__THE_0_i_0), THE_EOL);
      if (!(str_eq_cstr(str_copy(*__THE_0_i_0), "11111"))) return threadpool_insert(tp, threadpool_job_step(job, 2));
      *r = 1;
      return threadpool_insert(tp, threadpool_job_step(job, 3));
    }
    case 2: {
      print(stdout, "zzsz", "3 end", " ", str_copy(*__THE_0_i_0), THE_EOL);
      job->step = 3;
      return threadpool_add(tp, (*__THE_0_a_0).f, xalloc((*__THE_0_a_0).x, (*__THE_0_a_0).l), NULL, NULL, job);
    }
    case 3: {
      str_free((struct str) *__THE_0_v2_0);
      if (*r == 1) return threadpool_insert(tp, threadpool_job_step(job, 5));
    }
    case 4: {
      *__THE_0_i_0 = str_realloc(*__THE_0_i_0, str_concat_cstr(str_copy(*__THE_0_i_0), "1"));
      return threadpool_insert(tp, threadpool_job_step(job, 1));
    }
    case 5: {
      str_free((struct str) *__THE_0_i_0);
      if (*r == 1) return threadpool_insert(tp, threadpool_job_step(job, 6));
    }
    case 6: {
      str_free((struct str) *__THE_0_v1_0);
    }
  }
  if (job->parent != NULL) threadpool_insert(tp, job->parent);
  threadpool_job_deinit(job);
}
void __THE_1_test11_0_alloc (struct __THE_1_fn$1000 *n, struct __THE_1_test11_0X x) {
  size_t l = sizeof(struct __THE_1_test11_0X);
  struct __THE_1_test11_0X *r = alloc(l);
  memcpy(r, &x, l);
  n->f = &__THE_1_test11_0;
  n->x = r;
  n->l = l;
}
void __THE_1_test12_0 (threadpool_t *tp, threadpool_job_t *job, void *px, void *pp, void *pv, int step) {
  struct __THE_1_test12_0X *x = px;
  const struct __THE_1_fn$1000 *__THE_0_a_0 = x->__THE_0_a_0;
  struct str *__THE_0_v1_0 = &x->__THE_0_v1_0;
  struct str *__THE_0_i_0 = &x->__THE_0_i_0;
  unsigned char *r = &x->r;
  switch (step) {
    case 0: {
      *__THE_0_v1_0 = str_alloc("test1");
      *__THE_0_i_0 = str_alloc("1");
    }
    case 1: {
      if (!(str_ne_cstr(str_copy(*__THE_0_i_0), "1111111111"))) return threadpool_insert(tp, threadpool_job_step(job, 4));
      print(stdout, "zzsz", "4 start", " ", str_copy(*__THE_0_i_0), THE_EOL);
      if (!(str_eq_cstr(str_copy(*__THE_0_i_0), "11111"))) return threadpool_insert(tp, threadpool_job_step(job, 2));
      *r = 1;
      return threadpool_insert(tp, threadpool_job_step(job, 4));
    }
    case 2: {
      print(stdout, "zzsz", "4 end", " ", str_copy(*__THE_0_i_0), THE_EOL);
      job->step = 3;
      return threadpool_add(tp, (*__THE_0_a_0).f, xalloc((*__THE_0_a_0).x, (*__THE_0_a_0).l), NULL, NULL, job);
    }
    case 3: {
      *__THE_0_i_0 = str_realloc(*__THE_0_i_0, str_concat_cstr(str_copy(*__THE_0_i_0), "1"));
      return threadpool_insert(tp, threadpool_job_step(job, 1));
    }
    case 4: {
      str_free((struct str) *__THE_0_i_0);
      if (*r == 1) return threadpool_insert(tp, threadpool_job_step(job, 5));
    }
    case 5: {
      str_free((struct str) *__THE_0_v1_0);
    }
  }
  if (job->parent != NULL) threadpool_insert(tp, job->parent);
  threadpool_job_deinit(job);
}
void __THE_1_test12_0_alloc (struct __THE_1_fn$1000 *n, struct __THE_1_test12_0X x) {
  size_t l = sizeof(struct __THE_1_test12_0X);
  struct __THE_1_test12_0X *r = alloc(l);
  memcpy(r, &x, l);
  n->f = &__THE_1_test12_0;
  n->x = r;
  n->l = l;
}
void __THE_1_test13_0 (threadpool_t *tp, threadpool_job_t *job, void *px, void *pp, void *pv, int step) {
  struct __THE_1_test13_0X *x = px;
  const struct __THE_1_fn$1000 *__THE_0_a_0 = x->__THE_0_a_0;
  struct str *__THE_0_i_0 = &x->__THE_0_i_0;
  struct str *__THE_0_v2_0 = &x->__THE_0_v2_0;
  struct str *__THE_0_v3_0 = &x->__THE_0_v3_0;
  struct str *__THE_0_v4_0 = &x->__THE_0_v4_0;
  struct str *__THE_0_v5_0 = &x->__THE_0_v5_0;
  struct str *__THE_0_v6_0 = &x->__THE_0_v6_0;
  struct str *__THE_0_v7_0 = &x->__THE_0_v7_0;
  unsigned char *r = &x->r;
  switch (step) {
    case 0: {
      *__THE_0_i_0 = str_alloc("1");
    }
    case 1: {
      if (!(str_ne_cstr(str_copy(*__THE_0_i_0), "1111111111"))) return threadpool_insert(tp, threadpool_job_step(job, 10));
      *__THE_0_v2_0 = str_alloc("test2");
      job->step = 2;
      return threadpool_add(tp, (*__THE_0_a_0).f, xalloc((*__THE_0_a_0).x, (*__THE_0_a_0).l), NULL, NULL, job);
    }
    case 2: {
      *__THE_0_v3_0 = str_alloc("test3");
      print(stdout, "zzsz", "1 start", " ", str_copy(*__THE_0_i_0), THE_EOL);
      job->step = 3;
      return threadpool_add(tp, (*__THE_0_a_0).f, xalloc((*__THE_0_a_0).x, (*__THE_0_a_0).l), NULL, NULL, job);
    }
    case 3: {
      *__THE_0_v4_0 = str_alloc("test4");
      if (!(str_eq_cstr(str_copy(*__THE_0_i_0), "11111"))) return threadpool_insert(tp, threadpool_job_step(job, 5));
      *__THE_0_v5_0 = str_alloc("test5");
      *r = 1;
      return threadpool_insert(tp, threadpool_job_step(job, 4));
    }
    case 4: {
      str_free((struct str) *__THE_0_v5_0);
      if (*r == 1) return threadpool_insert(tp, threadpool_job_step(job, 8));
    }
    case 5: {
      *__THE_0_v6_0 = str_alloc("test6");
      job->step = 6;
      return threadpool_add(tp, (*__THE_0_a_0).f, xalloc((*__THE_0_a_0).x, (*__THE_0_a_0).l), NULL, NULL, job);
    }
    case 6: {
      print(stdout, "zzsz", "1 end", " ", str_copy(*__THE_0_i_0), THE_EOL);
      *__THE_0_v7_0 = str_alloc("test7");
      job->step = 7;
      return threadpool_add(tp, (*__THE_0_a_0).f, xalloc((*__THE_0_a_0).x, (*__THE_0_a_0).l), NULL, NULL, job);
    }
    case 7: {
      str_free((struct str) *__THE_0_v7_0);
      str_free((struct str) *__THE_0_v6_0);
    }
    case 8: {
      str_free((struct str) *__THE_0_v4_0);
      str_free((struct str) *__THE_0_v3_0);
      str_free((struct str) *__THE_0_v2_0);
      if (*r == 1) return threadpool_insert(tp, threadpool_job_step(job, 10));
    }
    case 9: {
      *__THE_0_i_0 = str_realloc(*__THE_0_i_0, str_concat_cstr(str_copy(*__THE_0_i_0), "1"));
      return threadpool_insert(tp, threadpool_job_step(job, 1));
    }
    case 10: {
      str_free((struct str) *__THE_0_i_0);
      if (*r == 1) break;
    }
    case 11: {
    }
  }
  if (job->parent != NULL) threadpool_insert(tp, job->parent);
  threadpool_job_deinit(job);
}
void __THE_1_test13_0_alloc (struct __THE_1_fn$1000 *n, struct __THE_1_test13_0X x) {
  size_t l = sizeof(struct __THE_1_test13_0X);
  struct __THE_1_test13_0X *r = alloc(l);
  memcpy(r, &x, l);
  n->f = &__THE_1_test13_0;
  n->x = r;
  n->l = l;
}
void __THE_1_test14_0 (threadpool_t *tp, threadpool_job_t *job, void *px, void *pp, void *pv, int step) {
  struct __THE_1_test14_0X *x = px;
  const struct __THE_1_fn$1000 *__THE_0_a_0 = x->__THE_0_a_0;
  struct str *__THE_0_i_0 = &x->__THE_0_i_0;
  struct str *__THE_0_v2_0 = &x->__THE_0_v2_0;
  unsigned char *r = &x->r;
  switch (step) {
    case 0: {
      *__THE_0_i_0 = str_alloc("1");
    }
    case 1: {
      if (!(str_ne_cstr(str_copy(*__THE_0_i_0), "1111111111"))) return threadpool_insert(tp, threadpool_job_step(job, 6));
      job->step = 2;
      return threadpool_add(tp, (*__THE_0_a_0).f, xalloc((*__THE_0_a_0).x, (*__THE_0_a_0).l), NULL, NULL, job);
    }
    case 2: {
      print(stdout, "zzsz", "2 start", " ", str_copy(*__THE_0_i_0), THE_EOL);
      if (!(str_eq_cstr(str_copy(*__THE_0_i_0), "11111"))) return threadpool_insert(tp, threadpool_job_step(job, 4));
      *__THE_0_v2_0 = str_alloc("test1");
      *r = 1;
      return threadpool_insert(tp, threadpool_job_step(job, 3));
    }
    case 3: {
      str_free((struct str) *__THE_0_v2_0);
      if (*r == 1) return threadpool_insert(tp, threadpool_job_step(job, 6));
    }
    case 4: {
      print(stdout, "zzsz", "2 end", " ", str_copy(*__THE_0_i_0), THE_EOL);
    }
    case 5: {
      *__THE_0_i_0 = str_realloc(*__THE_0_i_0, str_concat_cstr(str_copy(*__THE_0_i_0), "1"));
      return threadpool_insert(tp, threadpool_job_step(job, 1));
    }
    case 6: {
      str_free((struct str) *__THE_0_i_0);
      if (*r == 1) break;
    }
    case 7: {
    }
  }
  if (job->parent != NULL) threadpool_insert(tp, job->parent);
  threadpool_job_deinit(job);
}
void __THE_1_test14_0_alloc (struct __THE_1_fn$1000 *n, struct __THE_1_test14_0X x) {
  size_t l = sizeof(struct __THE_1_test14_0X);
  struct __THE_1_test14_0X *r = alloc(l);
  memcpy(r, &x, l);
  n->f = &__THE_1_test14_0;
  n->x = r;
  n->l = l;
}
void __THE_1_test15_0 (threadpool_t *tp, threadpool_job_t *job, void *px, void *pp, void *pv, int step) {
  struct __THE_1_test15_0X *x = px;
  const struct __THE_1_fn$1000 *__THE_0_a_0 = x->__THE_0_a_0;
  struct str *__THE_0_i_0 = &x->__THE_0_i_0;
  struct str *__THE_0_v2_0 = &x->__THE_0_v2_0;
  unsigned char *r = &x->r;
  switch (step) {
    case 0: {
      *__THE_0_i_0 = str_alloc("1");
    }
    case 1: {
      if (!(str_ne_cstr(str_copy(*__THE_0_i_0), "1111111111"))) return threadpool_insert(tp, threadpool_job_step(job, 5));
      *__THE_0_v2_0 = str_alloc("test1");
      print(stdout, "zzsz", "3 start", " ", str_copy(*__THE_0_i_0), THE_EOL);
      if (!(str_eq_cstr(str_copy(*__THE_0_i_0), "11111"))) return threadpool_insert(tp, threadpool_job_step(job, 2));
      *r = 1;
      return threadpool_insert(tp, threadpool_job_step(job, 3));
    }
    case 2: {
      print(stdout, "zzsz", "3 end", " ", str_copy(*__THE_0_i_0), THE_EOL);
      job->step = 3;
      return threadpool_add(tp, (*__THE_0_a_0).f, xalloc((*__THE_0_a_0).x, (*__THE_0_a_0).l), NULL, NULL, job);
    }
    case 3: {
      str_free((struct str) *__THE_0_v2_0);
      if (*r == 1) return threadpool_insert(tp, threadpool_job_step(job, 5));
    }
    case 4: {
      *__THE_0_i_0 = str_realloc(*__THE_0_i_0, str_concat_cstr(str_copy(*__THE_0_i_0), "1"));
      return threadpool_insert(tp, threadpool_job_step(job, 1));
    }
    case 5: {
      str_free((struct str) *__THE_0_i_0);
      if (*r == 1) break;
    }
    case 6: {
    }
  }
  if (job->parent != NULL) threadpool_insert(tp, job->parent);
  threadpool_job_deinit(job);
}
void __THE_1_test15_0_alloc (struct __THE_1_fn$1000 *n, struct __THE_1_test15_0X x) {
  size_t l = sizeof(struct __THE_1_test15_0X);
  struct __THE_1_test15_0X *r = alloc(l);
  memcpy(r, &x, l);
  n->f = &__THE_1_test15_0;
  n->x = r;
  n->l = l;
}
void __THE_1_test16_0 (threadpool_t *tp, threadpool_job_t *job, void *px, void *pp, void *pv, int step) {
  struct __THE_1_test16_0X *x = px;
  const struct __THE_1_fn$1000 *__THE_0_a_0 = x->__THE_0_a_0;
  struct str *__THE_0_i_0 = &x->__THE_0_i_0;
  unsigned char *r = &x->r;
  switch (step) {
    case 0: {
      *__THE_0_i_0 = str_alloc("1");
    }
    case 1: {
      if (!(str_ne_cstr(str_copy(*__THE_0_i_0), "1111111111"))) return threadpool_insert(tp, threadpool_job_step(job, 4));
      print(stdout, "zzsz", "4 start", " ", str_copy(*__THE_0_i_0), THE_EOL);
      if (!(str_eq_cstr(str_copy(*__THE_0_i_0), "11111"))) return threadpool_insert(tp, threadpool_job_step(job, 2));
      *r = 1;
      return threadpool_insert(tp, threadpool_job_step(job, 4));
    }
    case 2: {
      print(stdout, "zzsz", "4 end", " ", str_copy(*__THE_0_i_0), THE_EOL);
      job->step = 3;
      return threadpool_add(tp, (*__THE_0_a_0).f, xalloc((*__THE_0_a_0).x, (*__THE_0_a_0).l), NULL, NULL, job);
    }
    case 3: {
      *__THE_0_i_0 = str_realloc(*__THE_0_i_0, str_concat_cstr(str_copy(*__THE_0_i_0), "1"));
      return threadpool_insert(tp, threadpool_job_step(job, 1));
    }
    case 4: {
      str_free((struct str) *__THE_0_i_0);
      if (*r == 1) break;
    }
    case 5: {
    }
  }
  if (job->parent != NULL) threadpool_insert(tp, job->parent);
  threadpool_job_deinit(job);
}
void __THE_1_test16_0_alloc (struct __THE_1_fn$1000 *n, struct __THE_1_test16_0X x) {
  size_t l = sizeof(struct __THE_1_test16_0X);
  struct __THE_1_test16_0X *r = alloc(l);
  memcpy(r, &x, l);
  n->f = &__THE_1_test16_0;
  n->x = r;
  n->l = l;
}
void __THE_1_async_main (threadpool_t *tp, threadpool_job_t *job, void *px, void *pp, void *pv, int step) {
  struct __THE_1_async_mainX *x = px;
  const struct __THE_1_fn$1000 *__THE_0_test16_0 = x->__THE_0_test16_0;
  const struct __THE_1_fn$1000 *__THE_0_test15_0 = x->__THE_0_test15_0;
  const struct __THE_1_fn$1000 *__THE_0_test14_0 = x->__THE_0_test14_0;
  const struct __THE_1_fn$1000 *__THE_0_test13_0 = x->__THE_0_test13_0;
  const struct __THE_1_fn$1000 *__THE_0_test12_0 = x->__THE_0_test12_0;
  const struct __THE_1_fn$1000 *__THE_0_test11_0 = x->__THE_0_test11_0;
  const struct __THE_1_fn$1000 *__THE_0_test10_0 = x->__THE_0_test10_0;
  const struct __THE_1_fn$1000 *__THE_0_test9_0 = x->__THE_0_test9_0;
  const struct __THE_1_fn$1000 *__THE_0_test8_0 = x->__THE_0_test8_0;
  const struct __THE_1_fn$1000 *__THE_0_test7_0 = x->__THE_0_test7_0;
  const struct __THE_1_fn$1000 *__THE_0_test6_0 = x->__THE_0_test6_0;
  const struct __THE_1_fn$1000 *__THE_0_test5_0 = x->__THE_0_test5_0;
  const struct __THE_1_fn$1000 *__THE_0_test4_0 = x->__THE_0_test4_0;
  const struct __THE_1_fn$1000 *__THE_0_test3_0 = x->__THE_0_test3_0;
  const struct __THE_1_fn$1000 *__THE_0_test2_0 = x->__THE_0_test2_0;
  const struct __THE_1_fn$1000 *__THE_0_test1_0 = x->__THE_0_test1_0;
  switch (step) {
    case 0: {
      job->step = 1;
      return threadpool_add(tp, (*__THE_0_test1_0).f, xalloc((*__THE_0_test1_0).x, (*__THE_0_test1_0).l), NULL, NULL, job);
    }
    case 1: {
      job->step = 2;
      return threadpool_add(tp, (*__THE_0_test2_0).f, xalloc((*__THE_0_test2_0).x, (*__THE_0_test2_0).l), NULL, NULL, job);
    }
    case 2: {
      job->step = 3;
      return threadpool_add(tp, (*__THE_0_test3_0).f, xalloc((*__THE_0_test3_0).x, (*__THE_0_test3_0).l), NULL, NULL, job);
    }
    case 3: {
      job->step = 4;
      return threadpool_add(tp, (*__THE_0_test4_0).f, xalloc((*__THE_0_test4_0).x, (*__THE_0_test4_0).l), NULL, NULL, job);
    }
    case 4: {
      job->step = 5;
      return threadpool_add(tp, (*__THE_0_test5_0).f, xalloc((*__THE_0_test5_0).x, (*__THE_0_test5_0).l), NULL, NULL, job);
    }
    case 5: {
      job->step = 6;
      return threadpool_add(tp, (*__THE_0_test6_0).f, xalloc((*__THE_0_test6_0).x, (*__THE_0_test6_0).l), NULL, NULL, job);
    }
    case 6: {
      job->step = 7;
      return threadpool_add(tp, (*__THE_0_test7_0).f, xalloc((*__THE_0_test7_0).x, (*__THE_0_test7_0).l), NULL, NULL, job);
    }
    case 7: {
      job->step = 8;
      return threadpool_add(tp, (*__THE_0_test8_0).f, xalloc((*__THE_0_test8_0).x, (*__THE_0_test8_0).l), NULL, NULL, job);
    }
    case 8: {
      job->step = 9;
      return threadpool_add(tp, (*__THE_0_test9_0).f, xalloc((*__THE_0_test9_0).x, (*__THE_0_test9_0).l), NULL, NULL, job);
    }
    case 9: {
      job->step = 10;
      return threadpool_add(tp, (*__THE_0_test10_0).f, xalloc((*__THE_0_test10_0).x, (*__THE_0_test10_0).l), NULL, NULL, job);
    }
    case 10: {
      job->step = 11;
      return threadpool_add(tp, (*__THE_0_test11_0).f, xalloc((*__THE_0_test11_0).x, (*__THE_0_test11_0).l), NULL, NULL, job);
    }
    case 11: {
      job->step = 12;
      return threadpool_add(tp, (*__THE_0_test12_0).f, xalloc((*__THE_0_test12_0).x, (*__THE_0_test12_0).l), NULL, NULL, job);
    }
    case 12: {
      job->step = 13;
      return threadpool_add(tp, (*__THE_0_test13_0).f, xalloc((*__THE_0_test13_0).x, (*__THE_0_test13_0).l), NULL, NULL, job);
    }
    case 13: {
      job->step = 14;
      return threadpool_add(tp, (*__THE_0_test14_0).f, xalloc((*__THE_0_test14_0).x, (*__THE_0_test14_0).l), NULL, NULL, job);
    }
    case 14: {
      job->step = 15;
      return threadpool_add(tp, (*__THE_0_test15_0).f, xalloc((*__THE_0_test15_0).x, (*__THE_0_test15_0).l), NULL, NULL, job);
    }
    case 15: {
      job->step = 16;
      return threadpool_add(tp, (*__THE_0_test16_0).f, xalloc((*__THE_0_test16_0).x, (*__THE_0_test16_0).l), NULL, NULL, job);
    }
    case 16: {
    }
  }
  if (job->parent != NULL) threadpool_insert(tp, job->parent);
  threadpool_job_deinit(job);
}
void __THE_1_async_main_alloc (struct __THE_1_fn$1000 *n, struct __THE_1_async_mainX x) {
  size_t l = sizeof(struct __THE_1_async_mainX);
  struct __THE_1_async_mainX *r = alloc(l);
  memcpy(r, &x, l);
  n->f = &__THE_1_async_main;
  n->x = r;
  n->l = l;
}

int main () {
  threadpool_t *tp = threadpool_init(5);
  const struct __THE_1_fn$1000 __THE_0_a_0 = (struct __THE_1_fn$1000) {&__THE_1_a_0, NULL, 0};
  const struct __THE_1_fn$1000 __THE_0_test1_0;
  const struct __THE_1_fn$1000 __THE_0_test2_0;
  const struct __THE_1_fn$1000 __THE_0_test3_0;
  const struct __THE_1_fn$1000 __THE_0_test4_0;
  const struct __THE_1_fn$1000 __THE_0_test5_0;
  const struct __THE_1_fn$1000 __THE_0_test6_0;
  const struct __THE_1_fn$1000 __THE_0_test7_0;
  const struct __THE_1_fn$1000 __THE_0_test8_0;
  const struct __THE_1_fn$1000 __THE_0_test9_0;
  const struct __THE_1_fn$1000 __THE_0_test10_0;
  const struct __THE_1_fn$1000 __THE_0_test11_0;
  const struct __THE_1_fn$1000 __THE_0_test12_0;
  const struct __THE_1_fn$1000 __THE_0_test13_0;
  const struct __THE_1_fn$1000 __THE_0_test14_0;
  const struct __THE_1_fn$1000 __THE_0_test15_0;
  const struct __THE_1_fn$1000 __THE_0_test16_0;
  __THE_1_test1_0_alloc((struct __THE_1_fn$1000 *) &__THE_0_test1_0, (struct __THE_1_test1_0X) {&__THE_0_a_0});
  __THE_1_test2_0_alloc((struct __THE_1_fn$1000 *) &__THE_0_test2_0, (struct __THE_1_test2_0X) {&__THE_0_a_0});
  __THE_1_test3_0_alloc((struct __THE_1_fn$1000 *) &__THE_0_test3_0, (struct __THE_1_test3_0X) {&__THE_0_a_0});
  __THE_1_test4_0_alloc((struct __THE_1_fn$1000 *) &__THE_0_test4_0, (struct __THE_1_test4_0X) {&__THE_0_a_0});
  __THE_1_test5_0_alloc((struct __THE_1_fn$1000 *) &__THE_0_test5_0, (struct __THE_1_test5_0X) {&__THE_0_a_0});
  __THE_1_test6_0_alloc((struct __THE_1_fn$1000 *) &__THE_0_test6_0, (struct __THE_1_test6_0X) {&__THE_0_a_0});
  __THE_1_test7_0_alloc((struct __THE_1_fn$1000 *) &__THE_0_test7_0, (struct __THE_1_test7_0X) {&__THE_0_a_0});
  __THE_1_test8_0_alloc((struct __THE_1_fn$1000 *) &__THE_0_test8_0, (struct __THE_1_test8_0X) {&__THE_0_a_0});
  __THE_1_test9_0_alloc((struct __THE_1_fn$1000 *) &__THE_0_test9_0, (struct __THE_1_test9_0X) {&__THE_0_a_0});
  __THE_1_test10_0_alloc((struct __THE_1_fn$1000 *) &__THE_0_test10_0, (struct __THE_1_test10_0X) {&__THE_0_a_0});
  __THE_1_test11_0_alloc((struct __THE_1_fn$1000 *) &__THE_0_test11_0, (struct __THE_1_test11_0X) {&__THE_0_a_0});
  __THE_1_test12_0_alloc((struct __THE_1_fn$1000 *) &__THE_0_test12_0, (struct __THE_1_test12_0X) {&__THE_0_a_0});
  __THE_1_test13_0_alloc((struct __THE_1_fn$1000 *) &__THE_0_test13_0, (struct __THE_1_test13_0X) {&__THE_0_a_0});
  __THE_1_test14_0_alloc((struct __THE_1_fn$1000 *) &__THE_0_test14_0, (struct __THE_1_test14_0X) {&__THE_0_a_0});
  __THE_1_test15_0_alloc((struct __THE_1_fn$1000 *) &__THE_0_test15_0, (struct __THE_1_test15_0X) {&__THE_0_a_0});
  __THE_1_test16_0_alloc((struct __THE_1_fn$1000 *) &__THE_0_test16_0, (struct __THE_1_test16_0X) {&__THE_0_a_0});
  const struct __THE_1_fn$1000 async_main;
  __THE_1_async_main_alloc((struct __THE_1_fn$1000 *) &async_main, (struct __THE_1_async_mainX) {&__THE_0_test16_0, &__THE_0_test15_0, &__THE_0_test14_0, &__THE_0_test13_0, &__THE_0_test12_0, &__THE_0_test11_0, &__THE_0_test10_0, &__THE_0_test9_0, &__THE_0_test8_0, &__THE_0_test7_0, &__THE_0_test6_0, &__THE_0_test5_0, &__THE_0_test4_0, &__THE_0_test3_0, &__THE_0_test2_0, &__THE_0_test1_0});
  threadpool_add(tp, async_main.f, xalloc(async_main.x, async_main.l), NULL, NULL, NULL);
  threadpool_wait(tp);
  threadpool_deinit(tp);
  __THE_1_fn$1000_free((struct __THE_1_fn$1000) async_main);
  __THE_1_fn$1000_free((struct __THE_1_fn$1000) __THE_0_test16_0);
  __THE_1_fn$1000_free((struct __THE_1_fn$1000) __THE_0_test15_0);
  __THE_1_fn$1000_free((struct __THE_1_fn$1000) __THE_0_test14_0);
  __THE_1_fn$1000_free((struct __THE_1_fn$1000) __THE_0_test13_0);
  __THE_1_fn$1000_free((struct __THE_1_fn$1000) __THE_0_test12_0);
  __THE_1_fn$1000_free((struct __THE_1_fn$1000) __THE_0_test11_0);
  __THE_1_fn$1000_free((struct __THE_1_fn$1000) __THE_0_test10_0);
  __THE_1_fn$1000_free((struct __THE_1_fn$1000) __THE_0_test9_0);
  __THE_1_fn$1000_free((struct __THE_1_fn$1000) __THE_0_test8_0);
  __THE_1_fn$1000_free((struct __THE_1_fn$1000) __THE_0_test7_0);
  __THE_1_fn$1000_free((struct __THE_1_fn$1000) __THE_0_test6_0);
  __THE_1_fn$1000_free((struct __THE_1_fn$1000) __THE_0_test5_0);
  __THE_1_fn$1000_free((struct __THE_1_fn$1000) __THE_0_test4_0);
  __THE_1_fn$1000_free((struct __THE_1_fn$1000) __THE_0_test3_0);
  __THE_1_fn$1000_free((struct __THE_1_fn$1000) __THE_0_test2_0);
  __THE_1_fn$1000_free((struct __THE_1_fn$1000) __THE_0_test1_0);
  pthread_exit(NULL);
}
======= flags =======
U:-pthread
======= stdout =======
1 start 0
1 end 0
1 start 1
1 end 1
1 start 2
1 end 2
1 start 3
1 end 3
1 start 4
1 end 4
1 start 5
2 start 0
2 end 0
2 start 1
2 end 1
2 start 2
2 end 2
2 start 3
2 end 3
2 start 4
2 end 4
2 start 5
3 start 0
3 end 0
3 start 1
3 end 1
3 start 2
3 end 2
3 start 3
3 end 3
3 start 4
3 end 4
3 start 5
4 start 0
4 end 0
4 start 1
4 end 1
4 start 2
4 end 2
4 start 3
4 end 3
4 start 4
4 end 4
4 start 5
1 start 0
1 end 0
1 start 1
1 end 1
1 start 2
1 end 2
1 start 3
1 end 3
1 start 4
1 end 4
1 start 5
2 start 0
2 end 0
2 start 1
2 end 1
2 start 2
2 end 2
2 start 3
2 end 3
2 start 4
2 end 4
2 start 5
3 start 0
3 end 0
3 start 1
3 end 1
3 start 2
3 end 2
3 start 3
3 end 3
3 start 4
3 end 4
3 start 5
4 start 0
4 end 0
4 start 1
4 end 1
4 start 2
4 end 2
4 start 3
4 end 3
4 start 4
4 end 4
4 start 5
1 start 1
1 end 1
1 start 11
1 end 11
1 start 111
1 end 111
1 start 1111
1 end 1111
1 start 11111
2 start 1
2 end 1
2 start 11
2 end 11
2 start 111
2 end 111
2 start 1111
2 end 1111
2 start 11111
3 start 1
3 end 1
3 start 11
3 end 11
3 start 111
3 end 111
3 start 1111
3 end 1111
3 start 11111
4 start 1
4 end 1
4 start 11
4 end 11
4 start 111
4 end 111
4 start 1111
4 end 1111
4 start 11111
1 start 1
1 end 1
1 start 11
1 end 11
1 start 111
1 end 111
1 start 1111
1 end 1111
1 start 11111
2 start 1
2 end 1
2 start 11
2 end 11
2 start 111
2 end 111
2 start 1111
2 end 1111
2 start 11111
3 start 1
3 end 1
3 start 11
3 end 11
3 start 111
3 end 111
3 start 1111
3 end 1111
3 start 11111
4 start 1
4 end 1
4 start 11
4 end 11
4 start 111
4 end 111
4 start 1111
4 end 1111
4 start 11111
