======= stdin =======
main {
  mut url := "https://httpbin.org/status/200"
  mut req := request_open("GET", url)
  mut res := request_read(ref req)
  print("GET", url, res.status)
  request_close(ref req)

  url = "https://httpbin.org/status/400"
  req = request_open("GET", url)
  res = request_read(ref req)
  print("GET", url, res.status)
  request_close(ref req)

  url = "https://httpbin.org/status/500"
  req = request_open("GET", url)
  res = request_read(ref req)
  print("GET", url, res.status)
  request_close(ref req)

  print()

  req = request_open("POST", "https://httpbin.org/anything", data: "".toBuffer(), headers: [])
  res = request_read(ref req)
  print(res.data.str())
  request_close(ref req)

  req = request_open("POST", "https://httpbin.org/anything", data: "test".toBuffer())
  res = request_read(ref req)
  print(res.data.str())
  request_close(ref req)

  req = request_open(
    "POST",
    "https://httpbin.org/anything",
    data: "test1=value1&test2=value2".toBuffer(),
    headers: [
      request_Header{name: "content-type", value: "application/x-www-form-urlencoded"},
      request_Header{name: "custom-header", value: "custom-value"}
    ]
  )

  res = request_read(ref req)
  print(res.data.str())
  request_close(ref req)
}
======= code =======
#if defined(WIN32) || defined(_WIN32) || defined(__WIN32) || defined(__WIN32__)
  #define THE_OS_WINDOWS
  #define THE_EOL "\r\n"
  #define THE_PATH_SEP "\\"
#else
  #if defined(__APPLE__)
    #define THE_OS_MACOS
  #elif defined(__linux__)
    #define THE_OS_LINUX
  #endif
  #define THE_EOL "\n"
  #define THE_PATH_SEP "/"
#endif

#include <ctype.h>
#include <inttypes.h>
#include <openssl/ssl.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#ifdef THE_OS_WINDOWS
  #include <winsock2.h>
  #include <ws2tcpip.h>
  #include <windows.h>
#endif
#ifndef THE_OS_WINDOWS
  #include <netdb.h>
  #include <netinet/in.h>
  #include <sys/socket.h>
  #include <unistd.h>
#endif

bool lib_openssl_init = false;
bool lib_ws2_init = false;

struct buffer {
  unsigned char *d;
  size_t l;
};
struct request {
  #ifdef THE_OS_WINDOWS
    SOCKET fd;
  #else
    int fd;
  #endif
  SSL_CTX *ctx;
  SSL *ssl;
};
struct str {
  char *d;
  size_t l;
};

struct request_Header;
struct request_Request;
struct __THE_1_array_request_Header;
struct request_Response;
struct url_URL;

struct request_Header {
  const struct str __THE_0_name;
  const struct str __THE_0_value;
};
struct request_Request {
  void *_;
};
struct __THE_1_array_request_Header {
  struct request_Header **d;
  size_t l;
};
struct request_Response {
  const struct buffer __THE_0_data;
  const int32_t __THE_0_status;
  const struct __THE_1_array_request_Header __THE_0_headers;
};
struct url_URL {
  const struct str __THE_0_origin;
  const struct str __THE_0_protocol;
  const struct str __THE_0_host;
  const struct str __THE_0_hostname;
  const struct str __THE_0_port;
  const struct str __THE_0_path;
  const struct str __THE_0_pathname;
  const struct str __THE_0_search;
  const struct str __THE_0_hash;
};

void *alloc (size_t);
void *re_alloc (void *, size_t);
struct buffer buffer_copy (const struct buffer);
void buffer_free (struct buffer);
struct str buffer_to_str (struct buffer);
void print (FILE *, const char *, ...);
struct str str_alloc (const char *);
struct str str_copy (const struct str);
char *str_cstr (const struct str);
void str_free (struct str);
struct str str_realloc (struct str, struct str);
struct buffer str_to_buffer (struct str);
void request_close (struct request_Request **);
struct request_Request *request_open (struct str, struct str, struct buffer, struct __THE_1_array_request_Header);
struct request_Response *request_read (struct request_Request **);
char *request_stringifyHeaders (struct __THE_1_array_request_Header, struct url_URL *, struct buffer);
struct url_URL *url_parse (struct str);
struct request_Header *request_Header_alloc (struct str, struct str);
void request_Header_free (struct request_Header *);
void request_Request_free (struct request_Request *);
struct request_Request *request_Request_realloc (struct request_Request *, struct request_Request *);
struct __THE_1_array_request_Header __THE_1_array_request_Header_alloc (size_t, ...);
void __THE_1_array_request_Header_free (struct __THE_1_array_request_Header);
struct request_Response *request_Response_alloc (struct buffer, int32_t, struct __THE_1_array_request_Header);
void request_Response_free (struct request_Response *);
struct request_Response *request_Response_realloc (struct request_Response *, struct request_Response *);
struct url_URL *url_URL_alloc (struct str, struct str, struct str, struct str, struct str, struct str, struct str, struct str, struct str);
void url_URL_free (struct url_URL *);

void *alloc (size_t l) {
  void *r = malloc(l);
  if (r == NULL) {
    fprintf(stderr, "Error: failed to allocate %zu bytes" THE_EOL, l);
    exit(EXIT_FAILURE);
  }
  return r;
}
void *re_alloc (void *d, size_t l) {
  void *r = realloc(d, l);
  if (r == NULL) {
    fprintf(stderr, "Error: failed to reallocate %zu bytes" THE_EOL, l);
    exit(EXIT_FAILURE);
  }
  return r;
}
struct buffer buffer_copy (const struct buffer o) {
  unsigned char *d = alloc(o.l);
  memcpy(d, o.d, o.l);
  return (struct buffer) {d, o.l};
}
void buffer_free (struct buffer o) {
  free(o.d);
}
struct str buffer_to_str (struct buffer b) {
  return (struct str) {(char *) b.d, b.l};
}
void print (FILE *stream, const char *fmt, ...) {
  va_list args;
  va_start(args, fmt);
  char buf[512];
  struct str s;
  while (*fmt) {
    switch (*fmt++) {
      case 't': fputs(va_arg(args, int) ? "true" : "false", stream); break;
      case 'b': sprintf(buf, "%u", va_arg(args, unsigned)); fputs(buf, stream); break;
      case 'c': fputc(va_arg(args, int), stream); break;
      case 'e':
      case 'f':
      case 'g': snprintf(buf, 512, "%f", va_arg(args, double)); fputs(buf, stream); break;
      case 'h':
      case 'j':
      case 'v':
      case 'w': sprintf(buf, "%d", va_arg(args, int)); fputs(buf, stream); break;
      case 'i':
      case 'k': sprintf(buf, "%" PRId32, va_arg(args, int32_t)); fputs(buf, stream); break;
      case 'l': sprintf(buf, "%" PRId64, va_arg(args, int64_t)); fputs(buf, stream); break;
      case 'p': sprintf(buf, "%p", va_arg(args, void *)); fputs(buf, stream); break;
      case 's': s = va_arg(args, struct str); fwrite(s.d, 1, s.l, stream); str_free(s); break;
      case 'u': sprintf(buf, "%" PRIu32, va_arg(args, uint32_t)); fputs(buf, stream); break;
      case 'y': sprintf(buf, "%" PRIu64, va_arg(args, uint64_t)); fputs(buf, stream); break;
      case 'z': fputs(va_arg(args, char *), stream); break;
    }
  }
  va_end(args);
}
struct str str_alloc (const char *r) {
  size_t l = strlen(r);
  char *d = alloc(l);
  memcpy(d, r, l);
  return (struct str) {d, l};
}
struct str str_copy (const struct str s) {
  char *d = alloc(s.l);
  memcpy(d, s.d, s.l);
  return (struct str) {d, s.l};
}
char *str_cstr (const struct str s) {
  char *d = alloc(s.l + 1);
  memcpy(d, s.d, s.l);
  d[s.l] = '\0';
  return d;
}
void str_free (struct str s) {
  free(s.d);
}
struct str str_realloc (struct str s1, struct str s2) {
  free(s1.d);
  return s2;
}
struct buffer str_to_buffer (struct str s) {
  return (struct buffer) {(unsigned char *) s.d, s.l};
}
void request_close (struct request_Request **r) {
  struct request *req = (void *) *r;
  if (req->ssl != NULL) {
    SSL_CTX_free(req->ctx);
    SSL_free(req->ssl);
  } else if (req->fd != 0) {
    #ifdef THE_OS_WINDOWS
      closesocket(req->fd);
    #else
      close(req->fd);
    #endif
  }
  req->fd = 0;
  req->ctx = NULL;
  req->ssl = NULL;
}
struct request_Request *request_open (struct str method, struct str u, struct buffer data, struct __THE_1_array_request_Header headers) {
  struct url_URL *url = url_parse(u);
  if (
    !(url->__THE_0_protocol.l == 5 && memcmp(url->__THE_0_protocol.d, "http:", 5) == 0) &&
    !(url->__THE_0_protocol.l == 6 && memcmp(url->__THE_0_protocol.d, "https:", 6) == 0)
  ) {
    char *protocol = str_cstr(url->__THE_0_protocol);
    fprintf(stderr, "Error: can't perform request with protocol `%s`" THE_EOL, protocol);
    exit(EXIT_FAILURE);
  } else if (url->__THE_0_port.l >= 6) {
    char *port = str_cstr(url->__THE_0_port);
    fprintf(stderr, "Error: invalid port `%s`" THE_EOL, port);
    exit(EXIT_FAILURE);
  }
  char port[6];
  if (url->__THE_0_port.l != 0) {
    memcpy(port, url->__THE_0_port.d, url->__THE_0_port.l);
    port[url->__THE_0_port.l] = '\0';
    unsigned long p = strtoul(port, NULL, 10);
    if (p > 65535) {
      fprintf(stderr, "Error: invalid port `%s`" THE_EOL, port);
      exit(EXIT_FAILURE);
    }
  } else {
    memcpy(port, url->__THE_0_protocol.l == 6 ? "443" : "80", url->__THE_0_protocol.l == 6 ? 3 : 2);
    port[url->__THE_0_protocol.l == 6 ? 3 : 2] = '\0';
  }
  #ifdef THE_OS_WINDOWS
    if (!lib_ws2_init) {
      WSADATA w;
      if (WSAStartup(MAKEWORD(2, 2), &w) != 0) {
        fprintf(stderr, "Error: failed to initialize use of Windows Sockets DLL" THE_EOL);
        exit(EXIT_FAILURE);
      }
      lib_ws2_init = true;
    }
  #endif
  char *hostname = str_cstr(url->__THE_0_hostname);
  struct addrinfo *addr = NULL;
  struct addrinfo hints;
  memset(&hints, 0, sizeof(hints));
  hints.ai_family = AF_INET;
  hints.ai_socktype = SOCK_STREAM;
  hints.ai_protocol = IPPROTO_TCP;
  if (getaddrinfo(hostname, port, &hints, &addr) != 0) {
    fprintf(stderr, "Error: failed to resolve hostname address" THE_EOL);
    exit(EXIT_FAILURE);
  }
  free(hostname);
  struct request *req = alloc(sizeof(struct request));
  req->fd = socket(addr->ai_family, addr->ai_socktype, addr->ai_protocol);
  req->ctx = NULL;
  req->ssl = NULL;
  #ifdef THE_OS_WINDOWS
    bool socket_res = req->fd != INVALID_SOCKET;
  #else
    bool socket_res = req->fd != -1;
  #endif
  if (!socket_res) {
    fprintf(stderr, "Error: failed to create socket" THE_EOL);
    exit(EXIT_FAILURE);
  }
  #ifdef THE_OS_WINDOWS
    bool connect_res = connect(req->fd, addr->ai_addr, (int) addr->ai_addrlen) != SOCKET_ERROR;
  #else
    bool connect_res = connect(req->fd, addr->ai_addr, addr->ai_addrlen) != -1;
  #endif
  if (!connect_res) {
    char *origin = str_cstr(url->__THE_0_origin);
    fprintf(stderr, "Error: failed to connect to `%s`" THE_EOL, origin);
    exit(EXIT_FAILURE);
  }
  freeaddrinfo(addr);
  if (strcmp(port, "443") == 0) {
    if (!lib_openssl_init) {
      SSL_library_init();
      lib_openssl_init = true;
    }
    req->ctx = SSL_CTX_new(TLS_client_method());
    if (req->ctx == NULL) {
      fprintf(stderr, "Error: failed to create SSL context" THE_EOL);
      exit(EXIT_FAILURE);
    }
    req->ssl = SSL_new(req->ctx);
    SSL_set_fd(req->ssl, (int) req->fd);
    if (SSL_connect(req->ssl) != 1) {
      fprintf(stderr, "Error: failed to connect to socket with SSL" THE_EOL);
      exit(EXIT_FAILURE);
    }
  }
  char *req_headers = request_stringifyHeaders(headers, url, data);
  __THE_1_array_request_Header_free(headers);
  char *req_method = str_cstr(method);
  str_free(method);
  char *req_path = str_cstr(url->__THE_0_path);
  char *fmt = "%s %s HTTP/1.1\r\n%s\r\n";
  size_t req_len = snprintf(NULL, 0, fmt, req_method, req_path, req_headers);
  char *request = alloc(req_len + (data.l == 0 ? 0 : data.l + 2) + 1);
  sprintf(request, fmt, req_method, req_path, req_headers);
  free(req_path);
  free(req_method);
  free(req_headers);
  if (data.l != 0) {
    memcpy(&request[req_len], data.d, data.l);
    req_len += data.l;
    memcpy(&request[req_len], "\r\n", 3);
    req_len += 2;
  }
  buffer_free(data);
  #ifdef THE_OS_WINDOWS
    SSIZE_T y = 0, z = 0;
  #else
    ssize_t y = 0, z = 0;
  #endif
  while (y < req_len) {
    z = req->ssl == NULL
      ? send(req->fd, &request[y], req_len - y, 0)
      : SSL_write(req->ssl, &request[y], (int) (req_len - y));
    if (z == -1) {
      fprintf(stderr, "Error: failed to write to socket" THE_EOL);
      exit(EXIT_FAILURE);
    }
    y += z;
  }
  free(request);
  if (req->ssl == NULL) {
    #ifdef THE_OS_WINDOWS
      shutdown(req->fd, SD_SEND);
    #else
      shutdown(req->fd, 1);
    #endif
  } else {
    SSL_shutdown(req->ssl);
  }
  url_URL_free(url);
  return (struct request_Request *) req;
}
struct request_Response *request_read (struct request_Request **r) {
  struct request *req = (void *) *r;
  unsigned char b[1024];
  #ifdef THE_OS_WINDOWS
    SSIZE_T y;
  #else
    ssize_t y;
  #endif
  struct buffer data = {NULL, 0};
  while ((y = (req->ssl == NULL ? recv(req->fd, b, sizeof(b), 0) : SSL_read(req->ssl, b, sizeof(b)))) > 0) {
    data.d = re_alloc(data.d, data.l + y);
    memcpy(&data.d[data.l], b, y);
    data.l += y;
  }
  if (y < 0) {
    fprintf(stderr, "Error: failed to read from socket" THE_EOL);
    exit(EXIT_FAILURE);
  }
  size_t i;
  if (data.l > 8 && (memcmp(data.d, "HTTP/1.0 ", 9) == 0 || memcmp(data.d, "HTTP/1.1 ", 9) == 0)) {
    i = 9;
  } else if (data.l > 6 && (memcmp(data.d, "HTTP/2 ", 7) == 0 || memcmp(data.d, "HTTP/3 ", 7) == 0)) {
    i = 7;
  } else {
    fprintf(stderr, "Error: invalid response HTTP version" THE_EOL);
    exit(EXIT_FAILURE);
  }
  size_t status_start = i;
  while (i < data.l && isdigit(data.d[i])) i++;
  if (status_start == i) {
    fprintf(stderr, "Error: invalid response HTTP status code" THE_EOL);
    exit(EXIT_FAILURE);
  }
  size_t status_len = i - status_start;
  char *status = alloc(status_len + 1);
  memcpy(status, &data.d[status_start], status_len);
  status[status_len] = '\0';
  int32_t status_code = (int32_t) strtoul(status, NULL, 10);
  free(status);
  while (i < data.l) {
    if (data.d[i] == '\r' && i + 1 < data.l && data.d[i + 1] == '\n') {
      i += 2;
      break;
    }
    i++;
  }
  struct __THE_1_array_request_Header headers = {NULL, 0};
  while (true) {
    if (data.d[i] == '\r' && i + 1 < data.l && data.d[i + 1] == '\n') {
      i += 2;
      break;
    }
    size_t header_name_start = i;
    size_t header_name_end = 0;
    size_t header_value_start = 0;
    size_t header_value_end = 0;
    while (i < data.l) {
      if (data.d[i] == '\r' && i + 1 < data.l && data.d[i + 1] == '\n') {
        header_value_end = i;
        i += 2;
        break;
      } else if (data.d[i] == ':' && header_name_end == 0) {
        header_name_end = i;
        i++;
        while (i < data.l && data.d[i] == ' ') i++;
        header_value_start = i;
      }
      i++;
    }
    struct str header_name;
    header_name.l = header_name_end - header_name_start;
    header_name.d = alloc(header_name.l);
    memcpy(header_name.d, &data.d[header_name_start], header_name.l);
    for (size_t j = 0; j < header_name.l; j++) header_name.d[j] = (char) tolower(header_name.d[j]);
    struct str header_value;
    header_value.l = header_value_end - header_value_start;
    header_value.d = alloc(header_value.l);
    memcpy(header_value.d, &data.d[header_value_start], header_value.l);
    headers.d = re_alloc(headers.d, (headers.l + 1) * sizeof(struct request_Header *));
    headers.d[headers.l] = request_Header_alloc(header_name, header_value);
    headers.l++;
  }
  for (size_t j = 0; j < headers.l; j++) {
    for (size_t k = j + 1; k < headers.l; k++) {
      size_t count = headers.d[j]->__THE_0_name.l > headers.d[k]->__THE_0_name.l ? headers.d[k]->__THE_0_name.l : headers.d[j]->__THE_0_name.l;
      if (memcmp(headers.d[j]->__THE_0_name.d, headers.d[k]->__THE_0_name.d, count) > 0) {
        struct request_Header *a = headers.d[j];
        headers.d[j] = headers.d[k];
        headers.d[k] = a;
      }
    }
  }
  if (data.l - i > 0) {
    data.l = data.l - i;
    memmove(data.d, &data.d[i], data.l);
    data.d = re_alloc(data.d, data.l);
  } else {
    free(data.d);
    data.d = NULL;
    data.l = 0;
  }
  return request_Response_alloc(data, status_code, headers);
}
char *request_stringifyHeaders (struct __THE_1_array_request_Header headers, struct url_URL *url, struct buffer data) {
  bool has_content_length = false;
  bool has_host = false;
  char *d = NULL;
  size_t l = 0;
  for (size_t i = 0; i < headers.l; i++) {
    struct request_Header *h = headers.d[i];
    char *name = str_cstr(h->__THE_0_name);
    for (size_t j = 0; j < h->__THE_0_name.l; j++) name[j] = (char) tolower(name[j]);
    if (strcmp(name, "content-length") == 0) has_content_length = true;
    else if (strcmp(name, "host") == 0) has_host = true;
    free(name);
    d = re_alloc(d, l + h->__THE_0_name.l + 2 + h->__THE_0_value.l + 3);
    memcpy(&d[l], h->__THE_0_name.d, h->__THE_0_name.l);
    memcpy(&d[l + h->__THE_0_name.l], ": ", 2);
    memcpy(&d[l + h->__THE_0_name.l + 2], h->__THE_0_value.d, h->__THE_0_value.l);
    memcpy(&d[l + h->__THE_0_name.l + 2 + h->__THE_0_value.l], "\r\n", 3);
    l += h->__THE_0_name.l + 2 + h->__THE_0_value.l + 2;
  }
  if (!has_host) {
    char *h = str_cstr(url->__THE_0_hostname);
    size_t z = snprintf(NULL, 0, "Host: %s\r\n", h);
    d = re_alloc(d, l + z + 1);
    sprintf(&d[l], "Host: %s\r\n", h);
    l += z;
    free(h);
  }
  if (!has_content_length) {
    size_t z = snprintf(NULL, 0, "Content-Length: %zu\r\n", data.l);
    d = re_alloc(d, l + z + 1);
    sprintf(&d[l], "Content-Length: %zu\r\n", data.l);
    l += z;
  }
  return d;
}
struct url_URL *url_parse (struct str s) {
  if (s.l == 0) {
    fprintf(stderr, "Error: invalid URL" THE_EOL);
    exit(EXIT_FAILURE);
  }
  size_t i = 0;
  for (;; i++) {
    char ch = s.d[i];
    if (ch == ':' && i != 0) {
      i++;
      break;
    } else if (!isalnum(ch) && ch != '.' && ch != '-' && ch != '+') {
      fprintf(stderr, "Error: invalid URL protocol" THE_EOL);
      exit(EXIT_FAILURE);
    } else if (i == s.l - 1) {
      fprintf(stderr, "Error: invalid URL" THE_EOL);
      exit(EXIT_FAILURE);
    }
  }
  struct str protocol;
  protocol.l = i;
  protocol.d = alloc(protocol.l);
  memcpy(protocol.d, s.d, protocol.l);
  while (i < s.l && s.d[i] == '/') i++;
  if (i == s.l) {
    str_free(s);
    return url_URL_alloc(str_alloc(""), protocol, str_alloc(""), str_alloc(""), str_alloc(""), str_alloc(""), str_alloc(""), str_alloc(""), str_alloc(""));
  }
  size_t protocol_end = i;
  if ((protocol_end - protocol.l) < 2) {
    i = protocol.l;
    protocol_end = i;
  }
  size_t hostname_start = protocol.l == protocol_end ? 0 : i;
  size_t port_start = 0;
  size_t pathname_start = protocol.l == protocol_end ? i : 0;
  size_t search_start = 0;
  size_t hash_start = 0;
  for (;; i++) {
    char ch = s.d[i];
    if (ch == '@' && hostname_start != 0 && pathname_start == 0) {
      fprintf(stderr, "Error: URL auth is not supported" THE_EOL);
      exit(EXIT_FAILURE);
    } else if (ch == ':' && port_start != 0 && (pathname_start == 0 || search_start == 0 || hash_start == 0)) {
      fprintf(stderr, "Error: invalid URL port" THE_EOL);
      exit(EXIT_FAILURE);
    }
    if (ch == ':' && hostname_start != 0 && pathname_start == 0) port_start = i;
    else if (ch == '/' && pathname_start == 0) pathname_start = i;
    else if (ch == '?' && search_start == 0) search_start = i;
    else if (ch == '#' && hash_start == 0) hash_start = i;
    if (i == s.l - 1) break;
  }
  struct str hostname = str_alloc("");
  size_t hostname_end = port_start != 0 ? port_start : pathname_start != 0 ? pathname_start : search_start != 0 ? search_start : hash_start != 0 ? hash_start : s.l;
  if (hostname_start != 0 && hostname_start == hostname_end) {
    fprintf(stderr, "Error: invalid URL hostname" THE_EOL);
    exit(EXIT_FAILURE);
  } else if (hostname_start != 0 && hostname_start != hostname_end) {
    hostname.l = hostname_end - hostname_start;
    hostname.d = re_alloc(hostname.d, hostname.l);
    memcpy(hostname.d, &s.d[hostname_start], hostname.l);
  }
  struct str port = str_alloc("");
  size_t port_end = pathname_start != 0 ? pathname_start : search_start != 0 ? search_start : hash_start != 0 ? hash_start : s.l;
  if (port_start != 0 && port_start + 1 != port_end) {
    port.l = port_end - port_start - 1;
    port.d = re_alloc(port.d, port.l);
    memcpy(port.d, &s.d[port_start + 1], port.l);
  }
  struct str host = str_alloc("");
  if (hostname.l != 0) {
    host.l = hostname.l + (port.l == 0 ? 0 : port.l + 1);
    host.d = re_alloc(host.d, host.l);
    memcpy(host.d, hostname.d, hostname.l);
    if (port.l != 0) {
      memcpy(&host.d[hostname.l], ":", 1);
      memcpy(&host.d[hostname.l + 1], port.d, port.l);
    }
  }
  struct str origin = str_alloc("");
  if (memcmp(protocol.d, "ftp:", 4) == 0 || memcmp(protocol.d, "http:", 5) == 0 || memcmp(protocol.d, "https:", 6) == 0 || memcmp(protocol.d, "ws:", 3) == 0 || memcmp(protocol.d, "wss:", 4) == 0) {
    if (host.l == 0) {
      fprintf(stderr, "Error: URL origin is not present" THE_EOL);
      exit(EXIT_FAILURE);
    }
    origin.l = protocol.l + 2 + host.l;
    origin.d = re_alloc(origin.d, origin.l);
    memcpy(origin.d, protocol.d, protocol.l);
    memcpy(&origin.d[protocol.l], "//", 2);
    memcpy(&origin.d[protocol.l + 2], host.d, host.l);
  }
  struct str pathname = str_alloc("");
  size_t pathname_end = search_start != 0 ? search_start : hash_start != 0 ? hash_start : s.l;
  if (pathname_start != 0 && pathname_start != pathname_end) {
    pathname.l = pathname_end - pathname_start;
    pathname.d = re_alloc(pathname.d, pathname.l);
    memcpy(pathname.d, &s.d[pathname_start], pathname.l);
  } else if (memcmp(protocol.d, "ftp:", 4) == 0 || memcmp(protocol.d, "http:", 5) == 0 || memcmp(protocol.d, "https:", 6) == 0 || memcmp(protocol.d, "ws:", 3) == 0 || memcmp(protocol.d, "wss:", 4) == 0) {
    pathname.l = 1;
    pathname.d = re_alloc(pathname.d, pathname.l);
    memcpy(pathname.d, "/", pathname.l);
  }
  struct str search = str_alloc("");
  size_t search_end = hash_start != 0 ? hash_start : s.l;
  if (search_start != 0 && search_start != search_end) {
    search.l = search_end - search_start;
    search.d = re_alloc(search.d, search.l);
    memcpy(search.d, &s.d[search_start], search.l);
  }
  struct str path = str_alloc("");
  if (pathname.l != 0 || search.l != 0) {
    path.l = pathname.l + search.l;
    path.d = re_alloc(path.d, path.l);
    if (pathname.l != 0) {
      memcpy(path.d, pathname.d, pathname.l);
      if (search.l != 0) memcpy(&path.d[pathname.l], search.d, search.l);
    } else if (search.l != 0) {
      memcpy(path.d, search.d, search.l);
    }
  }
  struct str hash = str_alloc("");
  if (hash_start != 0) {
    hash.l = s.l - hash_start;
    hash.d = re_alloc(hash.d, hash.l);
    memcpy(hash.d, &s.d[hash_start], hash.l);
  }
  str_free(s);
  return url_URL_alloc(origin, protocol, host, hostname, port, path, pathname, search, hash);
}
struct request_Header *request_Header_alloc (struct str __THE_0_name, struct str __THE_0_value) {
  struct request_Header *r = alloc(sizeof(struct request_Header));
  struct request_Header s = {__THE_0_name, __THE_0_value};
  memcpy(r, &s, sizeof(struct request_Header));
  return r;
}
void request_Header_free (struct request_Header *o) {
  str_free((struct str) o->__THE_0_name);
  str_free((struct str) o->__THE_0_value);
  free(o);
}
void request_Request_free (struct request_Request *o) {
  request_close(&o);
  free(o);
}
struct request_Request *request_Request_realloc (struct request_Request *o1, struct request_Request *o2) {
  request_Request_free((struct request_Request *) o1);
  return o2;
}
struct __THE_1_array_request_Header __THE_1_array_request_Header_alloc (size_t x, ...) {
  if (x == 0) return (struct __THE_1_array_request_Header) {NULL, 0};
  struct request_Header **d = alloc(x * sizeof(struct request_Header *));
  va_list args;
  va_start(args, x);
  for (size_t i = 0; i < x; i++) d[i] = va_arg(args, struct request_Header *);
  va_end(args);
  return (struct __THE_1_array_request_Header) {d, x};
}
void __THE_1_array_request_Header_free (struct __THE_1_array_request_Header n) {
  for (size_t i = 0; i < n.l; i++) request_Header_free((struct request_Header *) n.d[i]);
  free(n.d);
}
struct request_Response *request_Response_alloc (struct buffer __THE_0_data, int32_t __THE_0_status, struct __THE_1_array_request_Header __THE_0_headers) {
  struct request_Response *r = alloc(sizeof(struct request_Response));
  struct request_Response s = {__THE_0_data, __THE_0_status, __THE_0_headers};
  memcpy(r, &s, sizeof(struct request_Response));
  return r;
}
void request_Response_free (struct request_Response *o) {
  buffer_free((struct buffer) o->__THE_0_data);
  __THE_1_array_request_Header_free((struct __THE_1_array_request_Header) o->__THE_0_headers);
  free(o);
}
struct request_Response *request_Response_realloc (struct request_Response *o1, struct request_Response *o2) {
  request_Response_free((struct request_Response *) o1);
  return o2;
}
struct url_URL *url_URL_alloc (struct str __THE_0_origin, struct str __THE_0_protocol, struct str __THE_0_host, struct str __THE_0_hostname, struct str __THE_0_port, struct str __THE_0_path, struct str __THE_0_pathname, struct str __THE_0_search, struct str __THE_0_hash) {
  struct url_URL *r = alloc(sizeof(struct url_URL));
  struct url_URL s = {__THE_0_origin, __THE_0_protocol, __THE_0_host, __THE_0_hostname, __THE_0_port, __THE_0_path, __THE_0_pathname, __THE_0_search, __THE_0_hash};
  memcpy(r, &s, sizeof(struct url_URL));
  return r;
}
void url_URL_free (struct url_URL *o) {
  str_free((struct str) o->__THE_0_origin);
  str_free((struct str) o->__THE_0_protocol);
  str_free((struct str) o->__THE_0_host);
  str_free((struct str) o->__THE_0_hostname);
  str_free((struct str) o->__THE_0_port);
  str_free((struct str) o->__THE_0_path);
  str_free((struct str) o->__THE_0_pathname);
  str_free((struct str) o->__THE_0_search);
  str_free((struct str) o->__THE_0_hash);
  free(o);
}

int main () {
  struct str __THE_0_url_0 = str_alloc("https://httpbin.org/status/200");
  struct request_Request *__THE_0_req_0 = request_open(str_alloc("GET"), str_copy(__THE_0_url_0), (struct buffer) {NULL, 0}, (struct __THE_1_array_request_Header) {NULL, 0});
  struct request_Response *__THE_0_res_0 = request_read(&__THE_0_req_0);
  print(stdout, "zzsziz", "GET", " ", str_copy(__THE_0_url_0), " ", __THE_0_res_0->__THE_0_status, THE_EOL);
  request_close(&__THE_0_req_0);
  __THE_0_url_0 = str_realloc(__THE_0_url_0, str_alloc("https://httpbin.org/status/400"));
  __THE_0_req_0 = request_Request_realloc(__THE_0_req_0, request_open(str_alloc("GET"), str_copy(__THE_0_url_0), (struct buffer) {NULL, 0}, (struct __THE_1_array_request_Header) {NULL, 0}));
  __THE_0_res_0 = request_Response_realloc(__THE_0_res_0, request_read(&__THE_0_req_0));
  print(stdout, "zzsziz", "GET", " ", str_copy(__THE_0_url_0), " ", __THE_0_res_0->__THE_0_status, THE_EOL);
  request_close(&__THE_0_req_0);
  __THE_0_url_0 = str_realloc(__THE_0_url_0, str_alloc("https://httpbin.org/status/500"));
  __THE_0_req_0 = request_Request_realloc(__THE_0_req_0, request_open(str_alloc("GET"), str_copy(__THE_0_url_0), (struct buffer) {NULL, 0}, (struct __THE_1_array_request_Header) {NULL, 0}));
  __THE_0_res_0 = request_Response_realloc(__THE_0_res_0, request_read(&__THE_0_req_0));
  print(stdout, "zzsziz", "GET", " ", str_copy(__THE_0_url_0), " ", __THE_0_res_0->__THE_0_status, THE_EOL);
  request_close(&__THE_0_req_0);
  print(stdout, "z", THE_EOL);
  __THE_0_req_0 = request_Request_realloc(__THE_0_req_0, request_open(str_alloc("POST"), str_alloc("https://httpbin.org/anything"), str_to_buffer(str_alloc("")), __THE_1_array_request_Header_alloc(0)));
  __THE_0_res_0 = request_Response_realloc(__THE_0_res_0, request_read(&__THE_0_req_0));
  print(stdout, "sz", buffer_to_str(buffer_copy(__THE_0_res_0->__THE_0_data)), THE_EOL);
  request_close(&__THE_0_req_0);
  __THE_0_req_0 = request_Request_realloc(__THE_0_req_0, request_open(str_alloc("POST"), str_alloc("https://httpbin.org/anything"), str_to_buffer(str_alloc("test")), (struct __THE_1_array_request_Header) {NULL, 0}));
  __THE_0_res_0 = request_Response_realloc(__THE_0_res_0, request_read(&__THE_0_req_0));
  print(stdout, "sz", buffer_to_str(buffer_copy(__THE_0_res_0->__THE_0_data)), THE_EOL);
  request_close(&__THE_0_req_0);
  __THE_0_req_0 = request_Request_realloc(__THE_0_req_0, request_open(str_alloc("POST"), str_alloc("https://httpbin.org/anything"), str_to_buffer(str_alloc("test1=value1&test2=value2")), __THE_1_array_request_Header_alloc(2, request_Header_alloc(str_alloc("content-type"), str_alloc("application/x-www-form-urlencoded")), request_Header_alloc(str_alloc("custom-header"), str_alloc("custom-value")))));
  __THE_0_res_0 = request_Response_realloc(__THE_0_res_0, request_read(&__THE_0_req_0));
  print(stdout, "sz", buffer_to_str(buffer_copy(__THE_0_res_0->__THE_0_data)), THE_EOL);
  request_close(&__THE_0_req_0);
  request_Response_free((struct request_Response *) __THE_0_res_0);
  request_Request_free((struct request_Request *) __THE_0_req_0);
  str_free((struct str) __THE_0_url_0);
}
======= flags =======
U:-lssl W:-lWs2_32 W:-llibssl
======= stdout =======
GET https://httpbin.org/status/200 200
GET https://httpbin.org/status/400 400
GET https://httpbin.org/status/500 500

{{{ \s+ }}"args": {},{{ \s+ }}"data": "",{{ \s+ }}"files": {},{{ \s+ }}"form": {},{{ \s+ }}"headers": {{{ \s+ }}"Content-Length": "0",{{ \s+ }}"Host": "httpbin.org",{{ \s+ }}"X-Amzn-Trace-Id": "{{ [^"]+ }}"{{ \s+ }}},{{ \s+ }}"json": null,{{ \s+ }}"method": "POST",{{ \s+ }}"origin": "{{ [^"]+ }}",{{ \s+ }}"url": "https://httpbin.org/anything"{{ \s+ }}}{{ \n }}
{{{ \s+ }}"args": {},{{ \s+ }}"data": "test",{{ \s+ }}"files": {},{{ \s+ }}"form": {},{{ \s+ }}"headers": {{{ \s+ }}"Content-Length": "4",{{ \s+ }}"Host": "httpbin.org",{{ \s+ }}"X-Amzn-Trace-Id": "{{ [^"]+ }}"{{ \s+ }}},{{ \s+ }}"json": null,{{ \s+ }}"method": "POST",{{ \s+ }}"origin": "{{ [^"]+ }}",{{ \s+ }}"url": "https://httpbin.org/anything"{{ \s+ }}}{{ \n }}
{{{ \s+ }}"args": {},{{ \s+ }}"data": "",{{ \s+ }}"files": {},{{ \s+ }}"form": {{{ \s+ }}"test1": "value1",{{ \s+ }}"test2": "value2"{{ \s+ }}},{{ \s+ }}"headers": {{{ \s+ }}"Content-Length": "25",{{ \s+ }}"Content-Type": "application/x-www-form-urlencoded",{{ \s+ }}"Custom-Header": "custom-value",{{ \s+ }}"Host": "httpbin.org",{{ \s+ }}"X-Amzn-Trace-Id": "{{ [^"]+ }}"{{ \s+ }}},{{ \s+ }}"json": null,{{ \s+ }}"method": "POST",{{ \s+ }}"origin": "{{ [^"]+ }}",{{ \s+ }}"url": "https://httpbin.org/anything"{{ \s+ }}}{{ \n }}
