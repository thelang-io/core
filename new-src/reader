/*!
 * Copyright (c) Aaron Delasy
 *
 * Unauthorized copying of this file, via any medium is strictly prohibited
 * Proprietary and confidential
 */

fn Reader_init (p: str) Reader {
  path := realpathSync(p)

  if !isFileSync(path) {
    RaiseError("Path \"" + path + "\" is not a file")
  }

  content := readFileSync(path, "utf8")
  return Reader{path: path, content: content}
}

fn Reader_eof (self: ref Reader) bool {
  return self.pos >= self.content.len
}

fn Reader_lookahead (mut self: ref Reader, check: char) bool {
  if self.pos + 1 >= self.content.len {
    return false
  }

  ch := self.content[self.pos + 1]

  if (
    OS == "Windows" &&
    ch == '\r' &&
    self.pos + 2 < self.content.len &&
    self.content[self.pos + 2] == '\n'
  ) {
    if check == '\n' {
      self.pos += 2
      return true
    }
  } elif check == ch {
    self.pos++
    return true
  }

  return false
}

fn Reader_next (mut self: ref Reader) char {
  if Reader_eof(self) {
    RaiseError("Tried to read on eof")
  }

  ch1 := self.content[self.pos]
  self.pos++

  if OS == "Windows" && ch1 == '\r' && !Reader_eof(self) {
    ch2 := self.content[self.pos]

    if ch2 == '\n' {
      self.pos++
      return ch2
    }
  }

  return ch1
}

fn Reader_seek (mut self: ref Reader, pos: int) {
  self.pos = pos
}

fn Reader_slice (self: ref Reader, start: int?, end: int?) str {
  return self.content.slice(start, end)
}

fn Reader_walk (mut self: ref Reader, match: fn (char) bool) {
  loop !Reader_eof(self) {
    pos := self.pos
    ch := Reader_next(self)

    if !match(ch) {
      Reader_seek(self, pos)
      break
    }
  }
}
